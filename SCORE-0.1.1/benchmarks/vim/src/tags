!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.6	//
ABBREV	vim.h	244;"	d
ABBR_OFF	keymap.h	40;"	d
ACTION_EXPAND	vim.h	316;"	d
ACTION_GOTO	vim.h	312;"	d
ACTION_SHOW	vim.h	311;"	d
ACTION_SHOW_ALL	vim.h	314;"	d
ACTION_SPLIT	vim.h	313;"	d
ALEF	farsi.h	110;"	d
ALEF_	farsi.h	29;"	d
ALEF_A	farsi.h	109;"	d
ALEF_D_H	farsi.h	168;"	d
ALEF_U_H	farsi.h	166;"	d
ALEF_U_H_	farsi.h	28;"	d
ALIGN_LONG	structs.h	122;"	d
ALIGN_MASK	structs.h	128;"	d
ALIGN_SIZE	structs.h	123;"	d
ALIGN_SIZE	structs.h	125;"	d
ALL_BUILTIN_TCAPS	feature.h	248;"	d
ALWAYS_USE_GUI	gui.h	64;"	d
ANY	regexp.c	88;"	d	file:
ANYBUT	regexp.c	90;"	d	file:
ANYOF	regexp.c	89;"	d	file:
APPENDBIN	vim.h	595;"	d
APPENDBIN	vim.h	599;"	d
ASKMORE	vim.h	242;"	d
ATTR_OFF	syntax.c	86;"	d	file:
AT_CURSOR	farsi.h	178;"	d
AUGROUP_ALL	fileio.c	2653;"	d	file:
AUGROUP_DEFAULT	fileio.c	2651;"	d	file:
AUGROUP_ERROR	fileio.c	2652;"	d	file:
AUGROUP_NAME	fileio.c	2646;"	d	file:
AUTOCMD	feature.h	197;"	d
AYN	farsi.h	131;"	d
AYN_	farsi.h	44;"	d
AppendCharToRedobuff	getchar.c	/^AppendCharToRedobuff(c)$/;"	f
AppendNumberToRedobuff	getchar.c	/^AppendNumberToRedobuff(n)$/;"	f
AppendToRedobuff	getchar.c	/^AppendToRedobuff(s)$/;"	f
AutoCmd	fileio.c	/^typedef struct AutoCmd$/;"	s	file:
AutoCmd	fileio.c	/^} AutoCmd;$/;"	t	typeref:struct:AutoCmd	file:
AutoPat	fileio.c	/^typedef struct AutoPat$/;"	s	file:
AutoPat	fileio.c	/^} AutoPat;$/;"	t	typeref:struct:AutoPat	file:
AutoPatCmd	fileio.c	/^typedef struct AutoPatCmd$/;"	s	file:
AutoPatCmd	fileio.c	/^} AutoPatCmd;$/;"	t	typeref:struct:AutoPatCmd	file:
B0_FNAME_SIZE	memline.c	127;"	d	file:
B0_HNAME_SIZE	memline.c	129;"	d	file:
B0_MAGIC_CHAR	memline.c	138;"	d	file:
B0_MAGIC_INT	memline.c	136;"	d	file:
B0_MAGIC_LONG	memline.c	135;"	d	file:
B0_MAGIC_SHORT	memline.c	137;"	d	file:
B0_UNAME_SIZE	memline.c	128;"	d	file:
BACK	regexp.c	94;"	d	file:
BACKREF	regexp.c	120;"	d	file:
BACKSPACE_CHAR	edit.c	94;"	d	file:
BACKSPACE_LINE	edit.c	97;"	d	file:
BACKSPACE_WORD	edit.c	95;"	d	file:
BACKSPACE_WORD_NOT_SPACE	edit.c	96;"	d	file:
BACKWARD	vim.h	250;"	d
BANG	ex_cmds.h	35;"	d
BASENAMELEN	os_unix.h	150;"	d
BC	term.c	/^char *UP, *BC, PC;$/;"	v
BCO_ALWAYS	vim.h	423;"	d
BCO_ENTER	vim.h	422;"	d
BCO_NOHELP	vim.h	424;"	d
BE	farsi.h	112;"	d
BF_CHECK_RO	vim.h	259;"	d
BF_NEVERLOADED	vim.h	262;"	d
BF_RECOVERED	vim.h	258;"	d
BHDR	structs.h	/^typedef struct block_hdr    BHDR;$/;"	t	typeref:struct:block_hdr
BH_DIRTY	structs.h	201;"	d
BH_LOCKED	structs.h	202;"	d
BINARY_TAGS	feature.h	165;"	d
BLOCK0_ID0	memline.c	67;"	d	file:
BLOCK0_ID1	memline.c	68;"	d	file:
BL_FIX	vim.h	413;"	d
BL_SOL	vim.h	412;"	d
BL_WHITE	vim.h	411;"	d
BOL	regexp.c	86;"	d	file:
BOTH_DIRECTIONS	vim.h	251;"	d
BOW	regexp.c	103;"	d	file:
BRACE_AT_END	misc1.c	2999;"	d	file:
BRACE_AT_START	misc1.c	2998;"	d	file:
BRACE_COMPLEX	regexp.c	121;"	d	file:
BRACE_IN_COL0	misc1.c	2997;"	d	file:
BRACE_LIMITS	regexp.c	113;"	d	file:
BRACE_SIMPLE	regexp.c	101;"	d	file:
BRANCH	regexp.c	92;"	d	file:
BREAKCHECK_SKIP	misc1.c	4234;"	d	file:
BREAKCHECK_SKIP	misc1.c	4236;"	d	file:
BS	ascii.h	14;"	d
BT_EXTRA_KEYS	term.c	72;"	d	file:
BUF	structs.h	/^typedef struct buffer BUF;$/;"	t	typeref:struct:buffer
BUFFER_SIZE	if_python.c	158;"	d	file:
BUFNAME	ex_cmds.h	50;"	d
BUFSIZE	fileio.c	31;"	d	file:
BVAR_ENTRY	eval.c	51;"	d	file:
BufListAsSeq	if_python.c	/^static PySequenceMethods BufListAsSeq = {$/;"	v	file:
BufListItem	if_python.c	/^BufListItem(PyObject *self, int n)$/;"	f	file:
BufListLength	if_python.c	/^BufListLength(PyObject *self)$/;"	f	file:
BufListObject	if_python.c	/^BufListObject;$/;"	t	typeref:struct:__anon8	file:
BufListType	if_python.c	/^static PyTypeObject BufListType = {$/;"	v	file:
BufferAppend	if_python.c	/^BufferAppend(PyObject *self, PyObject *args)$/;"	f	file:
BufferAsSeq	if_python.c	/^static PySequenceMethods BufferAsSeq = {$/;"	v	file:
BufferAssItem	if_python.c	/^BufferAssItem(PyObject *self, int n, PyObject *val)$/;"	f	file:
BufferAssSlice	if_python.c	/^BufferAssSlice(PyObject *self, int lo, int hi, PyObject *val)$/;"	f	file:
BufferDestructor	if_python.c	/^BufferDestructor(PyObject *self)$/;"	f	file:
BufferGetattr	if_python.c	/^BufferGetattr(PyObject *self, char *name)$/;"	f	file:
BufferItem	if_python.c	/^BufferItem(PyObject *self, int n)$/;"	f	file:
BufferLength	if_python.c	/^BufferLength(PyObject *self)$/;"	f	file:
BufferMark	if_python.c	/^BufferMark(PyObject *self, PyObject *args)$/;"	f	file:
BufferMethods	if_python.c	/^static struct PyMethodDef BufferMethods[] = {$/;"	v	typeref:struct:PyMethodDef	file:
BufferNew	if_python.c	/^BufferNew(BUF *buf)$/;"	f	file:
BufferObject	if_python.c	/^BufferObject;$/;"	t	typeref:struct:__anon6	file:
BufferRange	if_python.c	/^BufferRange(PyObject *self, PyObject *args)$/;"	f	file:
BufferRepr	if_python.c	/^BufferRepr(PyObject *self)$/;"	f	file:
BufferSlice	if_python.c	/^BufferSlice(PyObject *self, int lo, int hi)$/;"	f	file:
BufferType	if_python.c	/^static PyTypeObject BufferType = {$/;"	v	file:
BufferType	if_python.c	/^static PyTypeObject BufferType;$/;"	v	file:
BufferType_Check	if_python.c	525;"	d	file:
CHANGED	vim.h	612;"	d
CHARSIZE	macros.h	56;"	d
CHAR_ID	vim.h	439;"	d
CHAR_IF	vim.h	440;"	d
CHAR_IP	vim.h	438;"	d
CHAR_MASK	vim.h	437;"	d
CHE	farsi.h	117;"	d
CHECK	memline.c	11;"	d	file:
CHECK_INODE	os_unix.h	263;"	d
CHECK_INODE	vim.h	104;"	d
CHECK_PATH	vim.h	309;"	d
CINDENT	feature.h	270;"	d
CLEAR	vim.h	204;"	d
CLIPBOARD_REGISTER	ops.c	35;"	d	file:
CMDARG	structs.h	/^} CMDARG;$/;"	t	typeref:struct:cmdarg
CMDBUFFSIZE	os_unix.h	260;"	d
CMDBUFFSIZE	vim.h	572;"	d
CMDIDX	ex_cmds.h	/^typedef enum CMD_index CMDIDX;$/;"	t	typeref:enum:CMD_index
CMDLINE	vim.h	236;"	d
COL_RULER	option.c	3344;"	d	file:
COM_ALL	option.h	169;"	d
COM_BLANK	option.h	162;"	d
COM_END	option.h	165;"	d
COM_FIRST	option.h	166;"	d
COM_LEFT	option.h	167;"	d
COM_MAX_LEN	option.h	170;"	d
COM_MIDDLE	option.h	164;"	d
COM_NEST	option.h	161;"	d
COM_RIGHT	option.h	168;"	d
COM_START	option.h	163;"	d
CONTAINS_ALLBUT	syntax.c	210;"	d	file:
CONTEXT_UNKNOWN	vim.h	268;"	d
CONT_ADDING	globals.h	86;"	d
CONT_INTRPT	globals.h	87;"	d
CONT_LOCAL	globals.h	94;"	d
CONT_N_ADDS	globals.h	89;"	d
CONT_SOL	globals.h	92;"	d
CONT_S_IPOS	globals.h	90;"	d
COUNT	ex_cmds.h	44;"	d
CPO_ALL	option.h	117;"	d
CPO_ALTREAD	option.h	88;"	d
CPO_ALTWRITE	option.h	89;"	d
CPO_BAR	option.h	90;"	d
CPO_BSLASH	option.h	91;"	d
CPO_BUFOPT	option.h	105;"	d
CPO_BUFOPTGLOB	option.h	106;"	d
CPO_CW	option.h	109;"	d
CPO_DEFAULT	option.h	116;"	d
CPO_DOLLAR	option.h	112;"	d
CPO_DOTTAG	option.h	93;"	d
CPO_EMPTYREGION	option.h	95;"	d
CPO_ESC	option.h	111;"	d
CPO_EXECBUF	option.h	94;"	d
CPO_FILTER	option.h	113;"	d
CPO_FNAMER	option.h	96;"	d
CPO_FNAMEW	option.h	97;"	d
CPO_FWRITE	option.h	110;"	d
CPO_JOINSP	option.h	98;"	d
CPO_KEYCODE	option.h	99;"	d
CPO_LINEOFF	option.h	103;"	d
CPO_LISTWM	option.h	101;"	d
CPO_LITERAL	option.h	100;"	d
CPO_MATCH	option.h	114;"	d
CPO_REDO	option.h	104;"	d
CPO_SEARCH	option.h	92;"	d
CPO_SHOWMATCH	option.h	102;"	d
CPO_SPECI	option.h	115;"	d
CPO_TAGPAT	option.h	107;"	d
CPO_UNDO	option.h	108;"	d
CR	ascii.h	19;"	d
SCORE_getc	getchar.c	/^int SCORE_getc(FILE* file) {$/;"	f
CSF_ACTIVE	ex_docmd.c	44;"	d	file:
CSF_TRUE	ex_docmd.c	43;"	d	file:
CSF_WHILE	ex_docmd.c	45;"	d	file:
CSI	ascii.h	23;"	d
CSTACK_LEN	ex_docmd.c	30;"	d	file:
CTERM_ATTR_ENTRY	syntax.c	4747;"	d	file:
CTRL_X_DICTIONARY	edit.c	29;"	d	file:
CTRL_X_FILES	edit.c	24;"	d	file:
CTRL_X_FINISHED	edit.c	28;"	d	file:
CTRL_X_NOT_DEFINED_YET	edit.c	21;"	d	file:
CTRL_X_PATH_DEFINES	edit.c	27;"	d	file:
CTRL_X_PATH_PATTERNS	edit.c	26;"	d	file:
CTRL_X_SCROLL	edit.c	22;"	d	file:
CTRL_X_TAGS	edit.c	25;"	d	file:
CTRL_X_WANT_IDENT	edit.c	19;"	d	file:
CTRL_X_WHOLE_LINE	edit.c	23;"	d	file:
CURSOR_MOVED	vim.h	771;"	d
CUR_STATE	syntax.c	252;"	d	file:
CV	proto.h	137;"	d
C_X_SKIP	edit.c	31;"	d	file:
CheckBuffer	if_python.c	/^CheckBuffer(BufferObject *this)$/;"	f	file:
CheckWindow	if_python.c	/^CheckWindow(WindowObject *this)$/;"	f	file:
Columns	globals.h	/^EXTERN long	Columns INIT(= MIN_COLUMNS); \/* nr of columns in the screen *\/$/;"	v
Completion	edit.c	/^struct Completion$/;"	s	file:
Ctrl	ascii.h	25;"	d
CurrentGetattr	if_python.c	/^CurrentGetattr(PyObject *self, char *name)$/;"	f	file:
CurrentObject	if_python.c	/^CurrentObject;$/;"	t	typeref:struct:__anon10	file:
CurrentSetattr	if_python.c	/^CurrentSetattr(PyObject *self, char *name, PyObject *value)$/;"	f	file:
CurrentType	if_python.c	/^static PyTypeObject CurrentType = {$/;"	v	file:
D	gui.h	12;"	d
DAL	farsi.h	120;"	d
DATA_BL	memline.c	/^typedef struct data_block	DATA_BL;    \/* contents of a data block *\/$/;"	t	typeref:struct:data_block	file:
DATA_ID	memline.c	65;"	d	file:
DB_INDEX_MASK	memline.c	122;"	d	file:
DB_MARKED	memline.c	121;"	d	file:
DEBUG	regexp.c	42;"	d	file:
DEC_MOUSE	feature.h	398;"	d
DEFAULT_TERM	term.c	1004;"	d	file:
DEFAULT_TERM	term.c	1008;"	d	file:
DEFAULT_TERM	term.c	1012;"	d	file:
DEFAULT_TERM	term.c	1016;"	d	file:
DEFAULT_TERM	term.c	1020;"	d	file:
DEFAULT_TERM	term.c	1024;"	d	file:
DEFAULT_TERM	term.c	1028;"	d	file:
DEFAULT_TERM	term.c	1032;"	d	file:
DEFAULT_TERM	term.c	1033;"	d	file:
DEFAULT_TERM	term.c	1037;"	d	file:
DEF_BDIR	os_unix.h	217;"	d
DEF_BDIR	os_unix.h	219;"	d
DEF_DIR	os_unix.h	225;"	d
DEF_DIR	os_unix.h	227;"	d
DEL	ascii.h	22;"	d
DELETION_REGISTER	ops.c	33;"	d	file:
DFLALL	ex_cmds.h	39;"	d
DICT_EXACT	edit.c	1460;"	d	file:
DICT_FIRST	edit.c	1459;"	d	file:
DIGRAPHS	feature.h	55;"	d
DOBUF_CURRENT	vim.h	378;"	d
DOBUF_DEL	vim.h	375;"	d
DOBUF_FIRST	vim.h	379;"	d
DOBUF_GOTO	vim.h	372;"	d
DOBUF_LAST	vim.h	380;"	d
DOBUF_MOD	vim.h	381;"	d
DOBUF_SPLIT	vim.h	373;"	d
DOBUF_UNLOAD	vim.h	374;"	d
DOCMD_NOWAIT	vim.h	407;"	d
DOCMD_REPEAT	vim.h	408;"	d
DOCMD_VERBOSE	vim.h	406;"	d
DO_DECLARE_EXCMD	ex_docmd.c	15;"	d	file:
DO_INIT	globals.h	21;"	d
DO_JOIN	vim.h	551;"	d
DRAW_BOLD	gui.h	130;"	d
DRAW_TRANSP	gui.h	129;"	d
DRAW_UNDERL	gui.h	131;"	d
DT_FIRST	vim.h	449;"	d
DT_HELP	vim.h	452;"	d
DT_LAST	vim.h	450;"	d
DT_NEXT	vim.h	447;"	d
DT_POP	vim.h	446;"	d
DT_PREV	vim.h	448;"	d
DT_SELECT	vim.h	451;"	d
DT_TAG	vim.h	445;"	d
DoPythonCommand	if_python.c	/^DoPythonCommand(EXARG *eap, const char *cmd)$/;"	f	file:
ECMD_FORCEIT	vim.h	403;"	d
ECMD_HIDE	vim.h	399;"	d
ECMD_OLDBUF	vim.h	402;"	d
ECMD_SET_HELP	vim.h	400;"	d
EDITCMD	ex_cmds.h	49;"	d
EDIT_FILE	main.c	207;"	d	file:
EDIT_NONE	main.c	206;"	d	file:
EDIT_QF	main.c	210;"	d	file:
EDIT_STDIN	main.c	208;"	d	file:
EDIT_TAG	main.c	209;"	d	file:
EFM_DFLT	option.h	27;"	d
EFM_DFLT	option.h	30;"	d
EFM_DFLT	option.h	33;"	d
EFM_DFLT	option.h	36;"	d
EFM_DFLT	option.h	38;"	d
EMACS_TAGS	feature.h	157;"	d
EMSG	vim.h	651;"	d
EMSG2	vim.h	652;"	d
EMSGN	vim.h	653;"	d
EMSG_RETURN	regexp.c	179;"	d	file:
END	regexp.c	85;"	d	file:
END_PAGE_DATA	gui_at_sb.h	140;"	d
EOL	regexp.c	87;"	d	file:
EOL_DOS	option.h	69;"	d
EOL_MAC	option.h	70;"	d
EOL_UNIX	option.h	68;"	d
EOL_UNKNOWN	option.h	67;"	d
EOW	regexp.c	104;"	d	file:
ERRORFILE	os_unix.h	231;"	d
ERROR_INVARG	eval.c	1296;"	d	file:
ERROR_NONE	eval.c	1295;"	d	file:
ERROR_OTHER	eval.c	1298;"	d	file:
ERROR_UNKOWN	eval.c	1297;"	d	file:
ESC	ascii.h	20;"	d
ESC_STR	ascii.h	21;"	d
EVENT_BUFDELETE	vim.h	/^    EVENT_BUFDELETE = 0,    \/* just before deleting a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFENTER	vim.h	/^    EVENT_BUFENTER,	    \/* after entering a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFLEAVE	vim.h	/^    EVENT_BUFLEAVE,	    \/* before leaving a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFNEWFILE	vim.h	/^    EVENT_BUFNEWFILE,	    \/* when creating a buffer for a new file *\/$/;"	e	enum:auto_event
EVENT_BUFREADPOST	vim.h	/^    EVENT_BUFREADPOST,	    \/* after reading a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFREADPRE	vim.h	/^    EVENT_BUFREADPRE,	    \/* before reading a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFUNLOAD	vim.h	/^    EVENT_BUFUNLOAD,	    \/* just before unloading a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFWRITEPOST	vim.h	/^    EVENT_BUFWRITEPOST,	    \/* after writing a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFWRITEPRE	vim.h	/^    EVENT_BUFWRITEPRE,	    \/* before writing a buffer *\/$/;"	e	enum:auto_event
EVENT_FILEAPPENDPOST	vim.h	/^    EVENT_FILEAPPENDPOST,   \/* after appending to a file *\/$/;"	e	enum:auto_event
EVENT_FILEAPPENDPRE	vim.h	/^    EVENT_FILEAPPENDPRE,    \/* before appending to a file *\/$/;"	e	enum:auto_event
EVENT_FILECHANGEDSHELL	vim.h	/^    EVENT_FILECHANGEDSHELL, \/* after shell command that changed file *\/$/;"	e	enum:auto_event
EVENT_FILEREADPOST	vim.h	/^    EVENT_FILEREADPOST,	    \/* after reading a file *\/$/;"	e	enum:auto_event
EVENT_FILEREADPRE	vim.h	/^    EVENT_FILEREADPRE,	    \/* before reading a file *\/$/;"	e	enum:auto_event
EVENT_FILEWRITEPOST	vim.h	/^    EVENT_FILEWRITEPOST,    \/* after writing a file *\/$/;"	e	enum:auto_event
EVENT_FILEWRITEPRE	vim.h	/^    EVENT_FILEWRITEPRE,	    \/* before writing a file *\/$/;"	e	enum:auto_event
EVENT_FILTERREADPOST	vim.h	/^    EVENT_FILTERREADPOST,   \/* after reading from a filter *\/$/;"	e	enum:auto_event
EVENT_FILTERREADPRE	vim.h	/^    EVENT_FILTERREADPRE,    \/* before reading from a filter *\/$/;"	e	enum:auto_event
EVENT_FILTERWRITEPOST	vim.h	/^    EVENT_FILTERWRITEPOST,  \/* after writing to a filter *\/$/;"	e	enum:auto_event
EVENT_FILTERWRITEPRE	vim.h	/^    EVENT_FILTERWRITEPRE,   \/* before writing to a filter *\/$/;"	e	enum:auto_event
EVENT_STDINREADPOST	vim.h	/^    EVENT_STDINREADPOST,    \/* after reading from stdin *\/$/;"	e	enum:auto_event
EVENT_STDINREADPRE	vim.h	/^    EVENT_STDINREADPRE,	    \/* before reading from stdin *\/$/;"	e	enum:auto_event
EVENT_T	vim.h	/^typedef enum auto_event EVENT_T;$/;"	t	typeref:enum:auto_event
EVENT_TERMCHANGED	vim.h	/^    EVENT_TERMCHANGED,	    \/* after changing 'term' *\/$/;"	e	enum:auto_event
EVENT_USER	vim.h	/^    EVENT_USER,		    \/* user defined autocommand *\/$/;"	e	enum:auto_event
EVENT_VIMLEAVE	vim.h	/^    EVENT_VIMLEAVE,	    \/* before exiting Vim *\/$/;"	e	enum:auto_event
EVENT_WINENTER	vim.h	/^    EVENT_WINENTER,	    \/* after entering a window *\/$/;"	e	enum:auto_event
EVENT_WINLEAVE	vim.h	/^    EVENT_WINLEAVE,	    \/* before leaving a window *\/$/;"	e	enum:auto_event
EW_DIR	vim.h	299;"	d
EW_FILE	vim.h	300;"	d
EW_NOTFOUND	vim.h	301;"	d
EXACTLY	regexp.c	95;"	d	file:
EXARG	ex_cmds.h	/^} EXARG;$/;"	t	typeref:struct:exarg
EXCMD	ex_cmds.h	27;"	d
EXCMD	ex_cmds.h	29;"	d
EXCMD	ex_cmds.h	31;"	d
EXPAND_AUGROUP	vim.h	284;"	d
EXPAND_BOOL_SETTINGS	vim.h	275;"	d
EXPAND_BUFFERS	vim.h	279;"	d
EXPAND_COMMANDS	vim.h	271;"	d
EXPAND_DIRECTORIES	vim.h	273;"	d
EXPAND_EVENTS	vim.h	280;"	d
EXPAND_FILES	vim.h	272;"	d
EXPAND_HELP	vim.h	278;"	d
EXPAND_HIGHLIGHT	vim.h	283;"	d
EXPAND_MENUS	vim.h	281;"	d
EXPAND_NOTHING	vim.h	270;"	d
EXPAND_OLD_SETTING	vim.h	277;"	d
EXPAND_SETTINGS	vim.h	274;"	d
EXPAND_SYNTAX	vim.h	282;"	d
EXPAND_TAGS	vim.h	276;"	d
EXPAND_UNSUCCESSFUL	vim.h	269;"	d
EXPL_ALLOC_INC	os_unix.c	2573;"	d	file:
EXP_CASE	syntax.c	/^    EXP_CASE	    \/* expand ":syn case" arguments *\/$/;"	e	enum:__anon3	file:
EXP_SUBCMD	syntax.c	/^    EXP_SUBCMD,	    \/* expand ":syn" sub-commands *\/$/;"	e	enum:__anon3	file:
EXRC_FILE	os_unix.h	198;"	d
EXTERN	globals.h	16;"	d
EXTERN	main.c	9;"	d	file:
EXTERN	option.h	16;"	d
EXTERNCMD	vim.h	245;"	d
EXTRA	ex_cmds.h	36;"	d
EXTRA_MARKS	mark.c	26;"	d	file:
EXTRA_SEARCH	feature.h	105;"	d
EX_EXTRA	feature.h	97;"	d
Error	if_python.c	/^static OutputObject Error =$/;"	v	file:
Exec_reg	globals.h	/^EXTERN int	Exec_reg INIT(= FALSE);	\/* TRUE when executing a register *\/$/;"	v
ExpandBufnames	buffer.c	/^ExpandBufnames(pat, num_file, file, options)$/;"	f
ExpandFromContext	ex_getln.c	/^ExpandFromContext(pat, num_file, file, files_only, options)$/;"	f	file:
ExpandGeneric	ex_getln.c	/^ExpandGeneric(prog, num_file, file, func)$/;"	f
ExpandOldSetting	option.c	/^ExpandOldSetting(num_file, file)$/;"	f
ExpandOne	ex_getln.c	/^ExpandOne(str, orig, options, mode)$/;"	f
ExpandSettings	option.c	/^ExpandSettings(prog, num_file, file)$/;"	f
FAIL	vim.h	255;"	d
FALSE	vim.h	526;"	d
FARSI_0	farsi.h	91;"	d
FARSI_1	farsi.h	92;"	d
FARSI_2	farsi.h	93;"	d
FARSI_3	farsi.h	94;"	d
FARSI_4	farsi.h	95;"	d
FARSI_5	farsi.h	96;"	d
FARSI_6	farsi.h	97;"	d
FARSI_7	farsi.h	98;"	d
FARSI_8	farsi.h	99;"	d
FARSI_9	farsi.h	100;"	d
FE	farsi.h	133;"	d
FF	ascii.h	18;"	d
FFS_DFLT	option.h	51;"	d
FFS_DFLT	option.h	57;"	d
FFS_DFLT	option.h	60;"	d
FFS_VI	option.h	52;"	d
FFS_VI	option.h	62;"	d
FF_DFLT	option.h	50;"	d
FF_DFLT	option.h	56;"	d
FF_DFLT	option.h	59;"	d
FF_DOS	option.h	45;"	d
FF_MAC	option.h	46;"	d
FF_UNIX	option.h	47;"	d
FILE1	ex_cmds.h	53;"	d
FILES	ex_cmds.h	51;"	d
FILE_IN_PATH	feature.h	120;"	d
FILL_X	gui.h	81;"	d
FILL_Y	gui.h	82;"	d
FIND_ANY	vim.h	307;"	d
FIND_DEFINE	vim.h	308;"	d
FIND_IDENT	vim.h	333;"	d
FIND_IN_PATH	feature.h	129;"	d
FIND_STRING	vim.h	334;"	d
FKMAP	feature.h	149;"	d
FM_BACKWARD	vim.h	366;"	d
FM_BLOCKSTOP	vim.h	368;"	d
FM_FORWARD	vim.h	367;"	d
FM_SKIPCOMM	vim.h	369;"	d
FNAME	regexp.c	107;"	d	file:
FNAME_EXP	vim.h	338;"	d
FNAME_HYP	vim.h	339;"	d
FNAME_MESS	vim.h	337;"	d
FORWARD	vim.h	249;"	d
FO_ALL	option.h	85;"	d
FO_DFLT	option.h	84;"	d
FO_DFLT_VI	option.h	83;"	d
FO_INS_BLANK	option.h	81;"	d
FO_INS_LONG	option.h	80;"	d
FO_INS_VI	option.h	79;"	d
FO_OPEN_COMS	option.h	76;"	d
FO_Q_COMS	option.h	77;"	d
FO_Q_SECOND	option.h	78;"	d
FO_RET_COMS	option.h	75;"	d
FO_WRAP	option.h	73;"	d
FO_WRAP_COMS	option.h	74;"	d
FPC_DIFF	vim.h	393;"	d
FPC_DIFFX	vim.h	395;"	d
FPC_NOTX	vim.h	394;"	d
FPC_SAME	vim.h	392;"	d
FPC_SAMEX	vim.h	396;"	d
FPOS	structs.h	/^typedef struct fpos	FPOS;$/;"	t	typeref:struct:fpos
FRACTION_MULT	window.c	1468;"	d	file:
FREE_FNAME	edit.c	68;"	d	file:
F_BCOMMA	farsi.h	86;"	d
F_BLANK	farsi.h	74;"	d
F_BSIZE	memfile.c	49;"	d	file:
F_BSIZE	memfile.c	55;"	d	file:
F_BSLASH	farsi.h	156;"	d
F_COMMA	farsi.h	81;"	d
F_CURRENCY	farsi.h	78;"	d
F_DCOLON	farsi.h	102;"	d
F_DIVIDE	farsi.h	88;"	d
F_EQUALS	farsi.h	105;"	d
F_EXCL	farsi.h	77;"	d
F_GREATER	farsi.h	104;"	d
F_HE	farsi.h	141;"	d
F_LBRACE	farsi.h	149;"	d
F_LBRACK	farsi.h	147;"	d
F_LESS	farsi.h	106;"	d
F_LPARENT	farsi.h	82;"	d
F_LQUOT	farsi.h	151;"	d
F_MINUS	farsi.h	87;"	d
F_MUL	farsi.h	84;"	d
F_PCN	farsi.h	76;"	d
F_PERCENT	farsi.h	79;"	d
F_PERIOD	farsi.h	80;"	d
F_PIPE	farsi.h	155;"	d
F_PLUS	farsi.h	85;"	d
F_PSP	farsi.h	75;"	d
F_QUESTION	farsi.h	107;"	d
F_RBRACE	farsi.h	150;"	d
F_RBRACK	farsi.h	148;"	d
F_RPARENT	farsi.h	83;"	d
F_RQUOT	farsi.h	152;"	d
F_SEMICOLON	farsi.h	103;"	d
F_SLASH	farsi.h	89;"	d
F_STAR	farsi.h	153;"	d
F_UNDERLINE	farsi.h	154;"	d
F_is_TyB_TyC_TyD	farsi.c	/^F_is_TyB_TyC_TyD(src, offset)$/;"	f	file:
F_is_TyC_TyD	farsi.c	/^F_is_TyC_TyD(c)$/;"	f	file:
F_is_TyE	farsi.c	/^F_is_TyE(c)$/;"	f	file:
F_isalpha	farsi.c	/^F_isalpha(c)$/;"	f
F_ischar	farsi.c	/^F_ischar(c)$/;"	f
F_isdigit	farsi.c	/^F_isdigit(c)$/;"	f
F_isterm	farsi.c	/^F_isterm(c)$/;"	f	file:
FreeWild	misc1.c	/^FreeWild(num, file)$/;"	f
FullName_save	misc1.c	/^FullName_save(fname, force)$/;"	f
GAF	farsi.h	136;"	d
GAP	option.c	3081;"	d	file:
GAP	term.c	3472;"	d	file:
GETF_ALT	vim.h	343;"	d
GETF_SETMARK	vim.h	342;"	d
GHAF	farsi.h	134;"	d
GHAYN	farsi.h	132;"	d
GHAYN_	farsi.h	47;"	d
GOTO_COST	screen.c	2517;"	d	file:
GO_ALL	option.h	158;"	d
GO_ASEL	option.h	151;"	d
GO_BOT	option.h	152;"	d
GO_FORG	option.h	153;"	d
GO_GREY	option.h	154;"	d
GO_LEFT	option.h	155;"	d
GO_MENUS	option.h	156;"	d
GO_RIGHT	option.h	157;"	d
GUI_ATTR_ENTRY	syntax.c	4752;"	d	file:
GUI_MON_INVERT	gui.h	124;"	d
GUI_MON_IS_CURSOR	gui.h	125;"	d
GUI_MON_TRS_CURSOR	gui.h	126;"	d
GUI_MON_WRAP_CURSOR	gui.h	123;"	d
GVIMRC_FILE	os_unix.h	207;"	d
GetBufferLine	if_python.c	/^GetBufferLine(BUF *buf, int n)$/;"	f	file:
GetBufferLineList	if_python.c	/^GetBufferLineList(BUF *buf, int lo, int hi)$/;"	f	file:
Gui	gui.h	/^typedef struct Gui$/;"	s
Gui	gui.h	/^} Gui;$/;"	t	typeref:struct:Gui
GuiColor	gui.h	/^typedef long	    GuiColor;	    \/* handle for a GUI color *\/$/;"	t
GuiColor	structs.h	41;"	d
GuiFont	gui.h	/^typedef long_u	    GuiFont;	    \/* handle for a GUI font *\/$/;"	t
GuiMenu	gui.h	/^typedef struct GuiMenu$/;"	s
GuiMenu	gui.h	/^} GuiMenu;$/;"	t	typeref:struct:GuiMenu
GuiScrollbar	gui.h	/^typedef struct GuiScrollbar$/;"	s
GuiScrollbar	gui.h	/^} GuiScrollbar;$/;"	t	typeref:struct:GuiScrollbar
HAMZE	farsi.h	111;"	d
HASWIDTH	regexp.c	203;"	d	file:
HAVE_BCMP	config.h	94;"	d
HAVE_DIRENT_H	config.h	196;"	d
HAVE_ERRNO_H	config.h	252;"	d
HAVE_FCHDIR	config.h	97;"	d
HAVE_FCHOWN	config.h	100;"	d
HAVE_FCNTL_H	config.h	231;"	d
HAVE_FCNTL_H	if_python.c	26;"	d	file:
HAVE_FSYNC	config.h	103;"	d
HAVE_GETCWD	config.h	109;"	d
HAVE_GETPWNAM	config.h	112;"	d
HAVE_GETPWUID	config.h	115;"	d
HAVE_GETTIMEOFDAY	config.h	118;"	d
HAVE_GETWD	config.h	121;"	d
HAVE_LANGMAP	feature.h	65;"	d
HAVE_LIBNCURSES	config.h	17;"	d
HAVE_LOCALE_H	config.h	261;"	d
HAVE_LSTAT	config.h	124;"	d
HAVE_MEMCMP	config.h	127;"	d
HAVE_MEMSET	config.h	130;"	d
HAVE_OPENDIR	config.h	133;"	d
HAVE_OSPEED	config.h	23;"	d
HAVE_OUTFUNTYPE	config.h	35;"	d
HAVE_PATHDEF	vim.h	13;"	d
HAVE_POLL_H	config.h	279;"	d
HAVE_PUTENV	config.h	136;"	d
HAVE_PWD_H	config.h	285;"	d
HAVE_PYTHON	config.h	297;"	d
HAVE_QSORT	config.h	139;"	d
HAVE_RENAME	config.h	187;"	d
HAVE_SELECT	config.h	142;"	d
HAVE_SETENV	config.h	145;"	d
HAVE_SETPGID	config.h	148;"	d
HAVE_SETSID	config.h	151;"	d
HAVE_SGTTY_H	config.h	234;"	d
HAVE_SIGSET	config.h	154;"	d
HAVE_STDLIB_H	config.h	218;"	d
HAVE_STRCASECMP	config.h	157;"	d
HAVE_STRERROR	config.h	160;"	d
HAVE_STRFTIME	config.h	163;"	d
HAVE_STRINGS_H	config.h	255;"	d
HAVE_STRING_H	config.h	219;"	d
HAVE_STRNCASECMP	config.h	169;"	d
HAVE_STROPTS_H	config.h	249;"	d
HAVE_STRPBRK	config.h	175;"	d
HAVE_STRTOL	config.h	178;"	d
HAVE_ST_BLKSIZE	config.h	184;"	d
HAVE_SYS_IOCTL_H	config.h	237;"	d
HAVE_SYS_PARAM_H	config.h	291;"	d
HAVE_SYS_POLL_H	config.h	282;"	d
HAVE_SYS_SELECT_H	config.h	222;"	d
HAVE_SYS_STATFS_H	config.h	276;"	d
HAVE_SYS_TIME_H	config.h	240;"	d
HAVE_SYS_UTSNAME_H	config.h	225;"	d
HAVE_SYS_UTSNAME_H	vim.h	44;"	d
HAVE_SYS_WAIT_H	config.h	208;"	d
HAVE_TERMCAP_H	config.h	228;"	d
HAVE_TERMIOS_H	config.h	270;"	d
HAVE_TERMIO_H	config.h	243;"	d
HAVE_TGETENT	config.h	181;"	d
HAVE_UNISTD_H	config.h	246;"	d
HAVE_UP_BC_PC	config.h	29;"	d
HAVE_UTIME	config.h	190;"	d
HAVE_UTIME	vim.h	43;"	d
HAVE_UTIMES	config.h	193;"	d
HAVE_UTIME_H	config.h	288;"	d
HEADER_SIZE	memline.c	125;"	d	file:
HE_J	farsi.h	118;"	d
HIGHL_COST	screen.c	2518;"	d	file:
HINT_DEL_CHAR	vim.h	210;"	d
HINT_INS_CHAR	vim.h	211;"	d
HINT_NONE	vim.h	209;"	d
HIST_CMD	vim.h	429;"	d
HIST_COUNT	vim.h	432;"	d
HIST_EXPR	vim.h	431;"	d
HIST_SEARCH	vim.h	430;"	d
HITRETURN	vim.h	241;"	d
HLF_8	vim.h	/^    HLF_8 = 0,	    \/* Meta & special keys listed with ":map" *\/$/;"	e	enum:hlf_value
HLF_AT	vim.h	/^    HLF_AT,	    \/* @ and ~ characters at end of screen *\/$/;"	e	enum:hlf_value
HLF_CM	vim.h	/^    HLF_CM,	    \/* Mode (e.g., "-- INSERT --") *\/$/;"	e	enum:hlf_value
HLF_COUNT	vim.h	/^    HLF_COUNT	    \/* MUST be the last one *\/$/;"	e	enum:hlf_value
HLF_D	vim.h	/^    HLF_D,	    \/* directories in CTRL-D listing *\/$/;"	e	enum:hlf_value
HLF_E	vim.h	/^    HLF_E,	    \/* error messages *\/$/;"	e	enum:hlf_value
HLF_H	vim.h	/^    HLF_H,	    \/* obsolete, ignored *\/$/;"	e	enum:hlf_value
HLF_I	vim.h	/^    HLF_I,	    \/* incremental search *\/$/;"	e	enum:hlf_value
HLF_L	vim.h	/^    HLF_L,	    \/* last search string *\/$/;"	e	enum:hlf_value
HLF_M	vim.h	/^    HLF_M,	    \/* "--More--" message *\/$/;"	e	enum:hlf_value
HLF_N	vim.h	/^    HLF_N,	    \/* line number for ":number" and ":#" commands *\/$/;"	e	enum:hlf_value
HLF_R	vim.h	/^    HLF_R,	    \/* return to continue message and yes\/no questions *\/$/;"	e	enum:hlf_value
HLF_S	vim.h	/^    HLF_S,	    \/* status lines *\/$/;"	e	enum:hlf_value
HLF_T	vim.h	/^    HLF_T,	    \/* Titles for output from ":set all", ":autocmd" etc. *\/$/;"	e	enum:hlf_value
HLF_V	vim.h	/^    HLF_V,	    \/* Visual mode *\/$/;"	e	enum:hlf_value
HLF_W	vim.h	/^    HLF_W,	    \/* warning messages *\/$/;"	e	enum:hlf_value
HL_ALL	vim.h	223;"	d
HL_BOLD	vim.h	219;"	d
HL_CONTAINED	syntax.c	146;"	d	file:
HL_HAS_EOL	syntax.c	149;"	d	file:
HL_INVERSE	vim.h	218;"	d
HL_ITALIC	vim.h	220;"	d
HL_KEEPEND	syntax.c	156;"	d	file:
HL_MATCH	syntax.c	152;"	d	file:
HL_NORMAL	vim.h	217;"	d
HL_ONELINE	syntax.c	148;"	d	file:
HL_SKIPEMPTY	syntax.c	155;"	d	file:
HL_SKIPNL	syntax.c	153;"	d	file:
HL_SKIPWHITE	syntax.c	154;"	d	file:
HL_STANDOUT	vim.h	222;"	d
HL_SYNC_HERE	syntax.c	150;"	d	file:
HL_SYNC_THERE	syntax.c	151;"	d	file:
HL_TABLE	syntax.c	52;"	d	file:
HL_TRANSP	syntax.c	147;"	d	file:
HL_UNDERLINE	vim.h	221;"	d
IDENT	regexp.c	105;"	d	file:
ID_LIST_ALL	syntax.c	211;"	d	file:
IE	farsi.h	61;"	d
IE_	farsi.h	60;"	d
INBUFLEN	ui.c	961;"	d	file:
INC	option.c	3080;"	d	file:
INC	term.c	3471;"	d	file:
INCSTACK_SIZE	tag.c	672;"	d	file:
INDENT_DEC	vim.h	363;"	d
INDENT_INC	vim.h	362;"	d
INDENT_SET	vim.h	361;"	d
INDEX_SIZE	memline.c	124;"	d	file:
INIT	globals.h	17;"	d
INIT	globals.h	20;"	d
INIT	option.h	17;"	d
INIT	option.h	20;"	d
INPUT_BUFLEN	edit.c	2946;"	d	file:
INSERT	vim.h	237;"	d
INSERT_EXPAND	feature.h	74;"	d
INVALID_BUFFER_VALUE	if_python.c	522;"	d	file:
INVALID_STATE	syntax.c	234;"	d	file:
INVALID_WINDOW_VALUE	if_python.c	499;"	d	file:
INVERTED	vim.h	200;"	d
IN_BUFFER	vim.h	769;"	d
IN_STATUS_LINE	vim.h	770;"	d
IN_UNKNOWN	vim.h	768;"	d
IOSIZE	vim.h	577;"	d
IObuff	globals.h	/^EXTERN char_u	*IObuff;		\/* sprintf's are done in this buffer *\/$/;"	v
IPTR	structs.h	/^typedef struct info_pointer	IPTR;	    \/* block\/index pair *\/$/;"	t	typeref:struct:info_pointer
ISSPECIAL	edit.c	2714;"	d	file:
IS_ABBR	keymap.h	39;"	d
IS_SPECIAL	keymap.h	38;"	d
ITEM_END	syntax.c	3089;"	d	file:
ITEM_MATCHGROUP	syntax.c	3090;"	d	file:
ITEM_SKIP	syntax.c	3088;"	d	file:
ITEM_START	syntax.c	3087;"	d	file:
InsertBufferLines	if_python.c	/^InsertBufferLines(BUF *buf, int n, PyObject *lines, int *len_change)$/;"	f	file:
Insstart	edit.c	/^static FPOS	Insstart;		\/* This is where the latest$/;"	v	file:
Insstart_blank_vcol	edit.c	/^static colnr_t	Insstart_blank_vcol;	\/* vcol for first inserted blank *\/$/;"	v	file:
Insstart_textlen	edit.c	/^static colnr_t	Insstart_textlen;	\/* length of line when insert started *\/$/;"	v	file:
JAZR	farsi.h	159;"	d
JAZR_N	farsi.h	162;"	d
JE	farsi.h	124;"	d
JIM	farsi.h	116;"	d
JUMPLISTSIZE	structs.h	50;"	d
JUST_CALC_SIZE	regexp.c	212;"	d	file:
KAF	farsi.h	135;"	d
KEEP_ROOM	misc2.c	249;"	d	file:
KEY2TERMCAP0	keymap.h	90;"	d
KEY2TERMCAP1	keymap.h	91;"	d
KEYWORD_IDX	syntax.c	209;"	d	file:
KEY_NAMES_TABLE_LEN	misc2.c	1084;"	d	file:
KEY_OPEN_BACK	vim.h	347;"	d
KEY_OPEN_FORW	vim.h	346;"	d
KE_IGNORE	keymap.h	/^    KE_IGNORE,		\/* Ignored mouse drag\/release *\/$/;"	e	enum:key_extra
KE_LEFTDRAG	keymap.h	/^    KE_LEFTDRAG,	\/* Drag with left mouse button down *\/$/;"	e	enum:key_extra
KE_LEFTMOUSE	keymap.h	/^    KE_LEFTMOUSE,	\/* Left mouse button click *\/$/;"	e	enum:key_extra
KE_LEFTRELEASE	keymap.h	/^    KE_LEFTRELEASE,	\/* Left mouse button release *\/$/;"	e	enum:key_extra
KE_MIDDLEDRAG	keymap.h	/^    KE_MIDDLEDRAG,	\/* Drag with middle mouse button down *\/$/;"	e	enum:key_extra
KE_MIDDLEMOUSE	keymap.h	/^    KE_MIDDLEMOUSE,	\/* Middle mouse button click *\/$/;"	e	enum:key_extra
KE_MIDDLERELEASE	keymap.h	/^    KE_MIDDLERELEASE,	\/* Middle mouse button release *\/$/;"	e	enum:key_extra
KE_MOUSE	keymap.h	/^    KE_MOUSE,		\/* mouse event start *\/$/;"	e	enum:key_extra
KE_NAME	keymap.h	/^    KE_NAME = 3,	\/* name of this terminal entry *\/$/;"	e	enum:key_extra
KE_RIGHTDRAG	keymap.h	/^    KE_RIGHTDRAG,	\/* Drag with right mouse button down *\/$/;"	e	enum:key_extra
KE_RIGHTMOUSE	keymap.h	/^    KE_RIGHTMOUSE,	\/* Right mouse button click *\/$/;"	e	enum:key_extra
KE_RIGHTRELEASE	keymap.h	/^    KE_RIGHTRELEASE,	\/* Right mouse button release *\/$/;"	e	enum:key_extra
KE_SNIFF	keymap.h	/^    KE_SNIFF		\/* SNiFF+ input waiting *\/$/;"	e	enum:key_extra
KE_S_DOWN	keymap.h	/^    KE_S_DOWN,		\/* shift-down *\/$/;"	e	enum:key_extra
KE_S_F1	keymap.h	/^    KE_S_F1,		\/* shifted function keys *\/$/;"	e	enum:key_extra
KE_S_F10	keymap.h	/^    KE_S_F10,$/;"	e	enum:key_extra
KE_S_F11	keymap.h	/^    KE_S_F11,$/;"	e	enum:key_extra
KE_S_F12	keymap.h	/^    KE_S_F12,$/;"	e	enum:key_extra
KE_S_F13	keymap.h	/^    KE_S_F13,$/;"	e	enum:key_extra
KE_S_F14	keymap.h	/^    KE_S_F14,$/;"	e	enum:key_extra
KE_S_F15	keymap.h	/^    KE_S_F15,$/;"	e	enum:key_extra
KE_S_F16	keymap.h	/^    KE_S_F16,$/;"	e	enum:key_extra
KE_S_F17	keymap.h	/^    KE_S_F17,$/;"	e	enum:key_extra
KE_S_F18	keymap.h	/^    KE_S_F18,$/;"	e	enum:key_extra
KE_S_F19	keymap.h	/^    KE_S_F19,$/;"	e	enum:key_extra
KE_S_F2	keymap.h	/^    KE_S_F2,$/;"	e	enum:key_extra
KE_S_F20	keymap.h	/^    KE_S_F20,$/;"	e	enum:key_extra
KE_S_F21	keymap.h	/^    KE_S_F21,$/;"	e	enum:key_extra
KE_S_F22	keymap.h	/^    KE_S_F22,$/;"	e	enum:key_extra
KE_S_F23	keymap.h	/^    KE_S_F23,$/;"	e	enum:key_extra
KE_S_F24	keymap.h	/^    KE_S_F24,$/;"	e	enum:key_extra
KE_S_F25	keymap.h	/^    KE_S_F25,$/;"	e	enum:key_extra
KE_S_F26	keymap.h	/^    KE_S_F26,$/;"	e	enum:key_extra
KE_S_F27	keymap.h	/^    KE_S_F27,$/;"	e	enum:key_extra
KE_S_F28	keymap.h	/^    KE_S_F28,$/;"	e	enum:key_extra
KE_S_F29	keymap.h	/^    KE_S_F29,$/;"	e	enum:key_extra
KE_S_F3	keymap.h	/^    KE_S_F3,$/;"	e	enum:key_extra
KE_S_F30	keymap.h	/^    KE_S_F30,$/;"	e	enum:key_extra
KE_S_F31	keymap.h	/^    KE_S_F31,$/;"	e	enum:key_extra
KE_S_F32	keymap.h	/^    KE_S_F32,$/;"	e	enum:key_extra
KE_S_F33	keymap.h	/^    KE_S_F33,$/;"	e	enum:key_extra
KE_S_F34	keymap.h	/^    KE_S_F34,$/;"	e	enum:key_extra
KE_S_F35	keymap.h	/^    KE_S_F35,$/;"	e	enum:key_extra
KE_S_F4	keymap.h	/^    KE_S_F4,$/;"	e	enum:key_extra
KE_S_F5	keymap.h	/^    KE_S_F5,$/;"	e	enum:key_extra
KE_S_F6	keymap.h	/^    KE_S_F6,$/;"	e	enum:key_extra
KE_S_F7	keymap.h	/^    KE_S_F7,$/;"	e	enum:key_extra
KE_S_F8	keymap.h	/^    KE_S_F8,$/;"	e	enum:key_extra
KE_S_F9	keymap.h	/^    KE_S_F9,$/;"	e	enum:key_extra
KE_S_TAB	keymap.h	/^    KE_S_TAB,		\/* shifted TAB key *\/$/;"	e	enum:key_extra
KE_S_UP	keymap.h	/^    KE_S_UP,		\/* shift-up *\/$/;"	e	enum:key_extra
KE_TAB	keymap.h	/^    KE_TAB,		\/* unshifted TAB key *\/$/;"	e	enum:key_extra
KHASH_MASK	syntax.c	175;"	d	file:
KHASH_SIZE	syntax.c	174;"	d	file:
KS_AL	term.h	/^    KS_AL,	\/* add new blank line *\/$/;"	e	enum:SpecialKey
KS_BC	term.h	/^    KS_BC,	\/* backspace character (cursor left) *\/$/;"	e	enum:SpecialKey
KS_CAB	term.h	/^    KS_CAB,	\/* set background color (ANSI) *\/$/;"	e	enum:SpecialKey
KS_CAF	term.h	/^    KS_CAF,	\/* set foreground color (ANSI) *\/$/;"	e	enum:SpecialKey
KS_CAL	term.h	/^    KS_CAL,	\/* add number of blank lines *\/$/;"	e	enum:SpecialKey
KS_CCO	term.h	/^    KS_CCO,	\/* number of colors *\/$/;"	e	enum:SpecialKey
KS_CCS	term.h	/^    KS_CCS,	\/* cur is relative to scroll region *\/$/;"	e	enum:SpecialKey
KS_CD	term.h	/^    KS_CD,	\/* clear to end of display *\/$/;"	e	enum:SpecialKey
KS_CDL	term.h	/^    KS_CDL,	\/* delete number of lines *\/$/;"	e	enum:SpecialKey
KS_CE	term.h	/^    KS_CE,	\/* clear to end of line *\/$/;"	e	enum:SpecialKey
KS_CL	term.h	/^    KS_CL,	\/* clear screen *\/$/;"	e	enum:SpecialKey
KS_CM	term.h	/^    KS_CM,	\/* cursor motion *\/$/;"	e	enum:SpecialKey
KS_CRI	term.h	/^    KS_CRI,	\/* cursor number of chars right *\/$/;"	e	enum:SpecialKey
KS_CS	term.h	/^    KS_CS,	\/* scroll region *\/$/;"	e	enum:SpecialKey
KS_CSB	term.h	/^    KS_CSB,	\/* set background color *\/$/;"	e	enum:SpecialKey
KS_CSF	term.h	/^    KS_CSF,	\/* set foreground color *\/$/;"	e	enum:SpecialKey
KS_CZH	term.h	/^    KS_CZH,	\/* italic mode start *\/$/;"	e	enum:SpecialKey
KS_CZR	term.h	/^    KS_CZR,	\/* italic mode end *\/$/;"	e	enum:SpecialKey
KS_DA	term.h	/^    KS_DA,	\/* text may be scrolled down from up *\/$/;"	e	enum:SpecialKey
KS_DB	term.h	/^    KS_DB,	\/* text may be scrolled up from down *\/$/;"	e	enum:SpecialKey
KS_DEC_MOUSE	keymap.h	79;"	d
KS_DL	term.h	/^    KS_DL,	\/* delete line *\/$/;"	e	enum:SpecialKey
KS_EXTRA	keymap.h	58;"	d
KS_HORIZ_SCROLLBAR	keymap.h	73;"	d
KS_KE	term.h	/^    KS_KE,	\/* out of "keypad transmit" mode *\/$/;"	e	enum:SpecialKey
KS_KS	term.h	/^    KS_KS,	\/* put term in "keypad transmit" mode *\/$/;"	e	enum:SpecialKey
KS_LAST	term.h	76;"	d
KS_LE	term.h	/^    KS_LE,	\/* cursor left (mostly backspace) *\/$/;"	e	enum:SpecialKey
KS_MB	term.h	/^    KS_MB,	\/* blink mode *\/$/;"	e	enum:SpecialKey
KS_MD	term.h	/^    KS_MD,	\/* bold mode *\/$/;"	e	enum:SpecialKey
KS_ME	term.h	/^    KS_ME,	\/* normal mode *\/$/;"	e	enum:SpecialKey
KS_MENU	keymap.h	71;"	d
KS_MODIFIER	keymap.h	64;"	d
KS_MOUSE	keymap.h	70;"	d
KS_MR	term.h	/^    KS_MR,	\/* reverse mode *\/$/;"	e	enum:SpecialKey
KS_MS	term.h	/^    KS_MS,	\/* save to move cur in reverse mode *\/$/;"	e	enum:SpecialKey
KS_NAME	term.h	/^    KS_NAME = 0,\/* name of this terminal entry *\/$/;"	e	enum:SpecialKey
KS_ND	term.h	/^    KS_ND,	\/* cursor right *\/$/;"	e	enum:SpecialKey
KS_NETTERM_MOUSE	keymap.h	78;"	d
KS_OP	term.h	/^    KS_OP	\/* original color pair *\/$/;"	e	enum:SpecialKey
KS_SCROLLBAR	keymap.h	72;"	d
KS_SE	term.h	/^    KS_SE,	\/* normal mode *\/$/;"	e	enum:SpecialKey
KS_SO	term.h	/^    KS_SO,	\/* standout mode *\/$/;"	e	enum:SpecialKey
KS_SPECIAL	keymap.h	52;"	d
KS_SR	term.h	/^    KS_SR,	\/* scroll reverse (backward) *\/$/;"	e	enum:SpecialKey
KS_TE	term.h	/^    KS_TE,	\/* out of termcap mode *\/$/;"	e	enum:SpecialKey
KS_TI	term.h	/^    KS_TI,	\/* put terminal in termcap mode *\/$/;"	e	enum:SpecialKey
KS_UE	term.h	/^    KS_UE,	\/* exit underscore mode *\/$/;"	e	enum:SpecialKey
KS_US	term.h	/^    KS_US,	\/* underscore mode *\/$/;"	e	enum:SpecialKey
KS_VB	term.h	/^    KS_VB,	\/* visual bell *\/$/;"	e	enum:SpecialKey
KS_VE	term.h	/^    KS_VE,	\/* cursor visible *\/$/;"	e	enum:SpecialKey
KS_VI	term.h	/^    KS_VI,	\/* cursor invisible *\/$/;"	e	enum:SpecialKey
KS_VS	term.h	/^    KS_VS,	\/* cursor very visible *\/$/;"	e	enum:SpecialKey
KS_XS	term.h	/^    KS_XS,	\/* standout not erased by overwriting (hpterm) *\/$/;"	e	enum:SpecialKey
KS_ZERO	keymap.h	46;"	d
K_BS	keymap.h	277;"	d
K_CCIRCM	keymap.h	9;"	d
K_DEL	keymap.h	280;"	d
K_DOWN	keymap.h	186;"	d
K_END	keymap.h	282;"	d
K_F1	keymap.h	196;"	d
K_F10	keymap.h	205;"	d
K_F11	keymap.h	207;"	d
K_F12	keymap.h	208;"	d
K_F13	keymap.h	209;"	d
K_F14	keymap.h	210;"	d
K_F15	keymap.h	211;"	d
K_F16	keymap.h	212;"	d
K_F17	keymap.h	213;"	d
K_F18	keymap.h	214;"	d
K_F19	keymap.h	215;"	d
K_F2	keymap.h	197;"	d
K_F20	keymap.h	216;"	d
K_F21	keymap.h	218;"	d
K_F22	keymap.h	219;"	d
K_F23	keymap.h	220;"	d
K_F24	keymap.h	221;"	d
K_F25	keymap.h	222;"	d
K_F26	keymap.h	223;"	d
K_F27	keymap.h	224;"	d
K_F28	keymap.h	225;"	d
K_F29	keymap.h	226;"	d
K_F3	keymap.h	198;"	d
K_F30	keymap.h	227;"	d
K_F31	keymap.h	229;"	d
K_F32	keymap.h	230;"	d
K_F33	keymap.h	231;"	d
K_F34	keymap.h	232;"	d
K_F35	keymap.h	233;"	d
K_F4	keymap.h	199;"	d
K_F5	keymap.h	200;"	d
K_F6	keymap.h	201;"	d
K_F7	keymap.h	202;"	d
K_F8	keymap.h	203;"	d
K_F9	keymap.h	204;"	d
K_FILLER	keymap.h	84;"	d
K_HELP	keymap.h	274;"	d
K_HOME	keymap.h	281;"	d
K_HORIZ_SCROLLBAR	keymap.h	293;"	d
K_IGNORE	keymap.h	309;"	d
K_INS	keymap.h	279;"	d
K_KEND	keymap.h	286;"	d
K_KHOME	keymap.h	285;"	d
K_KPAGEDOWN	keymap.h	288;"	d
K_KPAGEUP	keymap.h	287;"	d
K_LEFT	keymap.h	187;"	d
K_LEFTDRAG	keymap.h	300;"	d
K_LEFTMOUSE	keymap.h	299;"	d
K_LEFTRELEASE	keymap.h	301;"	d
K_MENU	keymap.h	291;"	d
K_MIDDLEDRAG	keymap.h	303;"	d
K_MIDDLEMOUSE	keymap.h	302;"	d
K_MIDDLERELEASE	keymap.h	304;"	d
K_MOUSE	keymap.h	290;"	d
K_NEEDMORET	getchar.c	1017;"	d	file:
K_NUL	keymap.h	15;"	d
K_PAGEDOWN	keymap.h	284;"	d
K_PAGEUP	keymap.h	283;"	d
K_RIGHT	keymap.h	188;"	d
K_RIGHTDRAG	keymap.h	306;"	d
K_RIGHTMOUSE	keymap.h	305;"	d
K_RIGHTRELEASE	keymap.h	307;"	d
K_SCROLLBAR	keymap.h	292;"	d
K_SECOND	keymap.h	96;"	d
K_SNIFF	keymap.h	311;"	d
K_SPECIAL	keymap.h	31;"	d
K_S_DOWN	keymap.h	190;"	d
K_S_F1	keymap.h	235;"	d
K_S_F10	keymap.h	244;"	d
K_S_F11	keymap.h	246;"	d
K_S_F12	keymap.h	247;"	d
K_S_F13	keymap.h	248;"	d
K_S_F14	keymap.h	249;"	d
K_S_F15	keymap.h	250;"	d
K_S_F16	keymap.h	251;"	d
K_S_F17	keymap.h	252;"	d
K_S_F18	keymap.h	253;"	d
K_S_F19	keymap.h	254;"	d
K_S_F2	keymap.h	236;"	d
K_S_F20	keymap.h	255;"	d
K_S_F21	keymap.h	257;"	d
K_S_F22	keymap.h	258;"	d
K_S_F23	keymap.h	259;"	d
K_S_F24	keymap.h	260;"	d
K_S_F25	keymap.h	261;"	d
K_S_F26	keymap.h	262;"	d
K_S_F27	keymap.h	263;"	d
K_S_F28	keymap.h	264;"	d
K_S_F29	keymap.h	265;"	d
K_S_F3	keymap.h	237;"	d
K_S_F30	keymap.h	266;"	d
K_S_F31	keymap.h	268;"	d
K_S_F32	keymap.h	269;"	d
K_S_F33	keymap.h	270;"	d
K_S_F34	keymap.h	271;"	d
K_S_F35	keymap.h	272;"	d
K_S_F4	keymap.h	238;"	d
K_S_F5	keymap.h	239;"	d
K_S_F6	keymap.h	240;"	d
K_S_F7	keymap.h	241;"	d
K_S_F8	keymap.h	242;"	d
K_S_F9	keymap.h	243;"	d
K_S_LEFT	keymap.h	191;"	d
K_S_RIGHT	keymap.h	192;"	d
K_S_TAB	keymap.h	194;"	d
K_S_UP	keymap.h	189;"	d
K_TAB	keymap.h	193;"	d
K_THIRD	keymap.h	98;"	d
K_UNDO	keymap.h	275;"	d
K_UP	keymap.h	185;"	d
K_ZERO	keymap.h	183;"	d
KeyStuffed	globals.h	/^EXTERN int	KeyStuffed;		\/* TRUE if current char from stuffbuf *\/$/;"	v
KeyTyped	globals.h	/^EXTERN int	KeyTyped;		\/* TRUE if user typed current char *\/$/;"	v
LA	farsi.h	53;"	d
LAM	farsi.h	137;"	d
LANGMAP_ADJUST	macros.h	66;"	d
LISPINDENT	feature.h	266;"	d
LIST_ATTR	syntax.c	4909;"	d	file:
LIST_INT	syntax.c	4911;"	d	file:
LIST_STRING	syntax.c	4910;"	d	file:
LOOKFOR_ANY	misc1.c	3007;"	d	file:
LOOKFOR_CASE	misc1.c	3006;"	d	file:
LOOKFOR_DO	misc1.c	3005;"	d	file:
LOOKFOR_IF	misc1.c	3004;"	d	file:
LOOKFOR_SCOPEDECL	misc1.c	3010;"	d	file:
LOOKFOR_TERM	misc1.c	3008;"	d	file:
LOOKFOR_UNTERM	misc1.c	3009;"	d	file:
LSIZE	vim.h	575;"	d
LinePointers	globals.h	/^EXTERN char_u	**LinePointers INIT(= NULL);$/;"	v
LineToString	if_python.c	/^LineToString(const char *str)$/;"	f	file:
MAD	farsi.h	158;"	d
MAD_N	farsi.h	161;"	d
MAGIC	regexp.h	35;"	d
MAKEEF	os_unix.h	233;"	d
MAKEEF	os_unix.h	235;"	d
MAP_HASH	getchar.c	79;"	d	file:
MAXCOL	vim.h	666;"	d
MAXCOL	vim.h	668;"	d
MAXKEYWLEN	syntax.c	176;"	d	file:
MAXLNUM	vim.h	663;"	d
MAXMAPLEN	vim.h	590;"	d
MAXMEM	os_unix.h	270;"	d
MAXMEMTOT	os_unix.h	273;"	d
MAXNAMLEN	os_unix.h	131;"	d
MAXNAMLEN	os_unix.h	135;"	d
MAXNAMLEN	os_unix.h	139;"	d
MAXNAMLEN	os_unix.h	147;"	d
MAXPATHL	os_unix.h	261;"	d
MAXPATHL	vim.h	137;"	d
MAXPATHL	vim.h	139;"	d
MAXSUFLEN	ex_getln.c	1360;"	d	file:
MAX_ADDR	quickfix.c	44;"	d	file:
MAX_ARG_CMDS	main.c	175;"	d	file:
MAX_FEAT	feature.h	36;"	d
MAX_FUNC_ARGS	eval.c	1292;"	d	file:
MAX_KEY_CODE_LEN	keymap.h	337;"	d
MAX_KEY_NAME_LEN	keymap.h	327;"	d
MAX_LIMIT	regexp.c	181;"	d	file:
MAYBE	vim.h	530;"	d
MBLOCK	vim.h	559;"	d
MCHAR	vim.h	557;"	d
MCLOSE	regexp.c	119;"	d	file:
MEMBLOCKSIZE	undo.c	808;"	d	file:
MEMFILE	structs.h	/^typedef struct memfile	    MEMFILE;$/;"	t	typeref:struct:memfile
MEMFILE_PAGE_SIZE	memfile.c	75;"	d	file:
MEMHASH	structs.h	227;"	d
MEMHASHSIZE	structs.h	226;"	d
MEMLINE	structs.h	/^typedef struct memline MEMLINE;$/;"	t	typeref:struct:memline
MENU_ALL_MODES	gui.h	101;"	d
MENU_CMDLINE_MODE	gui.h	100;"	d
MENU_DEFAULT_HEIGHT	gui.h	120;"	d
MENU_INDEX_CMDLINE	gui.h	92;"	d
MENU_INDEX_INSERT	gui.h	91;"	d
MENU_INDEX_INVALID	gui.h	87;"	d
MENU_INDEX_NORMAL	gui.h	88;"	d
MENU_INDEX_OP_PENDING	gui.h	90;"	d
MENU_INDEX_VISUAL	gui.h	89;"	d
MENU_INSERT_MODE	gui.h	99;"	d
MENU_MODES	gui.h	93;"	d
MENU_MODE_CHARS	gui.h	104;"	d
MENU_NORMAL_MODE	gui.h	96;"	d
MENU_OP_PENDING_MODE	gui.h	98;"	d
MENU_VISUAL_MODE	gui.h	97;"	d
MESSAGE_FILE	message.c	13;"	d	file:
META	regexp.c	/^static char_u META[] = ".[()|=+*<>iIkKfFpPsS~123456789{";$/;"	v	file:
ME_ARG_MISSING	main.c	25;"	d	file:
ME_EXTRA_CMD	main.c	27;"	d	file:
ME_GARBAGE	main.c	26;"	d	file:
ME_TOO_MANY_ARGS	main.c	24;"	d	file:
ME_UNKNOWN_OPTION	main.c	23;"	d	file:
MFS_ALL	vim.h	416;"	d
MFS_FLUSH	vim.h	418;"	d
MFS_STOP	vim.h	417;"	d
MFS_ZERO	vim.h	419;"	d
MIM	farsi.h	138;"	d
MINIMAL_SIZE	getchar.c	33;"	d	file:
MIN_COLUMNS	vim.h	564;"	d
MIN_FEAT	feature.h	39;"	d
MIN_ROWS	vim.h	565;"	d
MIN_SPACE	edit.c	2227;"	d	file:
MLINE	vim.h	558;"	d
ML_DELETE	memline.c	183;"	d	file:
ML_EMPTY	structs.h	278;"	d
ML_FIND	memline.c	185;"	d	file:
ML_FLUSH	memline.c	186;"	d	file:
ML_INSERT	memline.c	184;"	d	file:
ML_LINE_DIRTY	structs.h	279;"	d
ML_LOCKED_DIRTY	structs.h	280;"	d
ML_LOCKED_POS	structs.h	281;"	d
ML_SIMPLE	memline.c	187;"	d	file:
MOD_MASK_2CLICK	keymap.h	317;"	d
MOD_MASK_3CLICK	keymap.h	318;"	d
MOD_MASK_4CLICK	keymap.h	319;"	d
MOD_MASK_ALT	keymap.h	316;"	d
MOD_MASK_CTRL	keymap.h	315;"	d
MOD_MASK_MULTI_CLICK	keymap.h	321;"	d
MOD_MASK_SHIFT	keymap.h	314;"	d
MOPEN	regexp.c	117;"	d	file:
MOUSE_A	option.h	129;"	d
MOUSE_ALL	option.h	130;"	d
MOUSE_ALT	vim.h	749;"	d
MOUSE_CLICK_MASK	vim.h	756;"	d
MOUSE_COMMAND	option.h	126;"	d
MOUSE_CTRL	vim.h	750;"	d
MOUSE_DID_MOVE	vim.h	776;"	d
MOUSE_DRAG	vim.h	754;"	d
MOUSE_FOCUS	vim.h	774;"	d
MOUSE_HELP	option.h	127;"	d
MOUSE_INSERT	option.h	125;"	d
MOUSE_LEFT	vim.h	744;"	d
MOUSE_MAY_VIS	vim.h	775;"	d
MOUSE_MIDDLE	vim.h	745;"	d
MOUSE_NORMAL	option.h	123;"	d
MOUSE_RELEASE	vim.h	747;"	d
MOUSE_RETURN	option.h	128;"	d
MOUSE_RIGHT	vim.h	746;"	d
MOUSE_SETPOS	vim.h	777;"	d
MOUSE_SHIFT	vim.h	748;"	d
MOUSE_VISUAL	option.h	124;"	d
MSG	vim.h	649;"	d
MSG_ATTR	vim.h	650;"	d
MSG_BUF_LEN	vim.h	578;"	d
MSG_PUTS	vim.h	656;"	d
MSG_PUTS_ATTR	vim.h	657;"	d
MSG_PUTS_TITLE	vim.h	658;"	d
MT_COUNT	tag.c	55;"	d	file:
MT_GL_CUR	tag.c	48;"	d	file:
MT_GL_OTH	tag.c	49;"	d	file:
MT_IC_GL_CUR	tag.c	52;"	d	file:
MT_IC_GL_OTH	tag.c	53;"	d	file:
MT_IC_OFF	tag.c	56;"	d	file:
MT_IC_ST_CUR	tag.c	51;"	d	file:
MT_IC_ST_OTH	tag.c	54;"	d	file:
MT_ST_CUR	tag.c	47;"	d	file:
MT_ST_OTH	tag.c	50;"	d	file:
M_NEEDMORET	getchar.c	1018;"	d	file:
M_OFFSET	undo.c	825;"	d	file:
M_OFFSET	undo.c	828;"	d	file:
Magic	regexp.c	123;"	d	file:
Meta	ascii.h	26;"	d
NAMEDF	ex_cmds.h	54;"	d
NAMEDFS	ex_cmds.h	55;"	d
NAMLEN	os_unix.h	104;"	d
NAMLEN	os_unix.h	108;"	d
NEEDARG	ex_cmds.h	41;"	d
NETTERM_MOUSE	feature.h	395;"	d
NEXT	regexp.c	165;"	d	file:
NL	ascii.h	16;"	d
NL_STR	ascii.h	17;"	d
NMARKS	structs.h	49;"	d
NODFL	ex_cmds.h	40;"	d
NONE_IDX	syntax.c	160;"	d	file:
NOON	farsi.h	139;"	d
NORMAL	vim.h	233;"	d
NORMAL_BUSY	vim.h	239;"	d
NOSPC	ex_cmds.h	38;"	d
NOTADR	ex_cmds.h	48;"	d
NOTAGFILE	tag.c	61;"	d	file:
NOTHING	regexp.c	96;"	d	file:
NOTRLCOM	ex_cmds.h	45;"	d
NOT_VALID	vim.h	203;"	d
NO_EXPANDPATH	os_unix.h	254;"	d
NR_TRANS	structs.h	/^typedef struct nr_trans NR_TRANS;$/;"	t	typeref:struct:nr_trans
NSCRIPT	globals.h	374;"	d
NSUBEXP	regexp.h	18;"	d
NUL	ascii.h	13;"	d
NUMBUFLEN	vim.h	143;"	d
NUM_EVENTS	vim.h	/^    NUM_EVENTS		    \/* MUST be the last one *\/$/;"	e	enum:auto_event
NUM_MOUSE_CLICKS	vim.h	758;"	d
NUM_REGISTERS	ops.c	25;"	d	file:
NUM_REGISTERS	ops.c	27;"	d	file:
NWHITE	regexp.c	116;"	d	file:
NameBuff	globals.h	/^EXTERN char_u	*NameBuff;		\/* file names are expanded in this$/;"	v
NextScreen	globals.h	/^EXTERN char_u	*NextScreen INIT(= NULL);$/;"	v
OK	vim.h	254;"	d
OLD_STATIC_TAGS	feature.h	174;"	d
ONE_LINE_DATA	gui_at_sb.h	138;"	d
ONE_PAGE_DATA	gui_at_sb.h	139;"	d
OO	farsi.h	165;"	d
OP	regexp.c	164;"	d	file:
OPARG	structs.h	/^} OPARG;$/;"	t	typeref:struct:oparg
OPERAND	regexp.c	166;"	d	file:
OPERAND_MAX	regexp.c	168;"	d	file:
OPERAND_MIN	regexp.c	167;"	d	file:
OP_CHANGE	vim.h	541;"	d
OP_COLON	vim.h	548;"	d
OP_DELETE	vim.h	539;"	d
OP_FILTER	vim.h	544;"	d
OP_FORMAT	vim.h	547;"	d
OP_GFORMAT	vim.h	552;"	d
OP_INDENT	vim.h	546;"	d
OP_LOWER	vim.h	550;"	d
OP_LSHIFT	vim.h	542;"	d
OP_NOP	vim.h	538;"	d
OP_PENDING	vim.h	235;"	d
OP_RSHIFT	vim.h	543;"	d
OP_TILDE	vim.h	545;"	d
OP_UPPER	vim.h	549;"	d
OP_YANK	vim.h	540;"	d
ORIGINAL_TEXT	edit.c	67;"	d	file:
OUT_SIZE	term.c	1842;"	d	file:
OUT_SIZE	term.c	1844;"	d	file:
OUT_STR	vim.h	654;"	d
OUT_STR_NF	vim.h	655;"	d
OW	farsi.h	160;"	d
OW_OW	farsi.h	163;"	d
O_EXTRA	vim.h	607;"	d
O_EXTRA	vim.h	609;"	d
Output	if_python.c	/^static OutputObject Output =$/;"	v	file:
OutputGetattr	if_python.c	/^OutputGetattr(PyObject *self, char *name)$/;"	f	file:
OutputMethods	if_python.c	/^static struct PyMethodDef OutputMethods[] = {$/;"	v	typeref:struct:PyMethodDef	file:
OutputObject	if_python.c	/^} OutputObject;$/;"	t	typeref:struct:__anon4	file:
OutputSetattr	if_python.c	/^OutputSetattr(PyObject *self, char *name, PyObject *val)$/;"	f	file:
OutputType	if_python.c	/^static PyTypeObject OutputType = {$/;"	v	file:
OutputWrite	if_python.c	/^OutputWrite(PyObject *self, PyObject *args)$/;"	f	file:
OutputWritelines	if_python.c	/^OutputWritelines(PyObject *self, PyObject *args)$/;"	f	file:
PARAM_COUNT	option.c	969;"	d	file:
PATHSEP	ascii.h	35;"	d
PATHSEP	ascii.h	39;"	d
PATHSEP	ascii.h	42;"	d
PATHSEPSTR	ascii.h	36;"	d
PATHSEPSTR	ascii.h	40;"	d
PATHSEPSTR	ascii.h	43;"	d
PC	term.c	/^char *UP, *BC, PC;$/;"	v
PE	farsi.h	113;"	d
PLAN_CR	screen.c	2521;"	d	file:
PLAN_LE	screen.c	2520;"	d	file:
PLAN_NL	screen.c	2522;"	d	file:
PLAN_WRITE	screen.c	2523;"	d	file:
PLUS	regexp.c	99;"	d	file:
PRINT	regexp.c	108;"	d	file:
PTR_BL	memline.c	/^typedef struct pointer_block	PTR_BL;	    \/* contents of a pointer block *\/$/;"	t	typeref:struct:pointer_block	file:
PTR_EN	memline.c	/^typedef struct pointer_entry	PTR_EN;	    \/* block\/line-count pair *\/$/;"	t	typeref:struct:pointer_entry	file:
PTR_ID	memline.c	66;"	d	file:
PV_AI	option.c	/^    PV_AI = 1,$/;"	e	enum:indirect_options	file:
PV_BIN	option.c	/^    PV_BIN,$/;"	e	enum:indirect_options	file:
PV_CIN	option.c	/^    PV_CIN,$/;"	e	enum:indirect_options	file:
PV_CINK	option.c	/^    PV_CINK,$/;"	e	enum:indirect_options	file:
PV_CINO	option.c	/^    PV_CINO,$/;"	e	enum:indirect_options	file:
PV_CINW	option.c	/^    PV_CINW,$/;"	e	enum:indirect_options	file:
PV_COM	option.c	/^    PV_COM,$/;"	e	enum:indirect_options	file:
PV_CPT	option.c	/^    PV_CPT,$/;"	e	enum:indirect_options	file:
PV_EOL	option.c	/^    PV_EOL,$/;"	e	enum:indirect_options	file:
PV_ET	option.c	/^    PV_ET,$/;"	e	enum:indirect_options	file:
PV_FF	option.c	/^    PV_FF,$/;"	e	enum:indirect_options	file:
PV_FO	option.c	/^    PV_FO,$/;"	e	enum:indirect_options	file:
PV_INF	option.c	/^    PV_INF,$/;"	e	enum:indirect_options	file:
PV_ISK	option.c	/^    PV_ISK,$/;"	e	enum:indirect_options	file:
PV_LBR	option.c	/^    PV_LBR,$/;"	e	enum:indirect_options	file:
PV_LISP	option.c	/^    PV_LISP,$/;"	e	enum:indirect_options	file:
PV_LIST	option.c	/^    PV_LIST,$/;"	e	enum:indirect_options	file:
PV_ML	option.c	/^    PV_ML,$/;"	e	enum:indirect_options	file:
PV_MOD	option.c	/^    PV_MOD,$/;"	e	enum:indirect_options	file:
PV_NF	option.c	/^    PV_NF,$/;"	e	enum:indirect_options	file:
PV_NU	option.c	/^    PV_NU,$/;"	e	enum:indirect_options	file:
PV_RL	option.c	/^    PV_RL,$/;"	e	enum:indirect_options	file:
PV_RO	option.c	/^    PV_RO,$/;"	e	enum:indirect_options	file:
PV_SCROLL	option.c	/^    PV_SCROLL,$/;"	e	enum:indirect_options	file:
PV_SI	option.c	/^    PV_SI,$/;"	e	enum:indirect_options	file:
PV_SN	option.c	/^    PV_SN,$/;"	e	enum:indirect_options	file:
PV_STS	option.c	/^    PV_STS,$/;"	e	enum:indirect_options	file:
PV_SW	option.c	/^    PV_SW,$/;"	e	enum:indirect_options	file:
PV_TS	option.c	/^    PV_TS,$/;"	e	enum:indirect_options	file:
PV_TW	option.c	/^    PV_TW,$/;"	e	enum:indirect_options	file:
PV_TX	option.c	/^    PV_TX,$/;"	e	enum:indirect_options	file:
PV_WM	option.c	/^    PV_WM,$/;"	e	enum:indirect_options	file:
PV_WRAP	option.c	/^    PV_WRAP$/;"	e	enum:indirect_options	file:
P_ALLOCED	option.c	51;"	d	file:
P_BOOL	option.c	48;"	d	file:
P_DEF_ALLOCED	option.c	57;"	d	file:
P_EXPAND	option.c	54;"	d	file:
P_IND	option.c	55;"	d	file:
P_NODEFAULT	option.c	56;"	d	file:
P_NO_MKRC	option.c	60;"	d	file:
P_NUM	option.c	49;"	d	file:
P_RALL	option.c	66;"	d	file:
P_RBUF	option.c	65;"	d	file:
P_RSTAT	option.c	64;"	d	file:
P_STRING	option.c	50;"	d	file:
P_VIM	option.c	62;"	d	file:
P_VI_DEF	option.c	61;"	d	file:
P_WAS_SET	option.c	59;"	d	file:
PeekChr	regexp.c	310;"	d	file:
PyErr_SetVim	if_python.c	62;"	d	file:
PyThreadState	if_python.c	/^typedef PyObject PyThreadState;$/;"	t	file:
Py_GetProgramName	if_python.c	/^Py_GetProgramName(void)$/;"	f
PythonIO_Flush	if_python.c	/^PythonIO_Flush(void)$/;"	f	file:
PythonIO_Init	if_python.c	/^PythonIO_Init(void)$/;"	f	file:
PythonMod_Init	if_python.c	/^PythonMod_Init(void)$/;"	f	file:
Python_Init	if_python.c	/^Python_Init(void)$/;"	f	file:
Python_Lock_Vim	if_python.c	/^static void Python_Lock_Vim() {$/;"	f	file:
Python_Release_Vim	if_python.c	/^static void Python_Release_Vim() {$/;"	f	file:
Python_RestoreThread	if_python.c	/^static void Python_RestoreThread() {$/;"	f	file:
Python_SaveThread	if_python.c	/^static void Python_SaveThread() {$/;"	f	file:
QUICKFIX	feature.h	112;"	d
RANGE	ex_cmds.h	34;"	d
RBAppend	if_python.c	/^RBAppend(BufferObject *self, PyObject *args, int start, int end, int *new_end)$/;"	f	file:
RBAssItem	if_python.c	/^RBAssItem(BufferObject *self, int n, PyObject *val, int start, int end, int *new_end)$/;"	f	file:
RBAssSlice	if_python.c	/^RBAssSlice(BufferObject *self, int lo, int hi, PyObject *val, int start, int end, int *new_end)$/;"	f	file:
RBItem	if_python.c	/^RBItem(BufferObject *self, int n, int start, int end)$/;"	f	file:
RBSlice	if_python.c	/^RBSlice(BufferObject *self, int lo, int hi, int start, int end)$/;"	f	file:
RE	farsi.h	122;"	d
READBIN	vim.h	594;"	d
READBIN	vim.h	598;"	d
READ_FILTER	vim.h	357;"	d
READ_NEW	vim.h	356;"	d
READ_STDIN	vim.h	358;"	d
REGEXP_ABBR	regexp.c	/^static char_u REGEXP_ABBR[] = "rteb";$/;"	v	file:
REGEXP_INRANGE	regexp.c	/^static char_u REGEXP_INRANGE[] = "]^-\\\\";$/;"	v	file:
REGSTR	ex_cmds.h	43;"	d
REPLACE	vim.h	240;"	d
RETSIGTYPE	config.h	82;"	d
RET_ERROR	vim.h	533;"	d
RET_WIN_BUF_CHARTABSIZE	charset.c	317;"	d	file:
RE_BOTH	vim.h	387;"	d
RE_LAST	vim.h	388;"	d
RE_SEARCH	vim.h	385;"	d
RE_SUBST	vim.h	386;"	d
RIGHTLEFT	feature.h	138;"	d
RIGHTLEFT	feature.h	147;"	d
RLADDSUBFIX	ops.c	2489;"	d	file:
RLADDSUBFIX	ops.c	2491;"	d	file:
RangeAppend	if_python.c	/^RangeAppend(PyObject *self, PyObject *args)$/;"	f	file:
RangeAsSeq	if_python.c	/^static PySequenceMethods RangeAsSeq = {$/;"	v	file:
RangeAssItem	if_python.c	/^RangeAssItem(PyObject *self, int n, PyObject *val)$/;"	f	file:
RangeAssSlice	if_python.c	/^RangeAssSlice(PyObject *self, int lo, int hi, PyObject *val)$/;"	f	file:
RangeDestructor	if_python.c	/^RangeDestructor(PyObject *self)$/;"	f	file:
RangeEnd	if_python.c	/^static int RangeEnd;$/;"	v	file:
RangeGetattr	if_python.c	/^RangeGetattr(PyObject *self, char *name)$/;"	f	file:
RangeItem	if_python.c	/^RangeItem(PyObject *self, int n)$/;"	f	file:
RangeLength	if_python.c	/^RangeLength(PyObject *self)$/;"	f	file:
RangeMethods	if_python.c	/^static struct PyMethodDef RangeMethods[] = {$/;"	v	typeref:struct:PyMethodDef	file:
RangeNew	if_python.c	/^RangeNew(BUF *buf, int start, int end)$/;"	f	file:
RangeObject	if_python.c	/^RangeObject;$/;"	t	typeref:struct:__anon7	file:
RangeRepr	if_python.c	/^RangeRepr(PyObject *self)$/;"	f	file:
RangeSlice	if_python.c	/^RangeSlice(PyObject *self, int lo, int hi)$/;"	f	file:
RangeStart	if_python.c	/^static int RangeStart;$/;"	v	file:
RangeType	if_python.c	/^static PyTypeObject RangeType = {$/;"	v	file:
RangeType	if_python.c	/^static PyTypeObject RangeType;$/;"	v	file:
RangeType_Check	if_python.c	557;"	d	file:
RealWaitForChar	os_unix.c	/^RealWaitForChar(fd, msec)$/;"	f
Recording	globals.h	/^EXTERN int	Recording INIT(= FALSE);\/* TRUE when recording into a reg. *\/$/;"	v
RedrawingDisabled	globals.h	/^EXTERN int	RedrawingDisabled INIT(= FALSE);$/;"	v
ResetRedobuff	getchar.c	/^ResetRedobuff()$/;"	f
Rows	globals.h	/^EXTERN long	Rows INIT(= MIN_ROWS + 1);   \/* nr of rows in the screen *\/$/;"	v
SAD	farsi.h	127;"	d
SBAR_BOTTOM	gui.h	110;"	d
SBAR_HORIZ	gui.h	114;"	d
SBAR_LEFT	gui.h	108;"	d
SBAR_NONE	gui.h	107;"	d
SBAR_RIGHT	gui.h	109;"	d
SBAR_VERT	gui.h	113;"	d
SB_DEFAULT_WIDTH	gui.h	117;"	d
SCREEN_LINE	screen.c	66;"	d	file:
SCREEN_LINE	screen.c	69;"	d	file:
SE	farsi.h	115;"	d
SEARCH_ECHO	vim.h	321;"	d
SEARCH_END	vim.h	326;"	d
SEARCH_HIS	vim.h	325;"	d
SEARCH_KEEP	vim.h	330;"	d
SEARCH_MARK	vim.h	329;"	d
SEARCH_MSG	vim.h	322;"	d
SEARCH_NFMSG	vim.h	323;"	d
SEARCH_NOOF	vim.h	327;"	d
SEARCH_OPT	vim.h	324;"	d
SEARCH_REV	vim.h	320;"	d
SEARCH_START	vim.h	328;"	d
SEEK_END	os_unix.c	2556;"	d	file:
SEEK_SET	os_unix.c	2553;"	d	file:
SELECT_CLEARED	vim.h	784;"	d
SELECT_DONE	vim.h	786;"	d
SELECT_IN_PROGRESS	vim.h	785;"	d
SELECT_MODE_CHAR	vim.h	788;"	d
SELECT_MODE_LINE	vim.h	790;"	d
SELECT_MODE_WORD	vim.h	789;"	d
SETWSIZE	vim.h	243;"	d
SET_NUM_MOUSE_CLICKS	vim.h	761;"	d
SFNAME	regexp.c	111;"	d	file:
SF_CCOMMENT	syntax.c	165;"	d	file:
SF_MATCH	syntax.c	166;"	d	file:
SHELL_COOKED	vim.h	352;"	d
SHELL_DOOUT	vim.h	353;"	d
SHELL_EXPAND	vim.h	351;"	d
SHELL_FILTER	vim.h	350;"	d
SHIN	farsi.h	126;"	d
SHM_A	option.h	141;"	d
SHM_ALL	option.h	148;"	d
SHM_ATTENTION	option.h	146;"	d
SHM_FILE	option.h	135;"	d
SHM_INTRO	option.h	147;"	d
SHM_LAST	option.h	136;"	d
SHM_LINES	option.h	138;"	d
SHM_MOD	option.h	134;"	d
SHM_NEW	option.h	139;"	d
SHM_OVER	option.h	144;"	d
SHM_RO	option.h	133;"	d
SHM_SEARCH	option.h	145;"	d
SHM_TEXT	option.h	137;"	d
SHM_TRUNC	option.h	143;"	d
SHM_WRI	option.h	140;"	d
SHM_WRITE	option.h	142;"	d
SHOWCMD	feature.h	89;"	d
SHOWCMD_COLS	vim.h	671;"	d
SHOWMATCH	vim.h	246;"	d
SIDENT	regexp.c	109;"	d	file:
SIGDEFARG	os_unix.c	/^catch_sigint SIGDEFARG(sigarg)$/;"	f	file:
SIGDEFARG	os_unix.c	/^deathtrap SIGDEFARG(sigarg)$/;"	f	file:
SIGDEFARG	os_unix.c	/^sig_alarm SIGDEFARG(sigarg)$/;"	f	file:
SIGDEFARG	os_unix.c	/^sig_winch SIGDEFARG(sigarg)$/;"	f	file:
SIGDEFARG	os_unix.h	88;"	d
SIGDEFARG	os_unix.h	92;"	d
SIGDEFARG	os_unix.h	97;"	d
SIGDUMMYARG	os_unix.h	89;"	d
SIGDUMMYARG	os_unix.h	93;"	d
SIGDUMMYARG	os_unix.h	98;"	d
SIGHAS3ARGS	os_unix.h	82;"	d
SIGHASARG	os_unix.h	77;"	d
SIGPROTOARG	os_unix.h	87;"	d
SIGPROTOARG	os_unix.h	91;"	d
SIGPROTOARG	os_unix.h	96;"	d
SIGPROTOARG	osdef.h	/^extern RETSIGTYPE (*sigset __ARGS((int, RETSIGTYPE (*func) SIGPROTOARG))) __ARGS(SIGPROTOARG);$/;"	v
SIGRETURN	config.h	85;"	d
SIGWINCH	os_unix.c	54;"	d	file:
SIGWINCH	os_unix.c	62;"	d	file:
SIG_ERR	os_unix.c	118;"	d	file:
SIMPLE	regexp.c	204;"	d	file:
SIN	farsi.h	125;"	d
SIZEOF_INT	config.h	44;"	d
SMARTINDENT	feature.h	274;"	d
SMBUFSIZE	fileio.c	32;"	d	file:
SMODE_CONT	gui_at_sb.h	132;"	d
SMODE_LINE_DOWN	gui_at_sb.h	136;"	d
SMODE_LINE_UP	gui_at_sb.h	135;"	d
SMODE_NONE	gui_at_sb.h	131;"	d
SMODE_PAGE_DOWN	gui_at_sb.h	134;"	d
SMODE_PAGE_UP	gui_at_sb.h	133;"	d
SOLARIS	os_unix.h	48;"	d
SOME_BUILTIN_TCAPS	feature.h	250;"	d
SPECIAL_WILDCHAR	os_unix.h	251;"	d
SPEC_AFILE	ex_docmd.c	5314;"	d	file:
SPEC_CCWORD	ex_docmd.c	5307;"	d	file:
SPEC_CFILE	ex_docmd.c	5309;"	d	file:
SPEC_COUNT	ex_docmd.c	5317;"	d	file:
SPEC_CWORD	ex_docmd.c	5305;"	d	file:
SPEC_HASH	ex_docmd.c	5303;"	d	file:
SPEC_PERC	ex_docmd.c	5301;"	d	file:
SPEC_SFILE	ex_docmd.c	5311;"	d	file:
SPO_COUNT	syntax.c	100;"	d	file:
SPO_HE_OFF	syntax.c	96;"	d	file:
SPO_HS_OFF	syntax.c	95;"	d	file:
SPO_LC_OFF	syntax.c	99;"	d	file:
SPO_ME_OFF	syntax.c	94;"	d	file:
SPO_MS_OFF	syntax.c	93;"	d	file:
SPO_RE_OFF	syntax.c	98;"	d	file:
SPO_RS_OFF	syntax.c	97;"	d	file:
SPRINT	regexp.c	112;"	d	file:
SPSTART	regexp.c	205;"	d	file:
SPTYPE_END	syntax.c	143;"	d	file:
SPTYPE_MATCH	syntax.c	141;"	d	file:
SPTYPE_SKIP	syntax.c	144;"	d	file:
SPTYPE_START	syntax.c	142;"	d	file:
SRC_CMD	farsi.h	176;"	d
SRC_EDT	farsi.h	175;"	d
STACK_INCR	memline.c	170;"	d	file:
STAR	regexp.c	97;"	d	file:
STATFS	memfile.c	48;"	d	file:
STATFS	memfile.c	54;"	d	file:
STATUS_HEIGHT	vim.h	566;"	d
STRCAT	vim.h	642;"	d
STRCMP	vim.h	622;"	d
STRCPY	vim.h	620;"	d
STRICMP	vim.h	625;"	d
STRICMP	vim.h	628;"	d
STRICMP	vim.h	630;"	d
STRLEN	vim.h	619;"	d
STRNCAT	vim.h	643;"	d
STRNCMP	vim.h	623;"	d
STRNCPY	vim.h	621;"	d
STRNICMP	vim.h	634;"	d
STRNICMP	vim.h	637;"	d
STRNICMP	vim.h	639;"	d
SVR4	config.h	41;"	d
SVR4	os_unix.h	41;"	d
SWORD	regexp.c	110;"	d	file:
SYNTAX_HL	feature.h	219;"	d
SYN_ITEMS	syntax.c	158;"	d	file:
SYN_NAMELEN	syntax.c	90;"	d	file:
SYN_STATE_P	syntax.c	168;"	d	file:
SYS_GVIMRC_FILE	os_unix.h	175;"	d
SYS_MENU_FILE	os_unix.h	178;"	d
SYS_SELECT_WITH_SYS_TIME	config.h	79;"	d
SYS_VIMRC_FILE	os_unix.h	172;"	d
ScrollbarClassPart	gui_at_sb.h	/^typedef struct {int empty;} ScrollbarClassPart;$/;"	t	typeref:struct:__anon17
ScrollbarClassRec	gui_at_sb.h	/^} ScrollbarClassRec;$/;"	t	typeref:struct:_ScrollbarClassRec
ScrollbarPart	gui_at_sb.h	/^} ScrollbarPart;$/;"	t	typeref:struct:__anon16
ScrollbarRec	gui_at_sb.h	/^} ScrollbarRec;$/;"	t	typeref:struct:_ScrollbarRec
ScrollbarWidget	gui_at_sb.h	/^typedef struct _ScrollbarRec	  *ScrollbarWidget;$/;"	t	typeref:struct:_ScrollbarRec
ScrollbarWidgetClass	gui_at_sb.h	/^typedef struct _ScrollbarClassRec *ScrollbarWidgetClass;$/;"	t	typeref:struct:_ScrollbarClassRec
SearchedFile	search.c	/^typedef struct SearchedFile$/;"	s	file:
SearchedFile	search.c	/^} SearchedFile;$/;"	t	typeref:struct:SearchedFile	file:
SetBufferLine	if_python.c	/^SetBufferLine(BUF *buf, int n, PyObject *line, int *len_change)$/;"	f	file:
SetBufferLineList	if_python.c	/^SetBufferLineList(BUF *buf, int lo, int hi, PyObject *list, int *len_change)$/;"	f	file:
SpecialKey	term.h	/^enum SpecialKey$/;"	g
State	globals.h	/^EXTERN int	State INIT(= NORMAL);	\/* This is the current state of the$/;"	v
StringToLine	if_python.c	/^StringToLine(PyObject *obj)$/;"	f	file:
TAB	ascii.h	15;"	d
TAGSTACKSIZE	structs.h	51;"	d
TAG_HELP	vim.h	457;"	d
TAG_NAMES	vim.h	458;"	d
TAG_WILD	vim.h	459;"	d
TASH	farsi.h	164;"	d
TA_DFLT	option.h	53;"	d
TA_DFLT	option.h	63;"	d
TBUFSZ	vim.h	581;"	d
TBUFSZ	vim.h	583;"	d
TE	farsi.h	114;"	d
TEE	farsi.h	143;"	d
TEE_	farsi.h	27;"	d
TEMPDIRNAMES	os_unix.h	242;"	d
TEMPNAME	os_unix.h	243;"	d
TEMPNAME	os_unix.h	246;"	d
TEMPNAMELEN	fileio.c	2429;"	d	file:
TEMPNAMELEN	os_unix.h	244;"	d
TEMPNAMELEN	os_unix.h	247;"	d
TERMCAP2KEY	keymap.h	89;"	d
TERMINFO	config.h	20;"	d
TERM_ATTR_ENTRY	syntax.c	4743;"	d	file:
TEXT_OBJECTS	feature.h	82;"	d
TEXT_X	gui.h	78;"	d
TEXT_Y	gui.h	79;"	d
TGETENT	term.c	113;"	d	file:
TGETSTR	term.c	112;"	d	file:
TIME_WITH_SYS_TIME	config.h	76;"	d
TIOCGWINSZ	os_unix.c	57;"	d	file:
TMODE_COOK	term.h	136;"	d
TMODE_RAW	term.h	137;"	d
TO_LOWER	macros.h	44;"	d
TO_LOWER	macros.h	48;"	d
TO_LOWER	macros.h	51;"	d
TO_SPECIAL	keymap.h	103;"	d
TO_UPPER	macros.h	43;"	d
TO_UPPER	macros.h	47;"	d
TO_UPPER	macros.h	50;"	d
TPUTSFUNCAST	term.c	40;"	d	file:
TPUTSFUNCAST	term.c	43;"	d	file:
TPUTSFUNCAST	term.c	45;"	d	file:
TRLBAR	ex_cmds.h	42;"	d
TRUE	vim.h	527;"	d
TYPELEN_INIT	getchar.c	115;"	d	file:
TYPE_EQUAL	eval.c	/^    TYPE_EQUAL,		\/* == *\/$/;"	e	enum:exp_type	file:
TYPE_GEQUAL	eval.c	/^    TYPE_GEQUAL,	\/* >= *\/$/;"	e	enum:exp_type	file:
TYPE_GREATER	eval.c	/^    TYPE_GREATER,	\/* >  *\/$/;"	e	enum:exp_type	file:
TYPE_MATCH	eval.c	/^    TYPE_MATCH,		\/* =~ *\/$/;"	e	enum:exp_type	file:
TYPE_NEQUAL	eval.c	/^    TYPE_NEQUAL,	\/* != *\/$/;"	e	enum:exp_type	file:
TYPE_NOMATCH	eval.c	/^    TYPE_NOMATCH	\/* !~ *\/$/;"	e	enum:exp_type	file:
TYPE_SEQUAL	eval.c	/^    TYPE_SEQUAL,	\/* <= *\/$/;"	e	enum:exp_type	file:
TYPE_SMALLER	eval.c	/^    TYPE_SMALLER,	\/* <  *\/$/;"	e	enum:exp_type	file:
TYPE_UNKNOWN	eval.c	/^    TYPE_UNKNOWN = 0,$/;"	e	enum:exp_type	file:
T_AL	term.h	93;"	d
T_BC	term.h	123;"	d
T_CAB	term.h	131;"	d
T_CAF	term.h	130;"	d
T_CAL	term.h	94;"	d
T_CCO	term.h	125;"	d
T_CCS	term.h	124;"	d
T_CD	term.h	99;"	d
T_CDL	term.h	96;"	d
T_CE	term.h	92;"	d
T_CL	term.h	98;"	d
T_CM	term.h	115;"	d
T_CRI	term.h	117;"	d
T_CS	term.h	97;"	d
T_CSB	term.h	127;"	d
T_CSF	term.h	126;"	d
T_CZH	term.h	110;"	d
T_CZR	term.h	111;"	d
T_DA	term.h	100;"	d
T_DB	term.h	101;"	d
T_DL	term.h	95;"	d
T_KE	term.h	120;"	d
T_KS	term.h	119;"	d
T_LE	term.h	132;"	d
T_MB	term.h	129;"	d
T_MD	term.h	107;"	d
T_ME	term.h	105;"	d
T_MR	term.h	106;"	d
T_MS	term.h	114;"	d
T_NAME	term.h	91;"	d
T_ND	term.h	133;"	d
T_OP	term.h	134;"	d
T_SE	term.h	108;"	d
T_SO	term.h	109;"	d
T_SR	term.h	116;"	d
T_TE	term.h	122;"	d
T_TI	term.h	121;"	d
T_UE	term.h	112;"	d
T_US	term.h	113;"	d
T_VB	term.h	118;"	d
T_VE	term.h	103;"	d
T_VI	term.h	102;"	d
T_VS	term.h	104;"	d
T_XS	term.h	128;"	d
TheBufferList	if_python.c	/^static BufListObject TheBufferList =$/;"	v	file:
TheCurrent	if_python.c	/^static CurrentObject TheCurrent =$/;"	v	file:
TheWindowList	if_python.c	/^static WinListObject TheWindowList =$/;"	v	file:
UCHARAT	regexp.c	174;"	d	file:
UCHARAT	regexp.c	176;"	d	file:
UH_CHANGED	structs.h	115;"	d
UH_EMPTYBUF	structs.h	116;"	d
UNCHANGED	vim.h	613;"	d
UNIX	config.h	40;"	d
UNKNOWN	fileio.c	116;"	d	file:
UP	term.c	/^char *UP, *BC, PC;$/;"	v
URL_BACKSLASH	window.c	28;"	d	file:
URL_SLASH	window.c	27;"	d	file:
USECTRLV	ex_cmds.h	47;"	d
USEMEMMOVE	config.h	51;"	d
USE_CLIPBOARD	gui.h	52;"	d
USE_FSTATFS	memfile.c	131;"	d	file:
USE_GETCWD	os_unix.h	58;"	d
USE_GUI	vim.h	35;"	d
USE_GUI_MAC	vim.h	25;"	d
USE_GUI_X11	gui.h	15;"	d
USE_GUI_X11	gui.h	20;"	d
USE_MOUSE	gui.h	55;"	d
USE_MOUSE	os_unix.h	266;"	d
USE_NL	screen.c	3845;"	d	file:
USE_TMPNAM	fileio.c	2428;"	d	file:
USE_T_AL	screen.c	3841;"	d	file:
USE_T_CAL	screen.c	3839;"	d	file:
USE_T_CD	screen.c	3846;"	d	file:
USE_T_CDL	screen.c	3840;"	d	file:
USE_T_CE	screen.c	3842;"	d	file:
USE_T_DL	screen.c	3843;"	d	file:
USE_T_SR	screen.c	3844;"	d	file:
USR_EXRC_FILE	os_unix.h	182;"	d
USR_GVIMRC_FILE	os_unix.h	188;"	d
USR_VIMRC_FILE	os_unix.h	185;"	d
VALID	vim.h	199;"	d
VALID_BEF_CURSCHAR	vim.h	202;"	d
VALID_BOTLINE	screen.c	54;"	d	file:
VALID_BOTLINE_AP	screen.c	55;"	d	file:
VALID_CHEIGHT	screen.c	52;"	d	file:
VALID_CROW	screen.c	53;"	d	file:
VALID_H	ex_docmd.c	5295;"	d	file:
VALID_P	ex_docmd.c	5294;"	d	file:
VALID_STATE	syntax.c	235;"	d	file:
VALID_TO_CURSCHAR	vim.h	201;"	d
VALID_VIRTCOL	screen.c	51;"	d	file:
VALID_WCOL	screen.c	50;"	d	file:
VALID_WROW	screen.c	49;"	d	file:
VAR	eval.c	/^typedef var *	VAR;$/;"	t	file:
VAR_ENTRY	eval.c	49;"	d	file:
VAR_GAP_ENTRY	eval.c	50;"	d	file:
VAR_NUMBER	eval.c	40;"	d	file:
VAR_STRING	eval.c	41;"	d	file:
VAR_UNKNOWN	eval.c	39;"	d	file:
VIMINFO	feature.h	208;"	d
VIMINFO_FILE	os_unix.h	193;"	d
VIMRC_FILE	os_unix.h	202;"	d
VIM_DEFAULT	option.c	40;"	d	file:
VIM_HLP	os_unix.h	212;"	d
VIM_MEMCMP	vim.h	719;"	d
VIM_MEMMOVE	os_unix.h	289;"	d
VIM_VERSION_BUILD	version.h	19;"	d
VIM_VERSION_BUILD_STR	version.h	20;"	d
VIM_VERSION_LONG	version.h	31;"	d
VIM_VERSION_LONG_DATE	version.h	32;"	d
VIM_VERSION_MAJOR	version.h	15;"	d
VIM_VERSION_MAJOR_STR	version.h	16;"	d
VIM_VERSION_MEDIUM	version.h	30;"	d
VIM_VERSION_MINOR	version.h	17;"	d
VIM_VERSION_MINOR_STR	version.h	18;"	d
VIM_VERSION_PATCHLEVEL	version.h	21;"	d
VIM_VERSION_PATCHLEVEL_STR	version.h	22;"	d
VIM_VERSION_SHORT	version.h	29;"	d
VISUAL	vim.h	234;"	d
VI_DEFAULT	option.c	39;"	d	file:
VIsual	globals.h	/^EXTERN FPOS	VIsual;		\/* start position of active Visual selection *\/$/;"	v
VIsual_active	globals.h	/^EXTERN int	VIsual_active INIT(= FALSE);$/;"	v
VIsual_mode	globals.h	/^EXTERN int	VIsual_mode INIT(= 'v');$/;"	v
Version	version.c	/^char	*Version = VIM_VERSION_SHORT;$/;"	v
VimClipboard	vim.h	/^typedef struct VimClipboard$/;"	s
VimClipboard	vim.h	/^} VimClipboard;$/;"	t	typeref:struct:VimClipboard
VimCommand	if_python.c	/^VimCommand(PyObject *self, PyObject *args)$/;"	f	file:
VimError	if_python.c	/^static PyObject *VimError;$/;"	v	file:
VimErrorCheck	if_python.c	/^VimErrorCheck(void)$/;"	f	file:
VimEval	if_python.c	/^VimEval(PyObject *self, PyObject *args)$/;"	f	file:
VimFont	gui.h	/^    FontInfo	VimFont;	    \/* contians width height ascent,descent*\/$/;"	m	struct:Gui
VimFontID	gui.h	/^    short	VimFontID;$/;"	m	struct:Gui
VimMethods	if_python.c	/^static struct PyMethodDef VimMethods[] = {$/;"	v	typeref:struct:PyMethodDef	file:
VimWindow	gui.h	/^    WindowPtr	VimWindow;$/;"	m	struct:Gui
WANT_EVAL	feature.h	190;"	d
WANT_X11	feature.h	382;"	d
WAW	farsi.h	140;"	d
WAW_H	farsi.h	167;"	d
WEXITSTATUS	os_unixx.h	38;"	d
WEXITSTATUS	os_unixx.h	40;"	d
WHITE	regexp.c	115;"	d	file:
WIFEXITED	os_unixx.h	46;"	d
WIFEXITED	os_unixx.h	48;"	d
WILD_ALL	vim.h	292;"	d
WILD_EXPAND_FREE	vim.h	288;"	d
WILD_EXPAND_KEEP	vim.h	289;"	d
WILD_FREE	vim.h	287;"	d
WILD_HOME_REPLACE	vim.h	296;"	d
WILD_LIST_NOTFOUND	vim.h	295;"	d
WILD_LONGEST	vim.h	293;"	d
WILD_NEXT	vim.h	290;"	d
WILD_PREV	vim.h	291;"	d
WIN	structs.h	/^typedef struct window	    WIN;$/;"	t	typeref:struct:window
WINLNUM	structs.h	/^typedef struct winlnum	    WINLNUM;$/;"	t	typeref:struct:winlnum
WM_OLE	vim.h	794;"	d
WORD	regexp.c	106;"	d	file:
WORD1	ex_cmds.h	52;"	d
WORST	regexp.c	206;"	d	file:
WRITEBACKUP	feature.h	291;"	d
WRITEBIN	vim.h	593;"	d
WRITEBIN	vim.h	597;"	d
WVAR_ENTRY	eval.c	52;"	d	file:
WW_ALL	option.h	120;"	d
W_CONV	farsi.h	184;"	d
W_OK	os_unix.h	165;"	d
W_R_L	farsi.h	185;"	d
WaitForChar	os_unix.c	/^WaitForChar(msec)$/;"	f	file:
WantQueryMouse	globals.h	/^EXTERN int	WantQueryMouse INIT(= 0);$/;"	v
WinListAsSeq	if_python.c	/^static PySequenceMethods WinListAsSeq = {$/;"	v	file:
WinListItem	if_python.c	/^WinListItem(PyObject *self, int n)$/;"	f	file:
WinListLength	if_python.c	/^WinListLength(PyObject *self)$/;"	f	file:
WinListObject	if_python.c	/^WinListObject;$/;"	t	typeref:struct:__anon9	file:
WinListType	if_python.c	/^static PyTypeObject WinListType = {$/;"	v	file:
WindowDestructor	if_python.c	/^WindowDestructor(PyObject *self)$/;"	f	file:
WindowGetattr	if_python.c	/^WindowGetattr(PyObject *self, char *name)$/;"	f	file:
WindowMethods	if_python.c	/^static struct PyMethodDef WindowMethods[] = {$/;"	v	typeref:struct:PyMethodDef	file:
WindowNew	if_python.c	/^WindowNew(WIN *win)$/;"	f	file:
WindowObject	if_python.c	/^WindowObject;$/;"	t	typeref:struct:__anon5	file:
WindowRepr	if_python.c	/^WindowRepr(PyObject *self)$/;"	f	file:
WindowSetattr	if_python.c	/^WindowSetattr(PyObject *self, char *name, PyObject *val)$/;"	f	file:
WindowType	if_python.c	/^static PyTypeObject WindowType = {$/;"	v	file:
WindowType	if_python.c	/^static PyTypeObject WindowType;$/;"	v	file:
WindowType_Check	if_python.c	502;"	d	file:
XE	farsi.h	119;"	d
XFILE	ex_cmds.h	37;"	d
XTERM_MOUSE	feature.h	392;"	d
X_2_COL	gui.h	83;"	d
XtCBottomShadowPixel	gui_at_sb.h	81;"	d
XtCMaxOfThumb	gui_at_sb.h	78;"	d
XtCMinimumThumb	gui_at_sb.h	75;"	d
XtCShadowWidth	gui_at_sb.h	79;"	d
XtCShown	gui_at_sb.h	76;"	d
XtCTopOfThumb	gui_at_sb.h	77;"	d
XtCTopShadowPixel	gui_at_sb.h	80;"	d
XtNbottomShadowPixel	gui_at_sb.h	88;"	d
XtNmaxOfThumb	gui_at_sb.h	85;"	d
XtNminimumThumb	gui_at_sb.h	83;"	d
XtNshadowWidth	gui_at_sb.h	86;"	d
XtNtopOfThumb	gui_at_sb.h	84;"	d
XtNtopShadowPixel	gui_at_sb.h	87;"	d
YE	farsi.h	142;"	d
YEE	farsi.h	145;"	d
YEE_	farsi.h	63;"	d
YE_	farsi.h	64;"	d
Y_2_ROW	gui.h	84;"	d
ZAD	farsi.h	128;"	d
ZAL	farsi.h	121;"	d
ZE	farsi.h	123;"	d
ZEROR	ex_cmds.h	46;"	d
ZERO_BL	memline.c	/^typedef struct block0		ZERO_BL;    \/* contents of the first block *\/$/;"	t	typeref:struct:block0	file:
_AYN	farsi.h	42;"	d
_AYN_	farsi.h	43;"	d
_BE	farsi.h	30;"	d
_CHE	farsi.h	35;"	d
_FE	farsi.h	48;"	d
_GAF	farsi.h	51;"	d
_GHAF	farsi.h	49;"	d
_GHAYN	farsi.h	45;"	d
_GHAYN_	farsi.h	46;"	d
_HE	farsi.h	56;"	d
_HE_	farsi.h	57;"	d
_HE_J	farsi.h	36;"	d
_IE	farsi.h	59;"	d
_IO_PTEM_H	os_unixx.h	79;"	d
_JIM	farsi.h	34;"	d
_KAF	farsi.h	50;"	d
_KAF_H	farsi.h	144;"	d
_LAM	farsi.h	52;"	d
_MIM	farsi.h	54;"	d
_NOON	farsi.h	55;"	d
_NO_PROTO	os_unix.h	21;"	d
_PE	farsi.h	31;"	d
_PROTO_H	proto.h	143;"	d
_REGEXP_H	regexp.h	16;"	d
_SAD	farsi.h	40;"	d
_SE	farsi.h	33;"	d
_SHIN	farsi.h	39;"	d
_SIN	farsi.h	38;"	d
_ScrollbarClassRec	gui_at_sb.h	/^typedef struct _ScrollbarClassRec {$/;"	s
_ScrollbarRec	gui_at_sb.h	/^typedef struct _ScrollbarRec {$/;"	s
_Scrollbar_h	gui_at_sb.h	60;"	d
_TA	farsi.h	129;"	d
_TE	farsi.h	32;"	d
_XE	farsi.h	37;"	d
_YE	farsi.h	58;"	d
_YEE	farsi.h	62;"	d
_ZA	farsi.h	130;"	d
_ZAD	farsi.h	41;"	d
__ARGS	os_unix.h	161;"	d
__ARGS	os_unix.h	63;"	d
__ARGS	os_unix.h	65;"	d
__ARGS	regexp.c	/^typedef void (*(*fptr) __ARGS((char_u *, int)))();$/;"	t	file:
__ARGS	regexp.c	2334;"	d	file:
__ARGS	regexp.c	2335;"	d	file:
__ARGS	vim.h	54;"	d
__ARGS	vim.h	59;"	d
__ARGS	vim.h	64;"	d
__ARGS	vim.h	68;"	d
__ARGS	vim.h	73;"	d
__ARGS	vim.h	86;"	d
__ARGS	vim.h	88;"	d
__PARMS	vim.h	94;"	d
add_buff	getchar.c	/^add_buff(buf, s)$/;"	f	file:
add_char_buff	getchar.c	/^add_char_buff(buf, c)$/;"	f	file:
add_completion	edit.c	/^add_completion(str, len, fname, dir, reuse)$/;"	f	file:
add_completion_and_infercase	edit.c	/^add_completion_and_infercase(str, len, fname, dir, reuse)$/;"	f
add_keyword	syntax.c	/^add_keyword(name, id, flags, next_list)$/;"	f	file:
add_long_to_buf	term.c	/^add_long_to_buf(val, dst)$/;"	f
add_num_buff	getchar.c	/^add_num_buff(buf, n)$/;"	f	file:
add_termcap_entry	term.c	/^add_termcap_entry(name, force)$/;"	f
add_termcode	term.c	/^add_termcode(name, string)$/;"	f
add_to_history	ex_getln.c	/^add_to_history(histype, new_entry)$/;"	f
add_to_input_buf	ui.c	/^add_to_input_buf(s, len)$/;"	f
add_to_showcmd	normal.c	/^add_to_showcmd(c)$/;"	f
add_to_showcmd_c	normal.c	/^add_to_showcmd_c(c)$/;"	f
addfile	misc1.c	/^addfile(gap, f, flags)$/;"	f
addr_count	ex_cmds.h	/^    int		addr_count; \/* the number of addresses given *\/$/;"	m	struct:exarg
addstar	ex_getln.c	/^addstar(fname, len)$/;"	f
adjust_cursor	misc2.c	/^adjust_cursor()$/;"	f
adjust_cursor_col	misc2.c	/^adjust_cursor_col()$/;"	f
adr	quickfix.c	/^    char_u	    *(adr[MAX_ADDR]);	\/* addresses used *\/$/;"	m	struct:eformat	file:
adr	quickfix.c	/^    void	    *(adr[MAX_ADDR]);$/;"	m	struct:eformat	file:
adr_cnt	quickfix.c	/^    int		    adr_cnt;	    \/* number of addresses used *\/$/;"	m	struct:eformat	file:
ae_attr	structs.h	/^    short	    ae_attr;		\/* HL_BOLD, etc. *\/$/;"	m	struct:attr_entry
ae_u	structs.h	/^    } ae_u;$/;"	m	struct:attr_entry	typeref:union:attr_entry::__anon12
after_label	misc1.c	/^after_label(l)$/;"	f	file:
all_cflags	pathdef.c	/^char_u *all_cflags = (char_u *)"gcc -c -I. -Iproto -DHAVE_CONFIG_H    -g -O2 -Wall -Wshadow   -I\/usr\/include\/python2.4 ";$/;"	v
all_lflags	pathdef.c	/^char_u *all_lflags = (char_u *)"gcc  -o vim         -lncurses  \/usr\/lib\/python2.4\/config\/libpython2.4.a   -lpthread -ldl  -lutil -lm  ";$/;"	v
alloc	misc2.c	/^alloc(size)$/;"	f
alloc_check	misc2.c	/^alloc_check(size)$/;"	f
alloc_clear	misc2.c	/^alloc_clear(size)$/;"	f
alloc_cmdbuff	ex_getln.c	/^alloc_cmdbuff(len)$/;"	f	file:
alloc_string_var	eval.c	/^alloc_string_var(s)$/;"	f	file:
alloc_var	eval.c	/^alloc_var()$/;"	f	file:
allow_dirs	fileio.c	/^    char	    allow_dirs;		\/* Pattern may match whole path *\/$/;"	m	struct:AutoPat	file:
allow_keys	globals.h	/^EXTERN int	allow_keys INIT(= FALSE);   \/* allow key codes when no_mapping$/;"	v
amount	ex_cmds.h	/^    int		amount;	    \/* number of '>' or '<' for shift command *\/$/;"	m	struct:exarg
append	ex_cmds.h	/^    int		append;	    \/* TRUE with ":w >>file" command *\/$/;"	m	struct:exarg
append_arg_number	buffer.c	/^append_arg_number(buf, add_file, maxlen)$/;"	f	file:
apply_autocmds	fileio.c	/^apply_autocmds(event, fname, fname_io, force)$/;"	f
apply_autocmds_group	fileio.c	/^apply_autocmds_group(event, fname, fname_io, force, group)$/;"	f	file:
approximate_botline	screen.c	/^approximate_botline()$/;"	f
arg	ex_cmds.h	/^    char_u	*arg;	    \/* argument of the command *\/$/;"	m	struct:exarg
arg_file_count	globals.h	/^EXTERN int	arg_file_count;	\/* number of files *\/$/;"	v
arg_files	globals.h	/^EXTERN char_u	**arg_files;	\/* list of files *\/$/;"	v
arg_had_last	globals.h	/^EXTERN int	arg_had_last INIT(= FALSE); \/* accessed last file in arglist *\/$/;"	v
arrow_used	globals.h	/^EXTERN int	arrow_used;		\/* Normally FALSE, set to TRUE after$/;"	v
ask_yesno	misc1.c	/^ask_yesno(str, direct)$/;"	f
at_start	regexp.c	/^static int	at_start;   \/* True when we are on the first character *\/$/;"	v	file:
atom	vim.h	/^    Atom	atom;		    \/* Vim's own special selection format *\/$/;"	m	struct:VimClipboard
attr_entry	structs.h	/^struct attr_entry$/;"	s
au_cleanup	fileio.c	/^au_cleanup()$/;"	f	file:
au_find_group	fileio.c	/^au_find_group(name)$/;"	f	file:
au_get_grouparg	fileio.c	/^au_get_grouparg(argp)$/;"	f	file:
au_need_clean	fileio.c	/^static int au_need_clean = FALSE;   \/* need to delete marked patterns *\/$/;"	v	file:
au_new_group	fileio.c	/^au_new_group(name)$/;"	f	file:
au_remove_cmds	fileio.c	/^au_remove_cmds(ap)$/;"	f	file:
au_remove_pat	fileio.c	/^au_remove_pat(ap)$/;"	f	file:
augroups	fileio.c	/^struct growarray augroups = {0, 0, sizeof(char_u *), 10, NULL};$/;"	v	typeref:struct:growarray
auto_event	vim.h	/^enum auto_event$/;"	g
auto_next_pat	fileio.c	/^auto_next_pat(apc, stop_at_last)$/;"	f	file:
autocmd_busy	globals.h	/^EXTERN int	autocmd_busy INIT(= FALSE);	\/* Is apply_autocmds() busy? *\/$/;"	v
autocmd_fname	globals.h	/^EXTERN char_u	*autocmd_fname INIT(= NULL); \/* fname for <afile> on cmdline *\/$/;"	v
autocmd_nested	fileio.c	/^static int	autocmd_nested = FALSE;$/;"	v	file:
autocmd_no_enter	globals.h	/^EXTERN int	autocmd_no_enter INIT(= FALSE); \/* *Enter autocmds disabled *\/$/;"	v
autocmd_no_leave	globals.h	/^EXTERN int	autocmd_no_leave INIT(= FALSE); \/* *Leave autocmds disabled *\/$/;"	v
autowrite	ex_docmd.c	/^autowrite(buf, forceit)$/;"	f
autowrite_all	ex_docmd.c	/^autowrite_all()$/;"	f
available	vim.h	/^    int		available;	    \/* Is clipboard available? *\/$/;"	m	struct:VimClipboard
b0_fname	memline.c	/^    char_u	b0_fname[B0_FNAME_SIZE]; \/* name of file being edited *\/$/;"	m	struct:block0	file:
b0_hname	memline.c	/^    char_u	b0_hname[B0_HNAME_SIZE]; \/* host name (if it has a name) *\/$/;"	m	struct:block0	file:
b0_id	memline.c	/^    char_u	b0_id[2];	\/* id for block 0: BLOCK0_ID0 and BLOCK0_ID1 *\/$/;"	m	struct:block0	file:
b0_ino	memline.c	/^    char_u	b0_ino[4];	\/* inode of b0_fname *\/$/;"	m	struct:block0	file:
b0_magic_char	memline.c	/^    char_u	b0_magic_char;	\/* check for last char *\/$/;"	m	struct:block0	file:
b0_magic_int	memline.c	/^    int		b0_magic_int;	\/* check for byte order of int *\/$/;"	m	struct:block0	file:
b0_magic_long	memline.c	/^    long	b0_magic_long;	\/* check for byte order of long *\/$/;"	m	struct:block0	file:
b0_magic_short	memline.c	/^    short	b0_magic_short;	\/* check for byte order of short *\/$/;"	m	struct:block0	file:
b0_magic_wrong	memline.c	/^b0_magic_wrong(b0p)$/;"	f	file:
b0_mtime	memline.c	/^    char_u	b0_mtime[4];	\/* last modification time of file *\/$/;"	m	struct:block0	file:
b0_page_size	memline.c	/^    char_u	b0_page_size[4];\/* number of bytes per page *\/$/;"	m	struct:block0	file:
b0_pid	memline.c	/^    char_u	b0_pid[4];	\/* process id of creator (or 0) *\/$/;"	m	struct:block0	file:
b0_uname	memline.c	/^    char_u	b0_uname[B0_UNAME_SIZE]; \/* name of user (uid if no name) *\/$/;"	m	struct:block0	file:
b0_version	memline.c	/^    char_u	b0_version[10];	\/* Vim version string *\/$/;"	m	struct:block0	file:
b_block_head	structs.h	/^    struct m_block   b_block_head;	\/* head of allocated memory block list *\/$/;"	m	struct:buffer	typeref:struct:buffer::m_block
b_changed	structs.h	/^    int		     b_changed;		\/* 'modified': Set to TRUE if$/;"	m	struct:buffer
b_chartab	structs.h	/^    char	     b_chartab[256];$/;"	m	struct:buffer
b_did_warn	structs.h	/^    int		     b_did_warn;    \/* Set to 1 if user has been warned on$/;"	m	struct:buffer
b_ffname	structs.h	/^    char_u	    *b_ffname;		\/* full path file name *\/$/;"	m	struct:buffer
b_flags	structs.h	/^    int		     b_flags;		\/* various BF_ flags *\/$/;"	m	struct:buffer
b_fname	structs.h	/^    char_u	    *b_fname;		\/* current file name *\/$/;"	m	struct:buffer
b_fnum	structs.h	/^    int		     b_fnum;		\/* file number for this file. *\/$/;"	m	struct:buffer
b_help	structs.h	/^    int		     b_help;	    \/* buffer for help file *\/$/;"	m	struct:buffer
b_keywtab	structs.h	/^    struct keyentry	**b_keywtab;	      \/* syntax keywords hash table *\/$/;"	m	struct:buffer	typeref:struct:buffer::keyentry
b_keywtab_ic	structs.h	/^    struct keyentry	**b_keywtab_ic;	      \/* idem, ignore case *\/$/;"	m	struct:buffer	typeref:struct:buffer::keyentry
b_last_cursor	structs.h	/^    FPOS	     b_last_cursor;	\/* cursor position when last unloading$/;"	m	struct:buffer
b_m_search	structs.h	/^    info_t	    *b_m_search;	\/* pointer to chunk before previously$/;"	m	struct:buffer
b_marks_read	structs.h	/^    int		     b_marks_read;	\/* Have we read viminfo marks yet? *\/$/;"	m	struct:buffer
b_may_swap	structs.h	/^    int		     b_may_swap;$/;"	m	struct:buffer
b_mb_current	structs.h	/^    struct m_block  *b_mb_current;	\/* block where m_search points in *\/$/;"	m	struct:buffer	typeref:struct:buffer::m_block
b_ml	structs.h	/^    MEMLINE	     b_ml;		\/* associated memline (also contains$/;"	m	struct:buffer
b_mtime	structs.h	/^    long	     b_mtime;		\/* last change time of original file *\/$/;"	m	struct:buffer
b_mtime_read	structs.h	/^    long	     b_mtime_read;	\/* last change time when reading *\/$/;"	m	struct:buffer
b_namedm	structs.h	/^    FPOS	     b_namedm[NMARKS];	\/* current named marks (mark.c) *\/$/;"	m	struct:buffer
b_next	getchar.c	/^	struct bufblock *b_next;	\/* pointer to next bufblock *\/$/;"	m	struct:bufblock	typeref:struct:bufblock::bufblock	file:
b_next	structs.h	/^    BUF		    *b_next;		\/* links in list of buffers *\/$/;"	m	struct:buffer
b_notedited	structs.h	/^    int		     b_notedited;	\/* Set to TRUE when file name is$/;"	m	struct:buffer
b_nwindows	structs.h	/^    int		     b_nwindows;	\/* nr of windows open on this buffer *\/$/;"	m	struct:buffer
b_op_end	structs.h	/^    FPOS	     b_op_end;$/;"	m	struct:buffer
b_op_start	structs.h	/^    FPOS	     b_op_start;$/;"	m	struct:buffer
b_p_ai	structs.h	/^    int		     b_p_ai, b_p_ro, b_p_lisp;$/;"	m	struct:buffer
b_p_ai_save	structs.h	/^    int		     b_p_ai_save, b_p_lisp_save;$/;"	m	struct:buffer
b_p_bin	structs.h	/^    int		     b_p_bin, b_p_eol, b_p_et, b_p_ml, b_p_tx;$/;"	m	struct:buffer
b_p_cin	structs.h	/^    int		     b_p_cin;	    \/* use C progam indent mode *\/$/;"	m	struct:buffer
b_p_cin_save	structs.h	/^    int		     b_p_cin_save;  \/* b_p_cin saved for paste mode *\/$/;"	m	struct:buffer
b_p_cink	structs.h	/^    char_u	    *b_p_cink;	    \/* C progam indent mode keys *\/$/;"	m	struct:buffer
b_p_cino	structs.h	/^    char_u	    *b_p_cino;	    \/* C progam indent mode options *\/$/;"	m	struct:buffer
b_p_cinw	structs.h	/^    char_u	    *b_p_cinw;	    \/* words extra indent for 'si' and 'cin' *\/$/;"	m	struct:buffer
b_p_com	structs.h	/^    char_u	    *b_p_ff, *b_p_fo, *b_p_com, *b_p_isk;$/;"	m	struct:buffer
b_p_cpt	structs.h	/^    char_u	    *b_p_cpt;		\/* 'complete', types of expansions *\/$/;"	m	struct:buffer
b_p_eol	structs.h	/^    int		     b_p_bin, b_p_eol, b_p_et, b_p_ml, b_p_tx;$/;"	m	struct:buffer
b_p_et	structs.h	/^    int		     b_p_bin, b_p_eol, b_p_et, b_p_ml, b_p_tx;$/;"	m	struct:buffer
b_p_et_nobin	structs.h	/^    int		     b_p_ml_nobin, b_p_et_nobin;$/;"	m	struct:buffer
b_p_ff	structs.h	/^    char_u	    *b_p_ff, *b_p_fo, *b_p_com, *b_p_isk;$/;"	m	struct:buffer
b_p_fo	structs.h	/^    char_u	    *b_p_ff, *b_p_fo, *b_p_com, *b_p_isk;$/;"	m	struct:buffer
b_p_inf	structs.h	/^    int		     b_p_inf;		\/* infer case of ^N\/^P completions *\/$/;"	m	struct:buffer
b_p_initialized	structs.h	/^    int		     b_p_initialized;	\/* set when options initialized *\/$/;"	m	struct:buffer
b_p_isk	structs.h	/^    char_u	    *b_p_ff, *b_p_fo, *b_p_com, *b_p_isk;$/;"	m	struct:buffer
b_p_lisp	structs.h	/^    int		     b_p_ai, b_p_ro, b_p_lisp;$/;"	m	struct:buffer
b_p_lisp_save	structs.h	/^    int		     b_p_ai_save, b_p_lisp_save;$/;"	m	struct:buffer
b_p_ml	structs.h	/^    int		     b_p_bin, b_p_eol, b_p_et, b_p_ml, b_p_tx;$/;"	m	struct:buffer
b_p_ml_nobin	structs.h	/^    int		     b_p_ml_nobin, b_p_et_nobin;$/;"	m	struct:buffer
b_p_nf	structs.h	/^    char_u	    *b_p_nf;	    \/* Number formats *\/$/;"	m	struct:buffer
b_p_ro	structs.h	/^    int		     b_p_ai, b_p_ro, b_p_lisp;$/;"	m	struct:buffer
b_p_si	structs.h	/^    int		     b_p_si, b_p_si_save;$/;"	m	struct:buffer
b_p_si_save	structs.h	/^    int		     b_p_si, b_p_si_save;$/;"	m	struct:buffer
b_p_sn	structs.h	/^    int		     b_p_sn;$/;"	m	struct:buffer
b_p_sts	structs.h	/^    long	     b_p_sw, b_p_sts, b_p_ts, b_p_tw, b_p_wm;$/;"	m	struct:buffer
b_p_sts_save	structs.h	/^    long	     b_p_tw_save, b_p_wm_save, b_p_sts_save;$/;"	m	struct:buffer
b_p_sw	structs.h	/^    long	     b_p_sw, b_p_sts, b_p_ts, b_p_tw, b_p_wm;$/;"	m	struct:buffer
b_p_ts	structs.h	/^    long	     b_p_sw, b_p_sts, b_p_ts, b_p_tw, b_p_wm;$/;"	m	struct:buffer
b_p_tw	structs.h	/^    long	     b_p_sw, b_p_sts, b_p_ts, b_p_tw, b_p_wm;$/;"	m	struct:buffer
b_p_tw_nobin	structs.h	/^    long	     b_p_wm_nobin, b_p_tw_nobin;$/;"	m	struct:buffer
b_p_tw_save	structs.h	/^    long	     b_p_tw_save, b_p_wm_save, b_p_sts_save;$/;"	m	struct:buffer
b_p_tx	structs.h	/^    int		     b_p_bin, b_p_eol, b_p_et, b_p_ml, b_p_tx;$/;"	m	struct:buffer
b_p_wm	structs.h	/^    long	     b_p_sw, b_p_sts, b_p_ts, b_p_tw, b_p_wm;$/;"	m	struct:buffer
b_p_wm_nobin	structs.h	/^    long	     b_p_wm_nobin, b_p_tw_nobin;$/;"	m	struct:buffer
b_p_wm_save	structs.h	/^    long	     b_p_tw_save, b_p_wm_save, b_p_sts_save;$/;"	m	struct:buffer
b_prev	structs.h	/^    BUF		    *b_prev;$/;"	m	struct:buffer
b_scanned	structs.h	/^    int		     b_scanned;		\/* ^N\/^P have scanned this buffer *\/$/;"	m	struct:buffer
b_sfname	structs.h	/^    char_u	    *b_sfname;		\/* short file name *\/$/;"	m	struct:buffer
b_shortname	structs.h	/^    int		     b_shortname;   \/* this file has an 8.3 file name *\/$/;"	m	struct:buffer
b_sniff	structs.h	/^    int		     b_sniff;		\/* file was loaded through Sniff *\/$/;"	m	struct:buffer
b_start_ffc	structs.h	/^    int		     b_start_ffc;   \/* first char of 'ff' when edit started *\/$/;"	m	struct:buffer
b_str	getchar.c	/^	char_u		b_str[1];	\/* contents (actually longer) *\/$/;"	m	struct:bufblock	file:
b_syn_change_lnum	structs.h	/^    linenr_t		b_syn_change_lnum;$/;"	m	struct:buffer
b_syn_ic	structs.h	/^    int			b_syn_ic;	      \/* ignore case for :syn cmds *\/$/;"	m	struct:buffer
b_syn_linecont_ic	structs.h	/^    int			b_syn_linecont_ic;    \/* ignore-case flag for above *\/$/;"	m	struct:buffer
b_syn_linecont_pat	structs.h	/^    char_u		*b_syn_linecont_pat;  \/* line continuation pattern *\/$/;"	m	struct:buffer
b_syn_linecont_prog	structs.h	/^    vim_regexp		*b_syn_linecont_prog; \/* line continuation program *\/$/;"	m	struct:buffer
b_syn_patterns	structs.h	/^    struct growarray	b_syn_patterns;	      \/* table for syntax patterns *\/$/;"	m	struct:buffer	typeref:struct:buffer::growarray
b_syn_states	structs.h	/^    struct syn_state	*b_syn_states;$/;"	m	struct:buffer	typeref:struct:buffer::syn_state
b_syn_states_len	structs.h	/^    int			b_syn_states_len;$/;"	m	struct:buffer
b_syn_states_lnum	structs.h	/^    linenr_t		b_syn_states_lnum;$/;"	m	struct:buffer
b_syn_sync_flags	structs.h	/^    int			b_syn_sync_flags;     \/* flags about how to sync *\/$/;"	m	struct:buffer
b_syn_sync_id	structs.h	/^    short		b_syn_sync_id;	      \/* group to sync on *\/$/;"	m	struct:buffer
b_syn_sync_maxlines	structs.h	/^    long		b_syn_sync_maxlines;  \/* maximal sync lines offset *\/$/;"	m	struct:buffer
b_syn_sync_minlines	structs.h	/^    long		b_syn_sync_minlines;  \/* minimal sync lines offset *\/$/;"	m	struct:buffer
b_u_curhead	structs.h	/^    struct u_header *b_u_curhead;	\/* pointer to current header *\/$/;"	m	struct:buffer	typeref:struct:buffer::u_header
b_u_line_colnr	structs.h	/^    colnr_t	     b_u_line_colnr;	\/* optional column number *\/$/;"	m	struct:buffer
b_u_line_lnum	structs.h	/^    linenr_t	     b_u_line_lnum;	\/* line number of line in u_line *\/$/;"	m	struct:buffer
b_u_line_ptr	structs.h	/^    char_u	    *b_u_line_ptr;	\/* saved line for "U" command *\/$/;"	m	struct:buffer
b_u_newhead	structs.h	/^    struct u_header *b_u_newhead;	\/* pointer to newest header *\/$/;"	m	struct:buffer	typeref:struct:buffer::u_header
b_u_numhead	structs.h	/^    int		     b_u_numhead;	\/* current number of headers *\/$/;"	m	struct:buffer
b_u_oldhead	structs.h	/^    struct u_header *b_u_oldhead;	\/* pointer to oldest header *\/$/;"	m	struct:buffer	typeref:struct:buffer::u_header
b_u_synced	structs.h	/^    int		     b_u_synced;	\/* entry lists are synced *\/$/;"	m	struct:buffer
b_vars	structs.h	/^    struct growarray b_vars;	    \/* internal variables, local to buffer *\/$/;"	m	struct:buffer	typeref:struct:buffer::growarray
b_visual_end	structs.h	/^    FPOS	     b_visual_end;	\/* end position of last VIsual *\/$/;"	m	struct:buffer
b_visual_mode	structs.h	/^    int		     b_visual_mode;	\/* VIsual_mode of last VIsual *\/$/;"	m	struct:buffer
b_visual_start	structs.h	/^    FPOS	     b_visual_start;	\/* start pos of last VIsual *\/$/;"	m	struct:buffer
b_winlnum	structs.h	/^    WINLNUM	    *b_winlnum;		\/* list of last used lnum for$/;"	m	struct:buffer
back_gc	gui.h	/^    GC		back_gc;$/;"	m	struct:Gui
back_in_line	search.c	/^back_in_line()$/;"	f	file:
back_pixel	gui.h	/^    GuiColor	back_pixel;	    \/* Color of background *\/$/;"	m	struct:Gui
backslash_halve	ex_docmd.c	/^backslash_halve(p, has_wildcards)$/;"	f
backslash_trans	regexp.c	/^backslash_trans(c)$/;"	f	file:
bangredo	globals.h	/^EXTERN int	bangredo INIT(= FALSE);	    \/* set to TRUE whith ! command *\/$/;"	v
bck_word	search.c	/^bck_word(count, type, stop)$/;"	f
bckend_word	search.c	/^bckend_word(count, type, eol)$/;"	f
beep_count	globals.h	/^EXTERN int	beep_count INIT(= 0);	\/* nr of beeps since last char typed *\/$/;"	v
beep_flush	misc1.c	/^beep_flush()$/;"	f
beginline	edit.c	/^beginline(flags)$/;"	f
bg_color	structs.h	/^	    GuiColor	    bg_color;	\/* background color handle *\/$/;"	m	struct:attr_entry::__anon12::__anon15
bg_color	structs.h	/^	    char_u	    bg_color;	\/* background color number *\/$/;"	m	struct:attr_entry::__anon12::__anon14
bh_bnum	structs.h	/^    blocknr_t	bh_bnum;		\/* block number *\/$/;"	m	struct:block_hdr
bh_curr	getchar.c	/^	struct bufblock *bh_curr;	\/* bufblock for appending *\/$/;"	m	struct:buffheader	typeref:struct:buffheader::bufblock	file:
bh_data	structs.h	/^    char_u	*bh_data;	    \/* pointer to memory (for used block) *\/$/;"	m	struct:block_hdr
bh_first	getchar.c	/^	struct bufblock bh_first;	\/* first (dummy) block of list *\/$/;"	m	struct:buffheader	typeref:struct:buffheader::bufblock	file:
bh_flags	structs.h	/^    char	bh_flags;	    \/* BH_DIRTY or BH_LOCKED *\/$/;"	m	struct:block_hdr
bh_hash_next	structs.h	/^    BHDR	*bh_hash_next;	    \/* next block_hdr in hash list *\/$/;"	m	struct:block_hdr
bh_hash_prev	structs.h	/^    BHDR	*bh_hash_prev;	    \/* previous block_hdr in hash list *\/$/;"	m	struct:block_hdr
bh_index	getchar.c	/^	int		bh_index;	\/* index for reading *\/$/;"	m	struct:buffheader	file:
bh_next	structs.h	/^    BHDR	*bh_next;	    \/* next block_hdr in free or used list *\/$/;"	m	struct:block_hdr
bh_page_count	structs.h	/^    int		bh_page_count;	    \/* number of pages in this block *\/$/;"	m	struct:block_hdr
bh_prev	structs.h	/^    BHDR	*bh_prev;	    \/* previous block_hdr in used list *\/$/;"	m	struct:block_hdr
bh_space	getchar.c	/^	int		bh_space;	\/* space in bh_curr for appending *\/$/;"	m	struct:buffheader	file:
blank_pointer	gui.h	/^    Cursor	blank_pointer;	    \/* Blank pointer *\/$/;"	m	struct:Gui
block0	memline.c	/^struct block0$/;"	s	file:
block_def	ops.c	/^struct block_def$/;"	s	file:
block_hdr	structs.h	/^struct block_hdr$/;"	s
block_mode	structs.h	/^    int	    block_mode;		\/* current operator is Visual block mode *\/$/;"	m	struct:oparg
block_prep	ops.c	/^block_prep(oap, bd, lnum, is_del)$/;"	f	file:
block_redo	getchar.c	/^static int	block_redo = FALSE;$/;"	v	file:
blocknr_t	structs.h	/^typedef long		    blocknr_t;$/;"	t
bold_font	gui.h	/^    GuiFont	bold_font;$/;"	m	struct:Gui
boldital_font	gui.h	/^    GuiFont	boldital_font;$/;"	m	struct:Gui
border_offset	gui.h	/^    int		border_offset;	    \/* Total pixel offset for all borders *\/$/;"	m	struct:Gui
border_width	gui.h	/^    int		border_width;	    \/* Width of our border around text area *\/$/;"	m	struct:Gui
bot_shadow_GC	gui_at_sb.h	/^    GC		bot_shadow_GC;$/;"	m	struct:__anon16
bot_shadow_contrast	gui_at_sb.h	/^    int		bot_shadow_contrast;$/;"	m	struct:__anon16
bot_shadow_pixel	gui_at_sb.h	/^    Pixel	bot_shadow_pixel;$/;"	m	struct:__anon16
bot_top_msg	search.c	/^static char_u *bot_top_msg = (char_u *)"search hit BOTTOM, continuing at TOP";$/;"	v	file:
botline_approximated	screen.c	/^botline_approximated()$/;"	f
botline_valid	screen.c	/^botline_valid()$/;"	f
bottom_sbar	gui.h	/^    GuiScrollbar bottom_sbar;	    \/* Bottom scrollbar *\/$/;"	m	struct:Gui
bottommsg	tag.c	/^static char_u *bottommsg = (char_u *)"at bottom of tag stack";$/;"	v	file:
brace_count	regexp.c	/^static int	brace_count[10]; \/* Current counts for complex brace repeats *\/$/;"	v	file:
brace_max	regexp.c	/^static int	brace_max[10];	\/* Maximums for complex brace repeats *\/$/;"	v	file:
brace_min	regexp.c	/^static int	brace_min[10];	\/* Minimums for complex brace repeats *\/$/;"	v	file:
breakat_flags	globals.h	/^EXTERN char	breakat_flags[256];	\/* which characters are in 'breakat' *\/$/;"	v
bt_entry	term.c	/^    int		bt_entry;$/;"	m	struct:builtin_term	file:
bt_string	term.c	/^    char	*bt_string;$/;"	m	struct:builtin_term	file:
buf	if_python.c	/^    BUF *buf;$/;"	m	struct:__anon6	file:
buf	if_python.c	/^    BufferObject *buf;$/;"	m	struct:__anon7	file:
buf_changed	undo.c	/^buf_changed(buf)$/;"	f
buf_check_timestamp	fileio.c	/^buf_check_timestamp(buf)$/;"	f
buf_clear	buffer.c	/^buf_clear(buf)$/;"	f
buf_copy_options	option.c	/^buf_copy_options(bp_from, bp_to, flags)$/;"	f
buf_freeall	buffer.c	/^buf_freeall(buf)$/;"	f
buf_modname	fileio.c	/^buf_modname(shortname, fname, ext, prepend_dot)$/;"	f
buf_valid	buffer.c	/^buf_valid(buf)$/;"	f
buf_write	fileio.c	/^buf_write(buf, fname, sfname, start, end, append, forceit,$/;"	f
buf_write_all	ex_docmd.c	/^buf_write_all(buf)$/;"	f	file:
bufblock	getchar.c	/^struct bufblock$/;"	s	file:
bufempty	macros.h	37;"	d
buffer	if_python.c	/^static char_u *buffer = NULL;$/;"	v	file:
buffer	structs.h	/^struct buffer$/;"	s
buffer_ensure	if_python.c	/^buffer_ensure(int n)$/;"	f	file:
buffer_len	if_python.c	/^static int buffer_len = 0;$/;"	v	file:
buffer_size	if_python.c	/^static int buffer_size = 0;$/;"	v	file:
buffheader	getchar.c	/^struct buffheader$/;"	s	file:
buflist_add	buffer.c	/^buflist_add(fname)$/;"	f
buflist_altlnum	buffer.c	/^buflist_altlnum()$/;"	f
buflist_findlnum	buffer.c	/^buflist_findlnum(buf)$/;"	f
buflist_findname	buffer.c	/^buflist_findname(ffname)$/;"	f
buflist_findnr	buffer.c	/^buflist_findnr(nr)$/;"	f
buflist_findpat	buffer.c	/^buflist_findpat(pattern, pattern_end)$/;"	f
buflist_getfile	buffer.c	/^buflist_getfile(n, lnum, options, forceit)$/;"	f
buflist_getlnum	buffer.c	/^buflist_getlnum()$/;"	f
buflist_list	buffer.c	/^buflist_list()$/;"	f
buflist_match	buffer.c	/^buflist_match(prog, buf)$/;"	f	file:
buflist_match_try	buffer.c	/^buflist_match_try(prog, name)$/;"	f	file:
buflist_maxbufnr	buffer.c	/^buflist_maxbufnr()$/;"	f
buflist_name_nr	buffer.c	/^buflist_name_nr(fnum, fname, lnum)$/;"	f
buflist_new	buffer.c	/^buflist_new(ffname, sfname, lnum, use_curbuf)$/;"	f
buflist_nr2name	buffer.c	/^buflist_nr2name(n, fullname, helptail)$/;"	f
buflist_setlnum	buffer.c	/^buflist_setlnum(buf, lnum)$/;"	f	file:
builtin_term	term.c	/^struct builtin_term$/;"	s	file:
builtin_termcaps	term.c	/^struct builtin_term builtin_termcaps[] =$/;"	v	typeref:struct:builtin_term
button	misc2.c	/^    int	    button;		\/* Which mouse button is it? *\/$/;"	m	struct:mousetable	file:
call_shell	misc2.c	/^call_shell(cmd, opt)$/;"	f
canF_Ljoin	farsi.c	/^canF_Ljoin(c)$/;"	f	file:
canF_Rjoin	farsi.c	/^canF_Rjoin(c)$/;"	f	file:
can_abandon	ex_docmd.c	/^can_abandon(buf, forceit)$/;"	f
can_cindent	edit.c	/^static int	can_cindent;		\/* may do cindenting on this line *\/$/;"	v	file:
can_si	globals.h	/^EXTERN int	can_si INIT(= FALSE);$/;"	v
can_si_back	globals.h	/^EXTERN int	can_si_back INIT(= FALSE);$/;"	v
case_args	syntax.c	/^static char *(case_args[]) = {"match", "ignore", NULL};$/;"	v	file:
catch_signals	os_unix.c	/^catch_signals(func_deadly, func_other)$/;"	f	file:
cb	gui.h	/^    void	(*cb)();	    \/* Call-back routine *\/$/;"	m	struct:GuiMenu
ccheck_abbr	ex_getln.c	/^ccheck_abbr(c)$/;"	f	file:
ccline	ex_getln.c	/^static struct cmdline_info ccline;	\/* current cmdline_info *\/$/;"	v	typeref:struct:cmdline_info	file:
change_compatible	option.c	/^change_compatible(on)$/;"	f
change_indent	edit.c	/^change_indent(type, amount, round, replaced)$/;"	f	file:
change_warning	misc1.c	/^change_warning(col)$/;"	f
changed_cline_aft_curs	screen.c	/^changed_cline_aft_curs()$/;"	f
changed_cline_bef_curs	screen.c	/^changed_cline_bef_curs()$/;"	f
changed_line_abv_curs	screen.c	/^changed_line_abv_curs()$/;"	f
char_ascent	gui.h	/^    int		char_ascent;	    \/* Ascent of char in pixels *\/$/;"	m	struct:Gui
char_avail	getchar.c	/^char_avail()$/;"	f
char_class	ui.c	228;"	d	file:
char_height	gui.h	/^    int		char_height;	    \/* Height of char in pixels *\/$/;"	m	struct:Gui
char_to_long	memline.c	/^char_to_long(s)$/;"	f	file:
char_u	term.h	/^typedef unsigned char char_u;$/;"	t
char_u	vim.h	/^typedef unsigned char	char_u;$/;"	t
char_width	gui.h	/^    int		char_width;	    \/* Width of char in pixels *\/$/;"	m	struct:Gui
charsize	charset.c	/^charsize(c)$/;"	f
chartab	globals.h	/^EXTERN char_u	chartab[256];		\/* table used in charset.c *\/$/;"	v
chartab_initialized	charset.c	/^static int    chartab_initialized = FALSE;$/;"	v	file:
chartabsize	charset.c	/^chartabsize(c, col)$/;"	f
chdir	vim.h	103;"	d
check_abbr	getchar.c	/^check_abbr(c, ptr, col, mincol)$/;"	f
check_arg_idx	ex_docmd.c	/^check_arg_idx()$/;"	f
check_buf_options	option.c	/^check_buf_options(buf)$/;"	f
check_changed	ex_docmd.c	/^check_changed(buf, checkaw, mult_win, forceit)$/;"	f	file:
check_changed_any	ex_docmd.c	/^check_changed_any()$/;"	f
check_cursor_lnum	misc2.c	/^check_cursor_lnum()$/;"	f
check_cursor_moved	screen.c	/^check_cursor_moved(wp)$/;"	f	file:
check_ei	fileio.c	/^check_ei()$/;"	f
check_fname	ex_docmd.c	/^check_fname()$/;"	f
check_for_delay	screen.c	/^check_for_delay(check_msg_scroll)$/;"	f
check_keepend	syntax.c	/^check_keepend()$/;"	f	file:
check_keyword_id	syntax.c	/^check_keyword_id(line, startcol, endcol, flags, next_list, cur_si)$/;"	f	file:
check_linecomment	search.c	/^check_linecomment(line)$/;"	f	file:
check_lnums	window.c	/^check_lnums(do_curwin)$/;"	f
check_map_keycodes	getchar.c	/^check_map_keycodes()$/;"	f
check_mark	mark.c	/^check_mark(pos)$/;"	f
check_marks_read	fileio.c	/^check_marks_read()$/;"	f	file:
check_more	ex_docmd.c	/^check_more(message, forceit)$/;"	f	file:
check_mtime	fileio.c	/^check_mtime(buf, st)$/;"	f	file:
check_need_swap	memline.c	/^check_need_swap(newfile)$/;"	f
check_nextcmd	ex_docmd.c	/^check_nextcmd(p)$/;"	f
check_opt_strings	option.c	/^check_opt_strings(val, values, list)$/;"	f	file:
check_options	option.c	/^check_options()$/;"	f
check_readonly	ex_docmd.c	/^check_readonly(forceit)$/;"	f	file:
check_redraw	option.c	/^check_redraw(flags)$/;"	f	file:
check_restricted	ex_cmds.c	/^check_restricted()$/;"	f
check_secure	ex_cmds.c	/^check_secure()$/;"	f
check_shifted_spec_key	misc2.c	/^check_shifted_spec_key(c)$/;"	f
check_state_ends	syntax.c	/^check_state_ends(line)$/;"	f	file:
check_status	misc1.c	/^check_status(buf)$/;"	f
check_termcode	term.c	/^check_termcode(max_offset)$/;"	f
check_timestamps	fileio.c	/^check_timestamps()$/;"	f
check_visual_highlight	normal.c	/^check_visual_highlight()$/;"	f
check_winsize	term.c	/^check_winsize()$/;"	f
checkclearop	normal.c	/^checkclearop(oap)$/;"	f	file:
checkclearopq	normal.c	/^checkclearopq(oap)$/;"	f	file:
checkpcmark	mark.c	/^checkpcmark()$/;"	f
chg_c_toX_orX	farsi.c	/^chg_c_toX_orX()$/;"	f	file:
chg_c_to_X_orX_	farsi.c	/^chg_c_to_X_orX_()$/;"	f	file:
chg_c_to_X_or_X	farsi.c	/^chg_c_to_X_or_X ()$/;"	f	file:
chg_l_toXor_X	farsi.c	/^chg_l_toXor_X ()$/;"	f	file:
chg_l_to_X_orX_	farsi.c	/^chg_l_to_X_orX_ ()$/;"	f	file:
chg_r_to_Xor_X_	farsi.c	/^chg_r_to_Xor_X_()$/;"	f	file:
children	gui.h	/^    struct GuiMenu *children;	    \/* Children of sub-menu *\/$/;"	m	struct:GuiMenu	typeref:struct:GuiMenu::GuiMenu
chk_modeline	buffer.c	/^chk_modeline(lnum)$/;"	f	file:
cin_is_cinword	misc1.c	/^cin_is_cinword(line)$/;"	f	file:
cin_iscase	misc1.c	/^cin_iscase(s)$/;"	f
cin_iscomment	misc1.c	/^cin_iscomment(p)$/;"	f	file:
cin_isdefault	misc1.c	/^cin_isdefault(s)$/;"	f	file:
cin_isdo	misc1.c	/^cin_isdo(p)$/;"	f	file:
cin_iselse	misc1.c	/^cin_iselse(p)$/;"	f	file:
cin_isfuncdecl	misc1.c	/^cin_isfuncdecl(s)$/;"	f	file:
cin_isif	misc1.c	/^cin_isif(p)$/;"	f	file:
cin_islabel	misc1.c	/^cin_islabel(ind_maxcomment)		\/* XXX *\/$/;"	f
cin_ispreproc	misc1.c	/^cin_ispreproc(s)$/;"	f	file:
cin_isscopedecl	misc1.c	/^cin_isscopedecl(s)$/;"	f
cin_isterminated	misc1.c	/^cin_isterminated(s, incl_open)$/;"	f	file:
cin_iswhileofdo	misc1.c	/^cin_iswhileofdo(p, lnum, ind_maxparen)	    \/* XXX *\/$/;"	f	file:
cleanup_jumplist	mark.c	/^cleanup_jumplist()$/;"	f	file:
clear_cmdline	globals.h	/^EXTERN int	clear_cmdline INIT(= FALSE);	\/* cmdline must be cleared *\/$/;"	v
clear_insexp	edit.c	/^clear_insexp()$/;"	f	file:
clear_oparg	ops.c	/^clear_oparg(oap)$/;"	f
clear_showcmd	normal.c	/^clear_showcmd()$/;"	f
clear_subexpr	regexp.c	/^clear_subexpr()$/;"	f	file:
clear_termcodes	term.c	/^clear_termcodes()$/;"	f
clear_termoptions	option.c	/^clear_termoptions()$/;"	f
clear_var	eval.c	/^clear_var(varp)$/;"	f	file:
clearop	normal.c	/^clearop(oap)$/;"	f	file:
clearopbeep	normal.c	/^clearopbeep(oap)$/;"	f	file:
clip_auto_select	ui.c	/^clip_auto_select()$/;"	f
clip_clear_selection	ui.c	/^clip_clear_selection()$/;"	f
clip_compare_pos	ui.c	/^clip_compare_pos(row1, col1, row2, col2)$/;"	f	file:
clip_convert_selection	ops.c	/^clip_convert_selection(str, len)$/;"	f
clip_copy_selection	ui.c	/^clip_copy_selection()$/;"	f
clip_free_selection	ops.c	/^clip_free_selection()$/;"	f
clip_get_line_end	ui.c	/^clip_get_line_end(row)$/;"	f	file:
clip_get_selection	ops.c	/^clip_get_selection()$/;"	f
clip_get_word_boundaries	ui.c	/^clip_get_word_boundaries(cb, row, col)$/;"	f	file:
clip_init	ui.c	/^clip_init(can_use)$/;"	f
clip_invert_area	ui.c	/^clip_invert_area(row1, col1, row2, col2)$/;"	f	file:
clip_lose_selection	ui.c	/^clip_lose_selection()$/;"	f
clip_own_selection	ui.c	/^clip_own_selection()$/;"	f
clip_process_selection	ui.c	/^clip_process_selection(button, x, y, repeated_click, modifiers)$/;"	f
clip_redraw_selection	ui.c	/^clip_redraw_selection(x, y, w, h)$/;"	f
clip_scroll_selection	ui.c	/^clip_scroll_selection(rows)$/;"	f
clip_start_selection	ui.c	/^clip_start_selection(button, x, y, repeated_click, modifiers)$/;"	f
clip_update_non_visual_selection	ui.c	/^clip_update_non_visual_selection(cb, row1, col1, row2, col2)$/;"	f	file:
clip_update_selection	ui.c	/^clip_update_selection()$/;"	f
clip_yank_non_visual_selection	ui.c	/^clip_yank_non_visual_selection(row1, col1, row2, col2)$/;"	f	file:
clip_yank_selection	ops.c	/^clip_yank_selection(type, str, len)$/;"	f
clipboard	globals.h	/^EXTERN VimClipboard clipboard;$/;"	v
close_buffer	buffer.c	/^close_buffer(win, buf, free_buf, del_buf)$/;"	f
close_others	window.c	/^close_others(message, forceit)$/;"	f
close_redir	ex_docmd.c	/^close_redir()$/;"	f	file:
close_window	window.c	/^close_window(win, free_buf)$/;"	f
close_windows	window.c	/^close_windows(buf)$/;"	f
closescript	getchar.c	/^closescript()$/;"	f	file:
clrallmarks	mark.c	/^clrallmarks(buf)$/;"	f
cls	search.c	/^cls()$/;"	f	file:
cmd	ex_cmds.h	/^    char_u	*cmd;	    \/* the name of the command (except for :make) *\/$/;"	m	struct:exarg
cmd	fileio.c	/^    char_u	    *cmd;		\/* The command to be executed (NULL$/;"	m	struct:AutoCmd	file:
cmd_argt	ex_cmds.h	/^    long_u   cmd_argt;	\/* command line arguments permitted\/needed\/used *\/$/;"	m	struct:cmdname
cmd_fkmap	ex_getln.c	/^static int	    cmd_fkmap = 0;	\/* Farsi mapping during command line *\/$/;"	v	file:
cmd_gchar	ex_getln.c	/^cmd_gchar(offset)$/;"	f
cmd_hkmap	ex_getln.c	/^static int	cmd_hkmap = 0;	    \/* Hebrew mapping during command line *\/$/;"	v	file:
cmd_name	ex_cmds.h	/^    char_u  *cmd_name;	\/* name of the command *\/$/;"	m	struct:cmdname
cmd_numfiles	ex_getln.c	/^static int	cmd_numfiles = -1;	\/* number of files found by$/;"	v	file:
cmd_pchar	ex_getln.c	/^cmd_pchar(c, offset)$/;"	f
cmdarg	structs.h	/^typedef struct cmdarg$/;"	s
cmdbuff	ex_getln.c	/^    char_u  *cmdbuff;	    \/* pointer to command line buffer *\/$/;"	m	struct:cmdline_info	file:
cmdbufflen	ex_getln.c	/^    int	     cmdbufflen;    \/* length of cmdbuff *\/$/;"	m	struct:cmdline_info	file:
cmdchar	structs.h	/^    int	    cmdchar;	    \/* command character *\/$/;"	m	struct:cmdarg
cmdfirstc	ex_getln.c	/^    int	     cmdfirstc;	    \/* ':', '\/', '?', '=' or NUL *\/$/;"	m	struct:cmdline_info	file:
cmdidx	ex_cmds.h	/^    CMDIDX	cmdidx;	    \/* the index for the command *\/$/;"	m	struct:exarg
cmdidxs	ex_docmd.c	/^CMDIDX cmdidxs[27] =$/;"	v
cmdindent	ex_getln.c	/^    int	     cmdindent;	    \/* number of spaces before cmdline *\/$/;"	m	struct:cmdline_info	file:
cmdl_fkmap	farsi.c	/^cmdl_fkmap(c)$/;"	f
cmdlen	ex_getln.c	/^    int	     cmdlen;	    \/* number of chars on command line *\/$/;"	m	struct:cmdline_info	file:
cmdline_at_end	ex_getln.c	/^cmdline_at_end()$/;"	f
cmdline_info	ex_getln.c	/^struct cmdline_info$/;"	s	file:
cmdline_overstrike	ex_getln.c	/^cmdline_overstrike()$/;"	f
cmdline_paste	ops.c	/^cmdline_paste(regname)$/;"	f
cmdline_row	globals.h	/^EXTERN int	cmdline_row;$/;"	v
cmdname	ex_cmds.h	/^static struct cmdname$/;"	s
cmdnames	ex_cmds.h	/^} cmdnames[] =$/;"	v	typeref:struct:cmdname
cmdpos	ex_getln.c	/^    int	     cmdpos;	    \/* current cursor position *\/$/;"	m	struct:cmdline_info	file:
cmds	fileio.c	/^    AutoCmd	    *cmds;		\/* list of commands to do *\/$/;"	m	struct:AutoPat	file:
cmdspos	ex_getln.c	/^    int	     cmdspos;	    \/* cursor column on screen *\/$/;"	m	struct:cmdline_info	file:
code	term.c	/^    char_u  *code;	    \/* terminal code (in allocated memory) *\/$/;"	m	struct:termcode	file:
col	gui.h	/^    int		col;		    \/* Current cursor column in GUI display *\/$/;"	m	struct:Gui
col	structs.h	/^    colnr_t	    col;	    \/* column number *\/$/;"	m	struct:fpos
col_print	buffer.c	/^col_print(buf, col, vcol)$/;"	f
coladvance	misc2.c	/^coladvance(wcol)$/;"	f
colnr_t	structs.h	/^typedef unsigned	colnr_t;$/;"	t
colnr_t	vim.h	/^typedef unsigned    colnr_t;	    \/* column number type *\/$/;"	t
color_name2handle	syntax.c	/^color_name2handle(name)$/;"	f	file:
command	tag.c	/^    char_u	*command;	\/* first char of command *\/$/;"	m	struct:tag_pointers	file:
command_end	tag.c	/^    char_u	*command_end;	\/* first char of command *\/$/;"	m	struct:tag_pointers	file:
command_height	window.c	/^command_height(old_p_ch)$/;"	f
commentorempty	misc1.c	/^commentorempty(s)$/;"	f	file:
comp_botline	screen.c	/^comp_botline()$/;"	f	file:
comp_col	option.c	/^comp_col()$/;"	f
compatible_set	option.c	/^compatible_set()$/;"	f	file:
complete_dictionaries	edit.c	/^complete_dictionaries(dict, pat, dir, flags)$/;"	f	file:
complete_pat	edit.c	/^static char_u		    *complete_pat;$/;"	v	file:
completion_length	globals.h	/^EXTERN int		completion_length INIT(= 0);$/;"	v
compute_cmdrow	ex_getln.c	/^compute_cmdrow()$/;"	f
concat_fnames	misc1.c	/^concat_fnames(fname1, fname2, sep)$/;"	f
condstack	ex_docmd.c	/^struct condstack$/;"	s	file:
continue_mode	edit.c	/^static int		    continue_mode = 0;$/;"	v	file:
continue_status	globals.h	/^EXTERN int		continue_status   INIT(= 0);$/;"	v
conv_to_pstd	farsi.c	/^conv_to_pstd()$/;"	f
conv_to_pvim	farsi.c	/^conv_to_pvim()$/;"	f
copy_id_list	syntax.c	/^copy_id_list(list)$/;"	f	file:
copy_option_part	misc2.c	/^copy_option_part(option, buf, maxlen, sep_chars)$/;"	f
copy_redo	getchar.c	/^copy_redo(old_redo)$/;"	f	file:
copy_spaces	misc2.c	/^copy_spaces(ptr, count)$/;"	f
copy_state_to_current	syntax.c	/^copy_state_to_current(from)$/;"	f	file:
copy_viminfo_marks	mark.c	/^copy_viminfo_marks(line, fp_in, fp_out, count, eof)$/;"	f
core	gui_at_sb.h	/^    CorePart		core;$/;"	m	struct:_ScrollbarRec
core_class	gui_at_sb.h	/^    CoreClassPart		core_class;$/;"	m	struct:_ScrollbarClassRec
count0	structs.h	/^    long    count0;	    \/* count, default 0 *\/$/;"	m	struct:cmdarg
count1	structs.h	/^    long    count1;	    \/* count, default 1 *\/$/;"	m	struct:cmdarg
cs_flags	ex_docmd.c	/^    char    cs_flags[CSTACK_LEN];   \/* CSF_ flags *\/$/;"	m	struct:condstack	file:
cs_had_continue	ex_docmd.c	/^    char    cs_had_continue;	    \/* just found ":continue" *\/$/;"	m	struct:condstack	file:
cs_had_endwhile	ex_docmd.c	/^    char    cs_had_endwhile;	    \/* just found ":endwhile" *\/$/;"	m	struct:condstack	file:
cs_had_while	ex_docmd.c	/^    char    cs_had_while;	    \/* just found ":while" *\/$/;"	m	struct:condstack	file:
cs_idx	ex_docmd.c	/^    int	    cs_idx;		    \/* current entry, or -1 if none *\/$/;"	m	struct:condstack	file:
cs_line	ex_docmd.c	/^    int	    cs_line[CSTACK_LEN];    \/* line number of ":while" line *\/$/;"	m	struct:condstack	file:
cs_whilelevel	ex_docmd.c	/^    int	    cs_whilelevel;	    \/* number of nested ":while"s *\/$/;"	m	struct:condstack	file:
cstrchr	regexp.c	/^cstrchr(s, c)$/;"	f	file:
cstrncmp	regexp.c	/^cstrncmp(s1, s2, n)$/;"	f	file:
cterm	structs.h	/^	} cterm;$/;"	m	union:attr_entry::__anon12	typeref:struct:attr_entry::__anon12::__anon14
cterm_attr_table	syntax.c	/^struct growarray    cterm_attr_table = {0, 0, 0, 0, NULL};$/;"	v	typeref:struct:growarray
cterm_normal_bg_color	globals.h	/^EXTERN int	cterm_normal_bg_color INIT(= 0);$/;"	v
cterm_normal_fg_bold	globals.h	/^EXTERN int	cterm_normal_fg_bold INIT(= 0);$/;"	v
cterm_normal_fg_color	globals.h	/^EXTERN int	cterm_normal_fg_color INIT(= 0);$/;"	v
ctrl_x_mode	globals.h	/^EXTERN int	ctrl_x_mode INIT(= 0);	\/* Which Ctrl-X mode are we in? *\/$/;"	v
ctrl_x_msgs	edit.c	/^char *ctrl_x_msgs[] =$/;"	v
cur_match	structs.h	/^    int		    cur_match;		\/* match number *\/$/;"	m	struct:taggy
curbuf	globals.h	/^EXTERN BUF	*curbuf INIT(= NULL);	\/* currently active buffer *\/$/;"	v
curbuf_changed	undo.c	/^curbuf_changed()$/;"	f
curchr	regexp.c	/^static int	curchr;$/;"	v	file:
curpat	fileio.c	/^    AutoPat	*curpat;	\/* next AutoPat to examine *\/$/;"	m	struct:AutoPatCmd	file:
currBgColor	gui.h	/^    GuiColor	currBgColor;	    \/* Current background text color *\/$/;"	m	struct:Gui
currFgColor	gui.h	/^    GuiColor	currFgColor;	    \/* Current foreground text color *\/$/;"	m	struct:Gui
currFont	gui.h	/^    GuiFont	currFont;	    \/* Current font *\/$/;"	m	struct:Gui
curr_match	edit.c	/^static struct Completion    *curr_match = NULL;$/;"	v	typeref:struct:Completion	file:
curr_tmode	os_unix.c	/^static int curr_tmode = TMODE_COOK;	\/* contains current terminal mode *\/$/;"	v	file:
current_LinePointer	screen.c	/^static char_u *current_LinePointer;$/;"	v	file:
current_attr	syntax.c	/^static int current_attr = 0;	    \/* attr of current syntax word *\/$/;"	v	file:
current_augroup	fileio.c	/^static int current_augroup = AUGROUP_DEFAULT;$/;"	v	file:
current_block	search.c	/^current_block(oap, count, include, what)$/;"	f
current_col	syntax.c	/^static colnr_t	current_col = 0;	\/* column of current state *\/$/;"	v	file:
current_finished	syntax.c	/^static int	current_finished = 0;	\/* current line has been finished *\/$/;"	v	file:
current_id	syntax.c	/^static int current_id = 0;	    \/* ID of current char for syn_get_id() *\/$/;"	v	file:
current_line_id	syntax.c	/^static int	current_line_id = 0;	\/* unique number for current line *\/$/;"	v	file:
current_lnum	syntax.c	/^static linenr_t current_lnum = 0;	\/* lnum of current state *\/$/;"	v	file:
current_menu	globals.h	/^EXTERN GuiMenu	*current_menu;$/;"	v
current_next_flags	syntax.c	/^static int	current_next_flags = 0; \/* flags for current_next_list *\/$/;"	v	file:
current_next_list	syntax.c	/^static short	*current_next_list = NULL; \/* when non-zero, nextgroup list *\/$/;"	v	file:
current_par	search.c	/^current_par(oap, count, include, type)$/;"	f
current_scrollbar	globals.h	/^EXTERN int	current_scrollbar;$/;"	v
current_sent	search.c	/^current_sent(oap, count, include)$/;"	f
current_state	syntax.c	/^static struct growarray current_state	\/* current stack of state_items *\/$/;"	v	typeref:struct:growarray	file:
current_state_stored	syntax.c	/^static int	current_state_stored = 0; \/* TRUE if stored current state$/;"	v	file:
current_trans_id	syntax.c	/^static int current_trans_id = 0;    \/* idem, transparancy removed *\/$/;"	v	file:
current_word	search.c	/^current_word(oap, count, include, type)$/;"	f
curs_columns	screen.c	/^curs_columns(scroll)$/;"	f
curs_rows	screen.c	/^curs_rows(do_botline)$/;"	f	file:
curscript	globals.h	/^EXTERN int	curscript INIT(= 0);	    \/* index in scriptin[] *\/$/;"	v
cursor_col	gui.h	/^    int		cursor_col;	    \/* Physical cursor column in GUI display *\/$/;"	m	struct:Gui
cursor_correct	screen.c	/^cursor_correct()$/;"	f
cursor_down	edit.c	/^cursor_down(n, upd_topline)$/;"	f
cursor_is_off	term.c	/^static int cursor_is_off = FALSE;$/;"	v	file:
cursor_is_valid	gui.h	/^    char	cursor_is_valid;    \/* There is a cursor at cursor_row\/col *\/$/;"	m	struct:Gui
cursor_off	term.c	/^cursor_off()$/;"	f
cursor_on	term.c	/^cursor_on()$/;"	f
cursor_pos_info	buffer.c	/^cursor_pos_info()$/;"	f
cursor_row	gui.h	/^    int		cursor_row;	    \/* Physical cursor row in GUI display *\/$/;"	m	struct:Gui
cursor_up	edit.c	/^cursor_up(n, upd_topline)$/;"	f
cursor_valid	screen.c	/^cursor_valid()$/;"	f
cursorcmd	ex_getln.c	/^cursorcmd()$/;"	f	file:
curwin	globals.h	/^EXTERN WIN	*curwin;	\/* currently active window *\/$/;"	v
data_block	memline.c	/^struct data_block$/;"	s	file:
db_free	memline.c	/^    unsigned	db_free;	\/* free space available *\/$/;"	m	struct:data_block	file:
db_id	memline.c	/^    short_u	db_id;		\/* ID for data block: DATA_ID *\/$/;"	m	struct:data_block	file:
db_index	memline.c	/^    unsigned	db_index[1];	\/* index for start of line (actually bigger)$/;"	m	struct:data_block	file:
db_line_count	memline.c	/^    linenr_t	db_line_count;	\/* number of lines in this block *\/$/;"	m	struct:data_block	file:
db_txt_end	memline.c	/^    unsigned	db_txt_end;	\/* byte just after data block *\/$/;"	m	struct:data_block	file:
db_txt_start	memline.c	/^    unsigned	db_txt_start;	\/* byte where text starts *\/$/;"	m	struct:data_block	file:
deadly	os_unix.c	/^    char    deadly;	\/* Catch as a deadly signal? *\/$/;"	m	struct:signalinfo	file:
deadly_signal	os_unix.c	/^static int	deadly_signal = 0;	    \/* The signal we caught *\/$/;"	v	file:
debugfp	globals.h	/^EXTERN FILE *debugfp INIT(= NULL);$/;"	v
dec	misc2.c	/^dec(lp)$/;"	f
dec_cursor	misc2.c	/^dec_cursor()$/;"	f
decl	misc2.c	/^decl(lp)$/;"	f
def_back_pixel	gui.h	/^    GuiColor	def_back_pixel;	    \/* default Color of background *\/$/;"	m	struct:Gui
def_norm_pixel	gui.h	/^    GuiColor	def_norm_pixel;	    \/* default Color of normal text *\/$/;"	m	struct:Gui
def_val	option.c	/^    char_u	*def_val[2];	\/* default values for variable (vi and vim) *\/$/;"	m	struct:vimoption	file:
default_fileformat	misc2.c	/^default_fileformat()$/;"	f
default_vim_dir	pathdef.c	/^char_u *default_vim_dir = (char_u *)"\/usr\/local\/share\/vim";$/;"	v
del_char	misc1.c	/^del_char(fixpos)$/;"	f
del_chars	misc1.c	/^del_chars(count, fixpos)$/;"	f
del_from_showcmd	normal.c	/^del_from_showcmd(len)$/;"	f	file:
del_lines	misc1.c	/^del_lines(nlines, dowindow, undo)$/;"	f
del_termcode	term.c	/^del_termcode(name)$/;"	f
del_trailing_spaces	misc2.c	/^del_trailing_spaces(ptr)$/;"	f
del_typebuf	getchar.c	/^del_typebuf(len, offset)$/;"	f
dflt_bold_fn	gui.h	/^    char_u	*dflt_bold_fn;	    \/* Resource bold font *\/$/;"	m	struct:Gui
dflt_boldital_fn	gui.h	/^    char_u	*dflt_boldital_fn;  \/* Resource bold-italic font *\/$/;"	m	struct:Gui
dflt_font	gui.h	/^    char_u	*dflt_font;	    \/* Resource font, used if 'font' not set *\/$/;"	m	struct:Gui
dflt_ital_fn	gui.h	/^    char_u	*dflt_ital_fn;	    \/* Resource italic font *\/$/;"	m	struct:Gui
did_ai	globals.h	/^EXTERN int     did_ai INIT(= FALSE);$/;"	v
did_emsg	globals.h	/^EXTERN int	did_emsg;		    \/* set by emsg() for DoOneCmd() *\/$/;"	v
did_match_already	syntax.c	/^did_match_already(idx)$/;"	f	file:
did_outofmem_msg	globals.h	/^EXTERN int	did_outofmem_msg INIT(= FALSE);$/;"	v
did_set_icon	os_unix.c	/^static int	did_set_icon = FALSE;$/;"	v	file:
did_set_string_option	option.c	/^did_set_string_option(opt_idx, varp, new_value_alloced, oldval, errbuf)$/;"	f	file:
did_set_title	option.c	/^did_set_title(icon)$/;"	f	file:
did_set_title	os_unix.c	/^static int	did_set_title = FALSE;$/;"	v	file:
did_si	globals.h	/^EXTERN int	did_si INIT(= FALSE);$/;"	v
did_swapwrite_msg	globals.h	/^EXTERN int	did_swapwrite_msg INIT(= FALSE);$/;"	v
digraphcount	digraph.c	/^static int	digraphcount = 0;	    \/* number of added digraphs *\/$/;"	v	file:
digraphdefault	digraph.c	/^char_u	digraphdefault[][3] =	    \/* different HPUX digraphs *\/$/;"	v
digraphdefault	digraph.c	/^char_u	digraphdefault[][3] =	    \/* standard ATARI digraphs *\/$/;"	v
digraphdefault	digraph.c	/^char_u	digraphdefault[][3] =	    \/* standard ISO digraphs *\/$/;"	v
digraphdefault	digraph.c	/^char_u	digraphdefault[][3] =	    \/* standard MSDOS digraphs *\/$/;"	v
digraphnew	digraph.c	/^static char_u	(*digraphnew)[3];	    \/* pointer to added digraphs *\/$/;"	v	file:
dir	search.c	/^    int		dir;		\/* search direction *\/$/;"	m	struct:soffset	file:
dirent	os_unix.h	107;"	d
dis_msg	ops.c	/^dis_msg(p, skip_esc)$/;"	f
display_dollar	edit.c	/^display_dollar(col)$/;"	f
display_hint	globals.h	/^EXTERN int	display_hint INIT(= HINT_NONE);$/;"	v
display_showcmd	normal.c	/^display_showcmd()$/;"	f	file:
do_Lower	regexp.c	/^do_Lower(d, c)$/;"	f	file:
do_Upper	regexp.c	/^do_Upper(d, c)$/;"	f	file:
do_addsub	ops.c	/^do_addsub(command, Prenum1)$/;"	f
do_align	ex_cmds.c	/^do_align(eap)$/;"	f
do_append	ex_cmds.c	/^do_append(lnum, getline, cookie)$/;"	f
do_arg_all	buffer.c	/^do_arg_all(count, forceit)$/;"	f
do_argfile	ex_docmd.c	/^do_argfile(eap, argn)$/;"	f	file:
do_arglist	ex_docmd.c	/^do_arglist(str)$/;"	f	file:
do_args	ex_docmd.c	/^do_args(eap)$/;"	f	file:
do_ascii	ex_cmds.c	/^do_ascii()$/;"	f
do_at	normal.c	/^do_at(cap)$/;"	f	file:
do_augroup	fileio.c	/^do_augroup(arg)$/;"	f
do_autoall	fileio.c	/^do_autoall(arg)$/;"	f
do_autocmd	fileio.c	/^do_autocmd(arg, forceit)$/;"	f
do_autocmd_event	fileio.c	/^do_autocmd_event(event, pat, nested, cmd, forceit, group)$/;"	f	file:
do_bang	ex_cmds.c	/^do_bang(addr_count, line1, line2, forceit, arg, do_in, do_out)$/;"	f
do_bck_word	normal.c	/^do_bck_word(cap, type)$/;"	f	file:
do_brackets	normal.c	/^do_brackets(cap, dir)$/;"	f	file:
do_break	ex_docmd.c	/^do_break(cstack)$/;"	f	file:
do_bufdel	buffer.c	/^do_bufdel(command, arg, addr_count, start_bnr, end_bnr, forceit)$/;"	f
do_buffer	buffer.c	/^do_buffer(action, start, dir, count, forceit)$/;"	f
do_buffer_all	buffer.c	/^do_buffer_all(count, all)$/;"	f
do_cd	ex_docmd.c	/^do_cd(eap)$/;"	f	file:
do_cfile	ex_docmd.c	/^do_cfile(eap)$/;"	f	file:
do_change	ex_cmds.c	/^do_change(start, end, getline, cookie)$/;"	f
do_close	ex_docmd.c	/^do_close(eap)$/;"	f	file:
do_cmdline	ex_docmd.c	/^do_cmdline(cmdline, getline, cookie, flags)$/;"	f
do_colon	normal.c	/^do_colon(cap)$/;"	f	file:
do_continue	ex_docmd.c	/^do_continue(cstack)$/;"	f	file:
do_copy	ex_cmds.c	/^do_copy(line1, line2, n)$/;"	f
do_copymove	ex_docmd.c	/^do_copymove(eap)$/;"	f	file:
do_csearch	normal.c	/^do_csearch(cap, dir, type)$/;"	f	file:
do_cursormark	normal.c	/^do_cursormark(cap, flag, pos)$/;"	f	file:
do_digraph	digraph.c	/^do_digraph(c)$/;"	f
do_dis	ops.c	/^do_dis(arg)$/;"	f
do_do_join	ops.c	/^do_do_join(count, insert_space, redraw)$/;"	f
do_doautocmd	fileio.c	/^do_doautocmd(arg, do_msg)$/;"	f
do_echo	eval.c	/^do_echo(eap, echo)$/;"	f
do_ecmd	ex_docmd.c	/^do_ecmd(fnum, ffname, sfname, command, newlnum, flags)$/;"	f
do_ecmd_cmd	ex_cmds.h	/^    char_u	*do_ecmd_cmd; \/* +command argument to be used in edited file *\/$/;"	m	struct:exarg
do_ecmd_lnum	ex_cmds.h	/^    linenr_t	do_ecmd_lnum; \/* the line number in an edited file *\/$/;"	m	struct:exarg
do_else	ex_docmd.c	/^do_else(eap, cstack)$/;"	f	file:
do_endwhile	ex_docmd.c	/^do_endwhile(cstack)$/;"	f	file:
do_esc	normal.c	/^do_esc(cap, opnum)$/;"	f	file:
do_ex_tag	ex_docmd.c	/^do_ex_tag(eap, dt)$/;"	f	file:
do_exat	ex_docmd.c	/^do_exat(eap)$/;"	f	file:
do_execreg	ops.c	/^do_execreg(regname, colon, addcr)$/;"	f
do_execute	eval.c	/^do_execute(eap, getline, cookie)$/;"	f
do_exedit	ex_docmd.c	/^do_exedit(eap, old_curwin)$/;"	f	file:
do_exit	ex_docmd.c	/^do_exit(eap)$/;"	f	file:
do_exjoin	ex_docmd.c	/^do_exjoin(eap)$/;"	f	file:
do_exmap	ex_docmd.c	/^do_exmap(eap, isabbrev)$/;"	f	file:
do_exmode	ex_docmd.c	/^do_exmode()$/;"	f
do_exops	ex_docmd.c	/^do_exops(eap)$/;"	f	file:
do_file	ex_cmds.c	/^do_file(arg, forceit)$/;"	f
do_filter	ex_cmds.c	/^do_filter(line1, line2, buff, do_in, do_out)$/;"	f	file:
do_findpat	ex_docmd.c	/^do_findpat(eap, action)$/;"	f	file:
do_fixdel	ex_cmds.c	/^do_fixdel()$/;"	f
do_g_cmd	normal.c	/^do_g_cmd(cap, searchp)$/;"	f	file:
do_gd	normal.c	/^do_gd(oap, nchar)$/;"	f	file:
do_glob	ex_cmds.c	/^do_glob(eap)$/;"	f
do_gomark	normal.c	/^do_gomark(cap, flag)$/;"	f	file:
do_goto	normal.c	/^do_goto(oap, lnum)$/;"	f	file:
do_gotofile	normal.c	/^do_gotofile(cap)$/;"	f	file:
do_gui	ex_docmd.c	/^do_gui(eap)$/;"	f	file:
do_halfpage	normal.c	/^do_halfpage(cap)$/;"	f	file:
do_help	ex_cmds.c	/^do_help(eap)$/;"	f
do_highlight	syntax.c	/^do_highlight(line, forceit)$/;"	f
do_ident	normal.c	/^do_ident(cap, searchp)$/;"	f	file:
do_if	ex_docmd.c	/^do_if(eap, cstack)$/;"	f	file:
do_intro	screen.c	/^do_intro()$/;"	f
do_join	ops.c	/^do_join(insert_space, redraw)$/;"	f
do_jumps	mark.c	/^do_jumps()$/;"	f
do_left	normal.c	/^do_left(cap)$/;"	f	file:
do_let	eval.c	/^do_let(eap)$/;"	f
do_lineop	normal.c	/^do_lineop(cap)$/;"	f	file:
do_lower	regexp.c	/^do_lower(d, c)$/;"	f	file:
do_make	ex_docmd.c	/^do_make(arg)$/;"	f	file:
do_map	getchar.c	/^do_map(maptype, keys, mode, abbrev)$/;"	f
do_marks	mark.c	/^do_marks(arg)$/;"	f
do_mkrc	ex_docmd.c	/^do_mkrc(eap)$/;"	f	file:
do_modelines	buffer.c	/^do_modelines()$/;"	f
do_mouse	normal.c	/^do_mouse(oap, c, dir, count, fix_indent)$/;"	f
do_move	ex_cmds.c	/^do_move(line1, line2, dest)$/;"	f
do_next	ex_docmd.c	/^do_next(eap)$/;"	f	file:
do_normal	ex_docmd.c	/^do_normal(eap)$/;"	f	file:
do_normal_search	normal.c	/^do_normal_search(cap, searchp, dont_set_mark)$/;"	f	file:
do_object	normal.c	/^do_object(cap)$/;"	f	file:
do_one_cmd	ex_docmd.c	/^do_one_cmd(cmdlinep, sourcing,$/;"	f	file:
do_opencmd	normal.c	/^do_opencmd(cap)$/;"	f	file:
do_operator	normal.c	/^do_operator(cap)$/;"	f	file:
do_optrans	normal.c	/^do_optrans(cap)$/;"	f	file:
do_outofmem_msg	misc2.c	/^do_outofmem_msg()$/;"	f
do_pcmark	normal.c	/^do_pcmark(cap)$/;"	f	file:
do_pending_operator	normal.c	/^do_pending_operator(cap, searchbuff,$/;"	f
do_percent	normal.c	/^do_percent(cap)$/;"	f	file:
do_pput	normal.c	/^do_pput(cap)$/;"	f	file:
do_print	ex_docmd.c	/^do_print(eap)$/;"	f	file:
do_put	ops.c	/^do_put(regname, dir, count, fix_indent)$/;"	f
do_pwd	ex_docmd.c	/^do_pwd()$/;"	f	file:
do_pyfile	if_python.c	/^do_pyfile(EXARG *eap)$/;"	f
do_python	if_python.c	/^do_python(EXARG *eap)$/;"	f
do_quit	ex_docmd.c	/^do_quit(eap)$/;"	f	file:
do_quit_all	ex_docmd.c	/^do_quit_all(forceit)$/;"	f	file:
do_read	ex_docmd.c	/^do_read(eap)$/;"	f	file:
do_record	ops.c	/^do_record(c)$/;"	f
do_recover	ex_docmd.c	/^do_recover(eap)$/;"	f	file:
do_redir	ex_docmd.c	/^do_redir(eap)$/;"	f	file:
do_redraw	globals.h	/^EXTERN int	do_redraw INIT(= FALSE);    \/* extra redraw once *\/$/;"	v
do_regname	normal.c	/^do_regname(cap, opnump)$/;"	f	file:
do_replace	normal.c	/^do_replace(cap)$/;"	f	file:
do_resize	ex_docmd.c	/^do_resize(eap)$/;"	f	file:
do_resize	os_unix.c	/^static int	do_resize = FALSE;$/;"	v	file:
do_retab	ex_cmds.c	/^do_retab(eap)$/;"	f
do_right	normal.c	/^do_right(cap)$/;"	f	file:
do_scroll	normal.c	/^do_scroll(cap)$/;"	f	file:
do_scroll_line	normal.c	/^do_scroll_line(cap, is_ctrl_e)$/;"	f	file:
do_search	search.c	/^do_search(oap, dirc, str, count, options)$/;"	f
do_set	option.c	/^do_set(arg)$/;"	f
do_setmark	ex_docmd.c	/^do_setmark(eap)$/;"	f	file:
do_shell	ex_cmds.c	/^do_shell(cmd, flags)$/;"	f
do_sleep	ex_docmd.c	/^do_sleep(eap)$/;"	f	file:
do_source	ex_docmd.c	/^do_source(fname, check_other, is_vimrc)$/;"	f
do_splitview	ex_docmd.c	/^do_splitview(eap)$/;"	f	file:
do_sub	ex_cmds.c	/^do_sub(eap)$/;"	f
do_sub_msg	ex_cmds.c	/^do_sub_msg()$/;"	f	file:
do_suspend	ex_docmd.c	/^do_suspend(forceit)$/;"	f	file:
do_swapchar	normal.c	/^do_swapchar(cap)$/;"	f	file:
do_swapname	ex_docmd.c	/^do_swapname()$/;"	f	file:
do_syntax	syntax.c	/^do_syntax(eap)$/;"	f
do_tag	tag.c	/^do_tag(tag, type, count, forceit)$/;"	f
do_tags	tag.c	/^do_tags()$/;"	f
do_unlet	eval.c	/^do_unlet(arg)$/;"	f
do_upper	regexp.c	/^do_upper(d, c)$/;"	f	file:
do_version	version.c	/^do_version(arg)$/;"	f
do_viminfo	ex_cmds.c	/^do_viminfo(fp_in, fp_out, want_info, want_marks, force_read)$/;"	f	file:
do_visop	normal.c	/^do_visop(cap)$/;"	f	file:
do_visual	normal.c	/^do_visual(cap)$/;"	f	file:
do_while	ex_docmd.c	/^do_while(eap, cstack)$/;"	f	file:
do_window	window.c	/^do_window(nchar, Prenum)$/;"	f
do_winsize	ex_docmd.c	/^do_winsize(arg)$/;"	f	file:
do_wnext	ex_docmd.c	/^do_wnext(eap)$/;"	f	file:
do_wordcmd	normal.c	/^do_wordcmd(cap, type)$/;"	f	file:
do_wqall	ex_docmd.c	/^do_wqall(eap)$/;"	f	file:
do_write	ex_docmd.c	/^do_write(eap)$/;"	f	file:
do_z	ex_cmds.c	/^do_z(line, arg)$/;"	f
do_zet	normal.c	/^do_zet(cap)$/;"	f	file:
dofork	gui.h	/^    int		dofork;		    \/* Use fork() when GUI is starting *\/$/;"	m	struct:Gui
dollar_vcol	globals.h	/^EXTERN colnr_t	dollar_vcol INIT(= 0);$/;"	v
dont_scroll	globals.h	/^EXTERN	int	dont_scroll INIT(= FALSE);\/* don't use scrollbars when TRUE *\/$/;"	v
dont_wait_return	globals.h	/^EXTERN int	dont_wait_return INIT(= 0); \/* no need to wait for return *\/$/;"	v
dpy	gui.h	/^    Display	*dpy;		    \/* X display *\/$/;"	m	struct:Gui
dragged_sb	gui.h	/^    int		dragged_sb;	    \/* Which scrollbar being dragged, if any? *\/$/;"	m	struct:Gui
dragged_wp	gui.h	/^    struct window   *dragged_wp;    \/* Which WIN's sb being dragged, if any? *\/$/;"	m	struct:Gui	typeref:struct:Gui::window
dying	gui.h	/^    int		dying;		    \/* Is vim dying? Then output to terminal *\/$/;"	m	struct:Gui
e_abort	globals.h	/^EXTERN char_u e_abort[]	    INIT(="Command aborted");$/;"	v
e_ambmap	globals.h	/^EXTERN char_u e_ambmap[]    INIT(="Ambiguous mapping");$/;"	v
e_argreq	globals.h	/^EXTERN char_u e_argreq[]    INIT(="Argument required");$/;"	v
e_backslash	globals.h	/^EXTERN char_u e_backslash[] INIT(="\\\\ should be followed by \/, ? or &");$/;"	v
e_curdir	globals.h	/^EXTERN char_u e_curdir[]    INIT(="Command not allowed from exrc\/vimrc in current dir or tag search");$/;"	v
e_exists	globals.h	/^EXTERN char_u e_exists[]    INIT(="File exists (use ! to override)");$/;"	v
e_failed	globals.h	/^EXTERN char_u e_failed[]    INIT(="Command failed");$/;"	v
e_hitend	edit.c	/^char_u e_hitend[] = "Hit end of paragraph";$/;"	v
e_hitend_b	edit.c	/^char_u e_hitend_b[] = "Hit end of paragraph (backward)";$/;"	v
e_hitend_f	edit.c	/^char_u e_hitend_f[] = "Hit end of paragraph (forward)";$/;"	v
e_internal	globals.h	/^EXTERN char_u e_internal[]  INIT(="Internal error");$/;"	v
e_interr	globals.h	/^EXTERN char_u e_interr[]    INIT(="Interrupted");$/;"	v
e_invaddr	globals.h	/^EXTERN char_u e_invaddr[]   INIT(="Invalid address");$/;"	v
e_invarg	globals.h	/^EXTERN char_u e_invarg[]    INIT(="Invalid argument");$/;"	v
e_invarg2	globals.h	/^EXTERN char_u e_invarg2[]   INIT(="Invalid argument: %s");$/;"	v
e_invcmd	globals.h	/^EXTERN char_u e_invcmd[]    INIT(="Invalid command");$/;"	v
e_invexpr2	globals.h	/^EXTERN char_u e_invexpr2[]  INIT(="Invalid expression: %s");$/;"	v
e_invrange	globals.h	/^EXTERN char_u e_invrange[]  INIT(="Invalid range");$/;"	v
e_letunexp	globals.h	/^EXTERN char_u e_letunexp[]  INIT(="Unexpected characters before '='");$/;"	v
e_markinval	globals.h	/^EXTERN char_u e_markinval[] INIT(="Mark has invalid line number");$/;"	v
e_marknotset	globals.h	/^EXTERN char_u e_marknotset[]	INIT(="Mark not set");$/;"	v
e_nesting	globals.h	/^EXTERN char_u e_nesting[]   INIT(="Scripts nested too deep");$/;"	v
e_noalt	globals.h	/^EXTERN char_u e_noalt[]	    INIT(="No alternate file");$/;"	v
e_nobang	globals.h	/^EXTERN char_u e_nobang[]    INIT(="No ! allowed");$/;"	v
e_nofarsi	globals.h	/^EXTERN char_u e_nofarsi[]   INIT(="Farsi cannot be used: Not enabled at compile time\\n");$/;"	v
e_nogvim	globals.h	/^EXTERN char_u e_nogvim[]    INIT(="GUI cannot be used: Not enabled at compile time\\n");$/;"	v
e_nohebrew	globals.h	/^EXTERN char_u e_nohebrew[]  INIT(="Hebrew cannot be used: Not enabled at compile time\\n");$/;"	v
e_noinstext	globals.h	/^EXTERN char_u e_noinstext[] INIT(="No inserted text yet");$/;"	v
e_nolastcmd	globals.h	/^EXTERN char_u e_nolastcmd[] INIT(="No previous command line");$/;"	v
e_nomap	globals.h	/^EXTERN char_u e_nomap[]	    INIT(="No such mapping");$/;"	v
e_nomatch	globals.h	/^EXTERN char_u e_nomatch[]   INIT(="No match");$/;"	v
e_noname	globals.h	/^EXTERN char_u e_noname[]    INIT(="No file name");$/;"	v
e_nopresub	globals.h	/^EXTERN char_u e_nopresub[]  INIT(="No previous substitute regular expression");$/;"	v
e_noprev	globals.h	/^EXTERN char_u e_noprev[]    INIT(="No previous command");$/;"	v
e_noprevre	globals.h	/^EXTERN char_u e_noprevre[]  INIT(="No previous regular expression");$/;"	v
e_norange	globals.h	/^EXTERN char_u e_norange[]   INIT(="No range allowed");$/;"	v
e_noroom	globals.h	/^EXTERN char_u e_noroom[]    INIT(="Not enough room");$/;"	v
e_notcreate	globals.h	/^EXTERN char_u e_notcreate[] INIT(="Can't create file %s");$/;"	v
e_notmp	globals.h	/^EXTERN char_u e_notmp[]	    INIT(="Can't get temp file name");$/;"	v
e_notopen	globals.h	/^EXTERN char_u e_notopen[]   INIT(="Can't open file %s");$/;"	v
e_notread	globals.h	/^EXTERN char_u e_notread[]   INIT(="Can't read file %s");$/;"	v
e_nowrtmsg	globals.h	/^EXTERN char_u e_nowrtmsg[]  INIT(="No write since last change (use ! to override)");$/;"	v
e_null	globals.h	/^EXTERN char_u e_null[]	    INIT(="Null argument");$/;"	v
e_number	globals.h	/^EXTERN char_u e_number[]    INIT(="Number expected");$/;"	v
e_openerrf	globals.h	/^EXTERN char_u e_openerrf[]  INIT(="Can't open errorfile %s");$/;"	v
e_outofmem	globals.h	/^EXTERN char_u e_outofmem[]  INIT(="Out of memory!");$/;"	v
e_patnotf	globals.h	/^EXTERN char_u e_patnotf[]   INIT(="Pattern not found");$/;"	v
e_patnotf_b	edit.c	/^char_u e_patnotf_b[] = "Pattern not found (backward)";$/;"	v
e_patnotf_f	edit.c	/^char_u e_patnotf_f[] = "Pattern not found (forward)";$/;"	v
e_positive	globals.h	/^EXTERN char_u e_positive[]  INIT(="Argument must be positive");$/;"	v
e_quickfix	globals.h	/^EXTERN char_u e_quickfix[]  INIT(="No Errors");$/;"	v
e_re_corr	globals.h	/^EXTERN char_u e_re_corr[]   INIT(="Corrupted regexp program");$/;"	v
e_re_damg	globals.h	/^EXTERN char_u e_re_damg[]   INIT(="Damaged match string");$/;"	v
e_readerrf	globals.h	/^EXTERN char_u e_readerrf[]  INIT(="Error while reading errorfile");$/;"	v
e_readonly	globals.h	/^EXTERN char_u e_readonly[]  INIT(="'readonly' option is set (use ! to override)");$/;"	v
e_scroll	globals.h	/^EXTERN char_u e_scroll[]    INIT(="Invalid scroll size");$/;"	v
e_tagformat	globals.h	/^EXTERN char_u e_tagformat[] INIT(="Format error in tags file \\"%s\\"");$/;"	v
e_tagstack	globals.h	/^EXTERN char_u e_tagstack[]  INIT(="tag stack empty");$/;"	v
e_toocompl	globals.h	/^EXTERN char_u e_toocompl[]  INIT(="Command too complex");$/;"	v
e_toolong	globals.h	/^EXTERN char_u e_toolong[]   INIT(="Command too long");$/;"	v
e_toomany	globals.h	/^EXTERN char_u e_toomany[]   INIT(="Too many file names");$/;"	v
e_toombra	globals.h	/^EXTERN char_u e_toombra[]   INIT(="Too many \\\\(");$/;"	v
e_toomket	globals.h	/^EXTERN char_u e_toomket[]   INIT(="Too many \\\\)");$/;"	v
e_toomsbra	globals.h	/^EXTERN char_u e_toomsbra[]  INIT(="Too many [");$/;"	v
e_trailing	globals.h	/^EXTERN char_u e_trailing[]  INIT(="Trailing characters");$/;"	v
e_umark	globals.h	/^EXTERN char_u e_umark[]	    INIT(="Unknown mark");$/;"	v
e_unknown	globals.h	/^EXTERN char_u e_unknown[]   INIT(="Unknown");$/;"	v
e_write	globals.h	/^EXTERN char_u e_write[]	    INIT(="Error while writing");$/;"	v
e_zerocount	globals.h	/^EXTERN char_u e_zerocount[] INIT(="Zero count");$/;"	v
echeck_abbr	edit.c	/^echeck_abbr(c)$/;"	f	file:
edit	edit.c	/^edit(cmdchar, startln, count)$/;"	f
edit_putchar	edit.c	/^edit_putchar(c, highlight)$/;"	f	file:
edit_submode	globals.h	/^EXTERN char_u	*edit_submode INIT(= NULL); \/* msg for CTRL-X submode *\/$/;"	v
edit_submode_extra	globals.h	/^EXTERN char_u	*edit_submode_extra INIT(= NULL);\/* extra info for msg *\/$/;"	v
edit_submode_highl	globals.h	/^EXTERN enum hlf_value	edit_submode_highl; \/* highl. method for extra info *\/$/;"	v	typeref:enum:hlf_value
eformat	quickfix.c	/^struct eformat$/;"	s	file:
empty	gui_at_sb.h	/^typedef struct {int empty;} ScrollbarClassPart;$/;"	m	struct:__anon17
empty	structs.h	/^    int	    empty;		\/* op_start and op_end the same (only used by$/;"	m	struct:oparg
empty_option	globals.h	/^EXTERN char_u	*empty_option INIT(= (char_u *)"");$/;"	v
emsg	message.c	/^emsg(s)$/;"	f
emsg2	message.c	/^emsg2(s, a1)$/;"	f
emsg_off	globals.h	/^EXTERN int	emsg_off INIT(= FALSE);	    \/* don't display errors for now *\/$/;"	v
emsg_on_display	globals.h	/^EXTERN int	emsg_on_display INIT(= FALSE);	\/* there is an error message *\/$/;"	v
emsgn	message.c	/^emsgn(s, n)$/;"	f
end	if_python.c	/^    int end;$/;"	m	struct:__anon7	file:
end	search.c	/^    int		end;		\/* search set cursor at end *\/$/;"	m	struct:soffset	file:
end	structs.h	/^    FPOS    end;		\/* end of the operator *\/$/;"	m	struct:oparg
end	vim.h	/^    FPOS	end;		    \/* End of selected area *\/$/;"	m	struct:VimClipboard
end_adjusted	structs.h	/^    int	    end_adjusted;	\/* backuped b_op_end one char (only used by$/;"	m	struct:oparg
end_search_hl	screen.c	/^end_search_hl()$/;"	f	file:
end_vcol	structs.h	/^    colnr_t end_vcol;		\/* end col for block mode operator *\/$/;"	m	struct:oparg
end_visual_mode	normal.c	/^end_visual_mode()$/;"	f
end_word	search.c	/^end_word(count, type, stop, empty)$/;"	f
endp	regexp.h	/^    char_u	   *endp[NSUBEXP];$/;"	m	struct:__anon11
ends_excmd	ex_docmd.c	/^ends_excmd(c)$/;"	f
endspaces	ops.c	/^    int		endspaces;$/;"	m	struct:block_def	file:
enter_buffer	buffer.c	/^enter_buffer(buf)$/;"	f	file:
equal	macros.h	27;"	d
error	ex_docmd.c	/^    int		error;		\/* TRUE if LF found after CR-LF *\/$/;"	m	struct:source_cookie	file:
error	if_python.c	/^    long error;$/;"	m	struct:__anon4	file:
escape_chars	globals.h	/^EXTERN char_u	*escape_chars INIT(= (char_u *)" \\t\\\\\\"|");$/;"	v
eval0	eval.c	/^eval0(arg, retvar, nextcmd)$/;"	f	file:
eval1	eval.c	/^eval1(arg, retvar)$/;"	f	file:
eval2	eval.c	/^eval2(arg, retvar)$/;"	f	file:
eval3	eval.c	/^eval3(arg, retvar)$/;"	f	file:
eval4	eval.c	/^eval4(arg, retvar)$/;"	f	file:
eval5	eval.c	/^eval5(arg, retvar)$/;"	f	file:
eval6	eval.c	/^eval6(arg, retvar)$/;"	f	file:
eval_input	if_python.c	31;"	d	file:
eval_isnamec	eval.c	/^eval_isnamec(c)$/;"	f	file:
eval_to_bool	eval.c	/^eval_to_bool(arg, error, nextcmd)$/;"	f
eval_to_string	eval.c	/^eval_to_string(arg, nextcmd)$/;"	f
eval_vars	ex_docmd.c	/^eval_vars(src, usedlen, lnump, errormsg)$/;"	f
event	fileio.c	/^    EVENT_T	event;		\/* current event *\/$/;"	m	struct:AutoPatCmd	file:
event	fileio.c	/^    EVENT_T	event;	    \/* event number *\/$/;"	m	struct:event_name	file:
event_ignored	fileio.c	/^event_ignored(event)$/;"	f	file:
event_name	fileio.c	/^static struct event_name$/;"	s	file:
event_name2nr	fileio.c	/^event_name2nr(start, end)$/;"	f	file:
event_names	fileio.c	/^} event_names[] =$/;"	v	typeref:struct:event_name	file:
event_nr2name	fileio.c	/^event_nr2name(event)$/;"	f	file:
ex_no_reprint	globals.h	/^EXTERN int ex_no_reprint INIT(= FALSE); \/* no need to print after z or p *\/$/;"	v
ex_pressedreturn	ex_docmd.c	/^static int	    ex_pressedreturn = FALSE;$/;"	v	file:
exarg	ex_cmds.h	/^typedef struct exarg$/;"	s
exe_name	globals.h	/^EXTERN char_u	*exe_name;		\/* the name of the executable *\/$/;"	v
exiting	globals.h	/^EXTERN int	exiting INIT(= FALSE);$/;"	v
exmode_active	globals.h	/^EXTERN int exmode_active INIT(= FALSE);$/;"	v
exp_type	eval.c	/^enum exp_type$/;"	g	file:
expand_context	globals.h	/^EXTERN int	expand_context INIT(= CONTEXT_UNKNOWN);$/;"	v
expand_env	misc1.c	/^expand_env(src, dst, dstlen)$/;"	f
expand_env_save	misc1.c	/^expand_env_save(src)$/;"	f
expand_interactively	globals.h	/^EXTERN int	expand_interactively INIT(= FALSE);$/;"	v
expand_option_idx	option.c	/^static int expand_option_idx = -1;$/;"	v	file:
expand_option_name	option.c	/^static char_u expand_option_name[5] = {'t', '_', NUL, NUL, NUL};$/;"	v	file:
expand_pattern	globals.h	/^EXTERN char_u	*expand_pattern INIT(= NULL);$/;"	v
expand_rel_name	tag.c	/^expand_rel_name(fname, tag_fname)$/;"	f	file:
expand_sfile	ex_docmd.c	/^expand_sfile(arg)$/;"	f
expand_what	syntax.c	/^} expand_what;$/;"	v	typeref:enum:__anon3	file:
expand_wildcards	misc1.c	/^expand_wildcards(num_pat, pat, num_file, file, flags)$/;"	f
expand_wildcards	vim.h	303;"	d
expr_line	ops.c	/^static char_u	*expr_line = NULL;$/;"	v	file:
extra_shell_arg	os_unix.c	/^static char_u	*extra_shell_arg = NULL;$/;"	v	file:
f_buffer_exists	eval.c	/^f_buffer_exists(argvars, retvar)$/;"	f	file:
f_char2nr	eval.c	/^f_char2nr(argvars, retvar)$/;"	f	file:
f_col	eval.c	/^f_col(argvars, retvar)$/;"	f	file:
f_delete	eval.c	/^f_delete(argvars, retvar)$/;"	f	file:
f_exists	eval.c	/^f_exists(argvars, retvar)$/;"	f	file:
f_expand	eval.c	/^f_expand(argvars, retvar)$/;"	f	file:
f_file_readable	eval.c	/^f_file_readable(argvars, retvar)$/;"	f	file:
f_getline	eval.c	/^f_getline(argvars, retvar)$/;"	f	file:
f_has	eval.c	/^f_has(argvars, retvar)$/;"	f	file:
f_highlightID	eval.c	/^f_highlightID(argvars, retvar)$/;"	f	file:
f_highlight_exists	eval.c	/^f_highlight_exists(argvars, retvar)$/;"	f	file:
f_hostname	eval.c	/^f_hostname(argvars, retvar)$/;"	f	file:
f_isdirectory	eval.c	/^f_isdirectory(argvars, retvar)$/;"	f	file:
f_last_buffer_nr	eval.c	/^f_last_buffer_nr(argvars, retvar)$/;"	f	file:
f_line	eval.c	/^f_line(argvars, retvar)$/;"	f	file:
f_match	eval.c	/^f_match(argvars, retvar)$/;"	f	file:
f_matchend	eval.c	/^f_matchend(argvars, retvar)$/;"	f	file:
f_nr2char	eval.c	/^f_nr2char(argvars, retvar)$/;"	f	file:
f_some_match	eval.c	/^f_some_match(argvars, retvar, start)$/;"	f	file:
f_strftime	eval.c	/^f_strftime(argvars, retvar)$/;"	f	file:
f_strlen	eval.c	/^f_strlen(argvars, retvar)$/;"	f	file:
f_strpart	eval.c	/^f_strpart(argvars, retvar)$/;"	f	file:
f_substitute	eval.c	/^f_substitute(argvars, retvar)$/;"	f	file:
f_synID	eval.c	/^f_synID(argvars, retvar)$/;"	f	file:
f_synIDattr	eval.c	/^f_synIDattr(argvars, retvar)$/;"	f	file:
f_synIDtrans	eval.c	/^f_synIDtrans(argvars, retvar)$/;"	f	file:
f_tempname	eval.c	/^f_tempname(argvars, retvar)$/;"	f	file:
f_virtcol	eval.c	/^f_virtcol(argvars, retvar)$/;"	f	file:
farsi_fkey	farsi.c	/^farsi_fkey(c)$/;"	f
farsi_text_1	farsi.h	/^EXTERN char_u farsi_text_1[]$/;"	v
farsi_text_2	farsi.h	/^EXTERN char_u farsi_text_2[]$/;"	v
farsi_text_3	farsi.h	/^EXTERN char_u farsi_text_3[]$/;"	v
farsi_text_4	farsi.h	/^EXTERN char_u farsi_text_4[]$/;"	v
farsi_text_5	farsi.h	/^EXTERN char_u farsi_text_5[]$/;"	v
father	gui.h	/^    struct GuiMenu *father;	    \/* The father of the menu *\/$/;"	m	struct:GuiMenu	typeref:struct:GuiMenu::GuiMenu
fg_color	structs.h	/^	    GuiColor	    fg_color;	\/* foreground color handle *\/$/;"	m	struct:attr_entry::__anon12::__anon15
fg_color	structs.h	/^	    char_u	    fg_color;	\/* foreground color number *\/$/;"	m	struct:attr_entry::__anon12::__anon14
file_input	if_python.c	30;"	d	file:
file_name_at_cursor	window.c	/^file_name_at_cursor(options, count)$/;"	f
file_on_stdin	globals.h	/^EXTERN int	file_on_stdin INIT(= FALSE);	\/* read file from stdin *\/$/;"	v
file_pat_to_reg_pat	fileio.c	/^file_pat_to_reg_pat(pat, pat_end, allow_dirs)$/;"	f
fileformat	ex_docmd.c	/^    int		fileformat;	\/* EOL_UNKNOWN, EOL_UNIX or EOL_DOS *\/$/;"	m	struct:source_cookie	file:
fileinfo	buffer.c	/^fileinfo(fullname, shorthelp, dont_truncate)$/;"	f
filemark	structs.h	/^struct filemark$/;"	s
filemess	fileio.c	/^filemess(buf, name, s, attr)$/;"	f
fill_breakat_flags	option.c	/^fill_breakat_flags()$/;"	f	file:
fill_input_buf	ui.c	/^fill_input_buf(exit_on_error)$/;"	f
find_builtin_term	term.c	/^find_builtin_term(term)$/;"	f	file:
find_end_event	fileio.c	/^find_end_event(arg)$/;"	f	file:
find_end_of_word	normal.c	/^find_end_of_word(pos)$/;"	f	file:
find_endp	syntax.c	/^find_endp(idx, sstart, at_bol, hl_endp, flagsp, end_endp, end_idx)$/;"	f	file:
find_extra	tag.c	/^find_extra(pp)$/;"	f	file:
find_file_in_path	window.c	/^find_file_in_path(ptr, len, options, count)$/;"	f	file:
find_file_in_wildcard_path	window.c	/^find_file_in_wildcard_path(path_so_far, wildcards, level, countptr)$/;"	f	file:
find_first_blank	search.c	/^find_first_blank(posp)$/;"	f	file:
find_help_tags	ex_cmds.c	/^find_help_tags(arg, num_matches, matches)$/;"	f
find_ident_under_cursor	normal.c	/^find_ident_under_cursor(string, find_type)$/;"	f
find_key_option	option.c	/^find_key_option(arg)$/;"	f	file:
find_last_paren	misc1.c	/^find_last_paren(l)$/;"	f	file:
find_match	misc1.c	/^find_match(lookfor, ourscope, ind_maxparen, ind_maxcomment)$/;"	f	file:
find_match_paren	misc1.c	/^find_match_paren(ind_maxparen, ind_maxcomment)	    \/* XXX *\/$/;"	f	file:
find_nextcmd	ex_docmd.c	/^find_nextcmd(p)$/;"	f
find_option_end	eval.c	/^find_option_end(p)$/;"	f	file:
find_pattern_in_path	search.c	/^find_pattern_in_path(ptr, dir, len, whole, skip_comments,$/;"	f
find_special_key	misc2.c	/^find_special_key(srcp, modp)$/;"	f
find_special_key_in_table	misc2.c	/^find_special_key_in_table(c)$/;"	f
find_start_brace	misc1.c	/^find_start_brace(ind_maxcomment)	    \/* XXX *\/$/;"	f	file:
find_start_comment	misc1.c	/^find_start_comment(ind_maxcomment)	    \/* XXX *\/$/;"	f
find_start_of_word	normal.c	/^find_start_of_word(pos)$/;"	f	file:
find_tags	tag.c	/^find_tags(pat, num_matches, matchesp, flags, mincount)$/;"	f
find_termcode	term.c	/^find_termcode(name)$/;"	f
find_var	eval.c	/^find_var(name)$/;"	f	file:
find_var_ga	eval.c	/^find_var_ga(name, varname)$/;"	f	file:
find_viminfo_parameter	option.c	/^find_viminfo_parameter(type)$/;"	f
findmatch	search.c	/^findmatch(oap, initc)$/;"	f
findmatchlimit	search.c	/^findmatchlimit(oap, initc, flags, maxtravel)$/;"	f
findoption	option.c	/^findoption(arg)$/;"	f	file:
findpar	search.c	/^findpar(oap, dir, count, what, both)$/;"	f
findsent	search.c	/^findsent(dir, count)$/;"	f
findsent_forward	search.c	/^findsent_forward(count, at_start_sent)$/;"	f	file:
findswapname	memline.c	/^findswapname(buf, dirp, old_fname)$/;"	f	file:
finish_op	globals.h	/^EXTERN int	finish_op INIT(= FALSE);\/* TRUE while an operator is pending *\/$/;"	v
finish_viminfo_history	ex_getln.c	/^finish_viminfo_history()$/;"	f
first_abbr	getchar.c	/^static struct mapblock *first_abbr = NULL; \/* first entry in abbrlist *\/$/;"	v	typeref:struct:mapblock	file:
first_autopat	fileio.c	/^static AutoPat *first_autopat[NUM_EVENTS] =$/;"	v	file:
first_match	edit.c	/^static struct Completion    *first_match = NULL;$/;"	v	typeref:struct:Completion	file:
firstbuf	globals.h	/^EXTERN BUF	*firstbuf INIT(= NULL);	\/* first buffer *\/$/;"	v
firstwin	globals.h	/^EXTERN WIN	*firstwin;	\/* first window *\/$/;"	v
fix_fname	buffer.c	/^fix_fname(fname)$/;"	f
fixedtitle	os_unix.c	/^static char_u	*fixedtitle = (char_u *)"Thanks for flying Vim";$/;"	v	file:
fixthisline	edit.c	/^fixthisline(get_the_indent)$/;"	f
fkmap	farsi.c	/^fkmap(c)$/;"	f
flags	option.c	/^    short	flags;		\/* see below *\/$/;"	m	struct:vimoption	file:
flags	structs.h	/^    short	    flags;	\/* see syntax.c *\/$/;"	m	struct:keyentry
flush_buffers	getchar.c	/^flush_buffers(typeahead)$/;"	f
fm_getname	mark.c	/^fm_getname(fmark)$/;"	f
fmark	structs.h	/^    struct filemark fmark;		\/* cursor position BEFORE ":tag" *\/$/;"	m	struct:taggy	typeref:struct:taggy::filemark
fmarks_check_names	mark.c	/^fmarks_check_names(buf)$/;"	f
fmt_end_block	ops.c	/^fmt_end_block(lnum, leader_len, leader_flags)$/;"	f	file:
fmtstr	quickfix.c	/^    char_u	    *fmtstr;	    \/* pre-formatted part of 'errorformat' *\/$/;"	m	struct:eformat	file:
fname	edit.c	/^    char_u		*fname;	  \/* file containing the match *\/$/;"	m	struct:Completion	file:
fname	fileio.c	/^    char_u	*fname;		\/* fname to match with *\/$/;"	m	struct:AutoPatCmd	file:
fname	tag.c	/^    char_u	*fname;		\/* first char of file name *\/$/;"	m	struct:tag_pointers	file:
fname_end	tag.c	/^    char_u	*fname_end;	\/* char after file name *\/$/;"	m	struct:tag_pointers	file:
fname_expand	buffer.c	/^fname_expand(ffname, sfname)$/;"	f
fnamecmp	vim.h	699;"	d
fnamecmp	vim.h	702;"	d
fnamecmp_ino	memline.c	/^fnamecmp_ino(fname_c, fname_s, ino_block0)$/;"	f	file:
fnamencmp	vim.h	700;"	d
fnamencmp	vim.h	703;"	d
fnum	structs.h	/^    int		    fnum;	    \/* file number *\/$/;"	m	struct:filemark
fo_do_comments	globals.h	/^EXTERN int	fo_do_comments INIT(= FALSE);$/;"	v
font	structs.h	/^	    GuiFont	    font;	\/* font handle *\/$/;"	m	struct:attr_entry::__anon12::__anon15
font_name2handle	syntax.c	/^font_name2handle(name)$/;"	f	file:
font_opt	globals.h	/^EXTERN char *	font_opt INIT(= NULL);$/;"	v
forceit	ex_cmds.h	/^    int		forceit;    \/* TRUE if ! present *\/$/;"	m	struct:exarg
foreground	gui_at_sb.h	/^    Pixel	  foreground;	\/* thumb foreground color *\/$/;"	m	struct:__anon16
format	vim.h	/^    int_u	format;		    \/* Vim's own special clipboard format *\/$/;"	m	struct:VimClipboard
found_reverse_arg	globals.h	/^EXTERN int	found_reverse_arg INIT(= FALSE);$/;"	v
fp	ex_docmd.c	/^    FILE	*fp;		\/* opened file for sourcing *\/$/;"	m	struct:source_cookie	file:
fp	search.c	/^    FILE	*fp;		\/* File pointer *\/$/;"	m	struct:SearchedFile	file:
fpos	structs.h	/^struct fpos$/;"	s
free_buf_options	buffer.c	/^free_buf_options(buf, free_p_ff)$/;"	f
free_buf_winlnum	buffer.c	/^free_buf_winlnum(buf)$/;"	f	file:
free_buff	getchar.c	/^free_buff(buf)$/;"	f	file:
free_cmdlines	ex_docmd.c	/^free_cmdlines(gap)$/;"	f	file:
free_completions	edit.c	/^free_completions()$/;"	f	file:
free_keywtab	syntax.c	/^free_keywtab(ktabp)$/;"	f	file:
free_string_option	option.c	/^free_string_option(p)$/;"	f
free_var	eval.c	/^free_var(varp)$/;"	f	file:
free_yank	ops.c	/^free_yank(n)$/;"	f	file:
free_yank_all	ops.c	/^free_yank_all()$/;"	f	file:
fstatfs	memfile.c	50;"	d	file:
fstatfs	memfile.c	57;"	d	file:
full_screen	globals.h	/^EXTERN int	full_screen INIT(= FALSE);$/;"	v
fullname	option.c	/^    char	*fullname;	\/* full option name *\/$/;"	m	struct:vimoption	file:
fullpathcmp	misc1.c	/^fullpathcmp(s1, s2, checkname)$/;"	f
func	syntax.c	/^    void    (*func)__ARGS((EXARG *, int));	\/* function to call *\/$/;"	m	struct:subcommand	file:
fwd_word	search.c	/^fwd_word(count, type, eol)$/;"	f
ga_clear	misc2.c	/^ga_clear(ga)$/;"	f
ga_data	structs.h	/^    void    *ga_data;		    \/* pointer to the first item *\/$/;"	m	struct:growarray
ga_grow	misc2.c	/^ga_grow(ga, n)$/;"	f
ga_growsize	structs.h	/^    int	    ga_growsize;	    \/* number of items to grow each time *\/$/;"	m	struct:growarray
ga_init	misc2.c	/^ga_init(ga)$/;"	f
ga_itemsize	structs.h	/^    int	    ga_itemsize;	    \/* sizeof one item *\/$/;"	m	struct:growarray
ga_len	structs.h	/^    int	    ga_len;		    \/* current number of items used *\/$/;"	m	struct:growarray
ga_room	structs.h	/^    int	    ga_room;		    \/* number of unused items at the end *\/$/;"	m	struct:growarray
gather_termleader	term.c	/^gather_termleader()$/;"	f	file:
gc	gui_at_sb.h	/^    GC		  gc;		\/* a (shared) gc *\/$/;"	m	struct:__anon16
gchar	misc1.c	/^gchar(pos)$/;"	f
gchar_cursor	misc1.c	/^gchar_cursor()$/;"	f
geom	gui.h	/^    char_u	*geom;		    \/* Geometry, eg "80x24" *\/$/;"	m	struct:Gui
get_address	ex_docmd.c	/^get_address(ptr)$/;"	f	file:
get_attr_entry	syntax.c	/^get_attr_entry(table, aep)$/;"	f	file:
get_augroup_name	fileio.c	/^get_augroup_name(idx)$/;"	f
get_bufcont	getchar.c	/^get_bufcont(buffer, dozero)$/;"	f	file:
get_bytes_from_buf	term.c	/^get_bytes_from_buf(buf, bytes, num_bytes)$/;"	f	file:
get_c_indent	misc1.c	/^get_c_indent()$/;"	f
get_command_name	ex_docmd.c	/^get_command_name(idx)$/;"	f
get_env_len	eval.c	/^get_env_len(arg)$/;"	f	file:
get_env_string	eval.c	/^get_env_string(arg)$/;"	f
get_env_var	eval.c	/^get_env_var(arg, retvar)$/;"	f	file:
get_event_name	fileio.c	/^get_event_name(idx)$/;"	f
get_expansion	edit.c	/^get_expansion(ini, dir)$/;"	f	file:
get_expr_line	ops.c	/^get_expr_line()$/;"	f	file:
get_expr_register	ops.c	/^get_expr_register()$/;"	f
get_file_in_dir	memline.c	/^get_file_in_dir(fname, dname)$/;"	f
get_file_name_in_path	window.c	/^get_file_name_in_path(line, col, options, count)$/;"	f
get_fileformat	misc2.c	/^get_fileformat(buf)$/;"	f
get_func_var	eval.c	/^get_func_var(name, len, retvar, arg)$/;"	f	file:
get_group_name	syntax.c	/^get_group_name(arg, name_end)$/;"	f	file:
get_highlight_default	option.c	/^get_highlight_default()$/;"	f
get_highlight_name	syntax.c	/^get_highlight_name(idx)$/;"	f
get_id_len	eval.c	/^get_id_len(arg)$/;"	f	file:
get_id_list	syntax.c	/^get_id_list(arg, keylen, list)$/;"	f	file:
get_indent	misc1.c	/^get_indent()$/;"	f
get_indent_lnum	misc1.c	/^get_indent_lnum(lnum)$/;"	f
get_indent_nolabel	misc1.c	/^get_indent_nolabel(lnum)		\/* XXX *\/$/;"	f	file:
get_indent_str	misc1.c	/^get_indent_str(ptr)$/;"	f	file:
get_inserted	getchar.c	/^get_inserted()$/;"	f
get_key_name	misc2.c	/^get_key_name(i)$/;"	f
get_last_insert	edit.c	/^get_last_insert()$/;"	f
get_last_insert_save	edit.c	/^get_last_insert_save()$/;"	f
get_leader_len	misc1.c	/^get_leader_len(line, flags)$/;"	f
get_lisp_indent	misc1.c	/^get_lisp_indent()$/;"	f
get_lit_string_var	eval.c	/^get_lit_string_var(arg, retvar)$/;"	f	file:
get_literal	edit.c	/^get_literal()$/;"	f
get_long_from_buf	term.c	/^get_long_from_buf(buf, val)$/;"	f
get_map_mode	getchar.c	/^get_map_mode(cmdp, forceit)$/;"	f
get_mef_name	ex_docmd.c	/^get_mef_name(newname)$/;"	f	file:
get_mouse_button	misc2.c	/^get_mouse_button(code, is_click, is_drag)$/;"	f
get_mouse_class	normal.c	/^get_mouse_class(c)$/;"	f	file:
get_nolist_virtcol	edit.c	/^get_nolist_virtcol()$/;"	f	file:
get_number	misc1.c	/^get_number(colon)$/;"	f
get_number_arg	main.c	/^get_number_arg(p, idx, def)$/;"	f	file:
get_option_value	option.c	/^get_option_value(name, numval, stringval)$/;"	f
get_option_var	eval.c	/^get_option_var(arg, retvar)$/;"	f	file:
get_past_head	misc1.c	/^get_past_head(path)$/;"	f
get_pseudo_mouse_code	misc2.c	/^get_pseudo_mouse_code(button, is_click, is_drag)$/;"	f
get_recorded	getchar.c	/^get_recorded()$/;"	f
get_reg_contents	ops.c	/^get_reg_contents(regname)$/;"	f
get_register_name	ops.c	/^get_register_name(num)$/;"	f
get_spec_reg	ops.c	/^get_spec_reg(regname, argp, allocated)$/;"	f	file:
get_special_key_code	misc2.c	/^get_special_key_code(name)$/;"	f
get_special_key_name	misc2.c	/^get_special_key_name(c, modifiers)$/;"	f
get_string_var	eval.c	/^get_string_var(arg, retvar)$/;"	f	file:
get_stty	os_unix.c	/^get_stty()$/;"	f
get_syn_options	syntax.c	/^get_syn_options(arg, flagsp, sync_idx, cont_list, next_list)$/;"	f	file:
get_syn_pattern	syntax.c	/^get_syn_pattern(arg, ci)$/;"	f	file:
get_syntax_attr	syntax.c	/^get_syntax_attr(col, line)$/;"	f
get_syntax_name	syntax.c	/^get_syntax_name(idx)$/;"	f
get_tagfname	tag.c	/^get_tagfname(first, buf)$/;"	f	file:
get_term_code	option.c	/^get_term_code(tname)$/;"	f
get_termcode	term.c	/^get_termcode(i)$/;"	f
get_var_number	eval.c	/^get_var_number(varp)$/;"	f	file:
get_var_string	eval.c	/^get_var_string(varp)$/;"	f	file:
get_var_string_buf	eval.c	/^get_var_string_buf(varp, buf)$/;"	f	file:
get_var_var	eval.c	/^get_var_var(name, len, retvar)$/;"	f	file:
get_varp	option.c	/^get_varp(p)$/;"	f	file:
get_version	version.c	/^get_version()$/;"	f
get_viminfo_parameter	option.c	/^get_viminfo_parameter(type)$/;"	f
get_x11_icon	os_unix.c	/^get_x11_icon(test_only)$/;"	f	file:
get_x11_title	os_unix.c	/^get_x11_title(test_only)$/;"	f	file:
get_x11_windis	os_unix.c	/^get_x11_windis()$/;"	f	file:
get_yank_register	ops.c	/^get_yank_register(regname, writing)$/;"	f	file:
getaltfname	buffer.c	/^getaltfname()$/;"	f
getargcmd	ex_docmd.c	/^getargcmd(argp)$/;"	f	file:
getchr	regexp.c	/^getchr()$/;"	f	file:
getcmdline	ex_getln.c	/^getcmdline(firstc, count, indent)$/;"	f
getcwd	vim.h	102;"	d
getdigits	charset.c	/^getdigits(pp)$/;"	f
getdigraph	digraph.c	/^getdigraph(char1, char2, meta)$/;"	f
getexactdigraph	digraph.c	/^getexactdigraph(char1, char2, meta)$/;"	f	file:
getexline	ex_getln.c	/^getexline(c, dummy, indent)$/;"	f
getexmodeline	ex_getln.c	/^getexmodeline(c, dummy, indent)$/;"	f
getfile	ex_docmd.c	/^getfile(fnum, ffname, sfname, setpm, lnum, forceit)$/;"	f
gethostname	os_unix.c	1040;"	d	file:
getlinecol	term.c	/^getlinecol()$/;"	f
getmark	mark.c	/^getmark(c, changefile)$/;"	f
getnextac	fileio.c	/^getnextac(c, cookie, indent)$/;"	f	file:
getnextcomp	misc1.c	/^getnextcomp(fname)$/;"	f
getout	main.c	/^getout(r)$/;"	f
getsourceline	ex_docmd.c	/^getsourceline(c, cookie, indent)$/;"	f
gettail	misc1.c	/^gettail(fname)$/;"	f
getvcol	charset.c	/^getvcol(wp, pos, start, cursor, end)$/;"	f
getvcols	charset.c	/^getvcols(pos1, pos2, left, right)$/;"	f
give_warning	message.c	/^give_warning(message, hl)$/;"	f
global_busy	globals.h	/^EXTERN int	global_busy INIT(= 0);	    \/* set when :global is executing *\/$/;"	v
global_opnum	globals.h	/^EXTERN linenr_t		global_opnum INIT(= 0);$/;"	v
got_int	globals.h	/^EXTERN int	got_int INIT(= FALSE);	    \/* set to TRUE when interrupt$/;"	v
got_x_error	os_unix.c	/^int	    got_x_error = FALSE;$/;"	v
gotchars	getchar.c	/^gotchars(s, len)$/;"	f	file:
goto_endofbuf	misc1.c	/^goto_endofbuf(pos)$/;"	f
gotocmdline	ex_getln.c	/^gotocmdline(clr)$/;"	f
group	fileio.c	/^    int		    group;		\/* group ID *\/$/;"	m	struct:AutoPat	file:
group	fileio.c	/^    int		group;		\/* group being used *\/$/;"	m	struct:AutoPatCmd	file:
growarray	structs.h	/^struct growarray$/;"	s
gui	structs.h	/^	} gui;$/;"	m	union:attr_entry::__anon12	typeref:struct:attr_entry::__anon12::__anon15
gui_attr_table	syntax.c	/^struct growarray    gui_attr_table = {0, 0, 0, 0, NULL};$/;"	v	typeref:struct:growarray
gui_do_one_color	syntax.c	/^gui_do_one_color(idx)$/;"	f	file:
had_eol	regexp.c	/^static int	had_eol;	\/* TRUE when EOL found by vim_regcomp() *\/$/;"	v	file:
halfpage	screen.c	/^halfpage(flag, Prenum)$/;"	f
handle_drop	ex_docmd.c	/^handle_drop(filec, filev)$/;"	f
has_format_option	option.c	/^has_format_option(x)$/;"	f
has_while_cmd	ex_docmd.c	/^has_while_cmd(p)$/;"	f	file:
have_dollars	os_unix.c	/^have_dollars(num, file)$/;"	f	file:
have_wildcard	os_unix.c	/^have_wildcard(num, file)$/;"	f	file:
height	gui.h	/^    int		height;		    \/* Height of scroll bar (num rows) *\/$/;"	m	struct:GuiScrollbar
help_compare	ex_cmds.c	/^help_compare(s1, s2)$/;"	f	file:
help_heuristic	ex_cmds.c	/^help_heuristic(matched_string, offset, wrong_case)$/;"	f
help_save_isk	globals.h	/^EXTERN char_u	*help_save_isk INIT(= NULL);\/* 'isk' saved by do_help() *\/$/;"	v
help_save_ts	globals.h	/^EXTERN long	help_save_ts INIT(= 0);	    \/* 'ts' saved by do_help() *\/$/;"	v
hex2nr	charset.c	/^hex2nr(c)$/;"	f
highlight_attr	globals.h	/^EXTERN int	highlight_attr[HLF_COUNT];  \/* Highl. attr for each context. *\/$/;"	v
highlight_changed	syntax.c	/^highlight_changed()$/;"	f
highlight_clear	syntax.c	/^highlight_clear(idx)$/;"	f	file:
highlight_color	syntax.c	/^highlight_color(id, what)$/;"	f
highlight_exists	syntax.c	/^highlight_exists(name)$/;"	f
highlight_ga	syntax.c	/^static struct growarray highlight_ga;	    \/* highlight groups for$/;"	v	typeref:struct:growarray	file:
highlight_gui_started	syntax.c	/^highlight_gui_started()$/;"	f
highlight_has_attr	syntax.c	/^highlight_has_attr(id, flag)$/;"	f
highlight_init_both	syntax.c	/^static char *(highlight_init_both[]) =$/;"	v	file:
highlight_init_dark	syntax.c	/^static char *(highlight_init_dark[]) =$/;"	v	file:
highlight_init_light	syntax.c	/^static char *(highlight_init_light[]) =$/;"	v	file:
highlight_list_arg	syntax.c	/^highlight_list_arg(id, didh, type, iarg, sarg, name)$/;"	f	file:
highlight_list_one	syntax.c	/^highlight_list_one(id)$/;"	f	file:
highlight_mask	gui.h	/^    int		highlight_mask;	    \/* Highlight attribute mask *\/$/;"	m	struct:Gui
highlight_match	globals.h	/^EXTERN int	highlight_match INIT(= FALSE);	\/* show search match pos *\/$/;"	v
highlight_status	screen.c	/^highlight_status(attr)$/;"	f	file:
hisidx	ex_getln.c	/^static int	hisidx[HIST_COUNT] = {-1, -1, -1};  \/* last entered entry *\/$/;"	v	file:
hislen	ex_getln.c	/^static int	hislen = 0;		\/* actual length of history tables *\/$/;"	v	file:
hist_char2type	ex_getln.c	/^hist_char2type(c)$/;"	f	file:
hist_type2char	ex_getln.c	/^hist_type2char(type, use_question)$/;"	f	file:
history	ex_getln.c	/^static char_u	**(history[HIST_COUNT]) = {NULL, NULL, NULL};$/;"	v	file:
hkmap	edit.c	/^hkmap(c)$/;"	f
hl_attr_table	syntax.c	/^static int hl_attr_table[] =$/;"	v	file:
hl_group	syntax.c	/^struct hl_group$/;"	s	file:
hl_name_table	syntax.c	/^static char *(hl_name_table[]) =$/;"	v	file:
hl_set_bg_color_name	syntax.c	/^hl_set_bg_color_name(name)$/;"	f
hl_set_fg_color_name	syntax.c	/^hl_set_fg_color_name(name)$/;"	f
hl_set_font_name	syntax.c	/^hl_set_font_name(font_name)$/;"	f
hlf_value	vim.h	/^enum hlf_value$/;"	g
home_replace	misc1.c	/^home_replace(buf, src, dst, dstlen)$/;"	f
home_replace_save	misc1.c	/^home_replace_save(buf, src)$/;"	f
homedir	misc1.c	/^static char_u	*homedir = NULL;$/;"	v	file:
id	gui.h	/^    BMenuItem	*id;		    \/* Id of menu item *\/$/;"	m	struct:GuiMenu
id	gui.h	/^    ControlHandle id;		    \/* A handle to the scrollbar *\/$/;"	m	struct:GuiScrollbar
id	gui.h	/^    HWND	id;		    \/* Id of real scroll bar *\/$/;"	m	struct:GuiScrollbar
id	gui.h	/^    MenuHandle	id;$/;"	m	struct:GuiMenu
id	gui.h	/^    UINT	id;		    \/* Id of menu item *\/$/;"	m	struct:GuiMenu
id	gui.h	/^    VimScrollBar *id;		    \/* Pointer to real scroll bar *\/$/;"	m	struct:GuiScrollbar
id	gui.h	/^    Widget	id;		    \/* Id of real scroll bar *\/$/;"	m	struct:GuiScrollbar
id	gui.h	/^    Widget	id;		    \/* Manage this to enable item *\/$/;"	m	struct:GuiMenu
ident	gui.h	/^    long	ident;		    \/* Unique identifier for each scrollbar *\/$/;"	m	struct:GuiScrollbar
illegal_char	option.c	/^illegal_char(errbuf, c)$/;"	f	file:
in_cinkeys	edit.c	/^in_cinkeys(keytyped, when, line_is_empty)$/;"	f
in_focus	gui.h	/^    int		in_focus;	    \/* Vim has input focus *\/$/;"	m	struct:Gui
in_history	ex_getln.c	/^in_history(type, str, move_to_front)$/;"	f	file:
in_id_list	syntax.c	/^in_id_list(list, id, contained)$/;"	f	file:
in_use	gui.h	/^    int		in_use;		    \/* Is the GUI being used? *\/$/;"	m	struct:Gui
inbuf	ui.c	/^static char_u	inbuf[INBUFLEN + MAX_KEY_CODE_LEN];$/;"	v	file:
inbufcount	ui.c	/^static int	inbufcount = 0;	    \/* number of chars in inbuf[] *\/$/;"	v	file:
inc	misc2.c	/^inc(lp)$/;"	f
inc_cursor	misc2.c	/^inc_cursor()$/;"	f
inchar	getchar.c	/^inchar(buf, maxlen, wait_time)$/;"	f
incl	misc2.c	/^incl(lp)$/;"	f
include_groups	fileio.c	/^static int include_groups = FALSE;$/;"	v	file:
include_link	syntax.c	/^static int include_link = FALSE;	\/* include "link" for expansion *\/$/;"	v	file:
inclusive	structs.h	/^    int	    inclusive;		\/* TRUE if char motion is inclusive (only$/;"	m	struct:oparg
index	gui.h	/^    short	index;		    \/* the item index within the father menu *\/$/;"	m	struct:GuiMenu
indirect_options	option.c	/^enum indirect_options$/;"	g	file:
info_pointer	structs.h	/^struct info_pointer$/;"	s
info_t	structs.h	/^typedef struct m_info info_t;$/;"	t	typeref:struct:m_info
inindent	misc1.c	/^inindent(extra)$/;"	f
init_chartab	charset.c	/^init_chartab()$/;"	f
init_gui_options	option.c	/^init_gui_options()$/;"	f
init_highlight	syntax.c	/^init_highlight(both)$/;"	f
init_history	ex_getln.c	/^init_history()$/;"	f	file:
init_homedir	misc1.c	/^init_homedir()$/;"	f
init_syn_patterns	syntax.c	/^init_syn_patterns()$/;"	f	file:
init_typebuf	getchar.c	/^init_typebuf()$/;"	f	file:
init_yank	ops.c	/^init_yank()$/;"	f
initchr	regexp.c	/^initchr(str)$/;"	f	file:
initialised	if_python.c	/^static int initialised = 0;$/;"	v	file:
inmacro	search.c	/^inmacro(opt, s)$/;"	f	file:
ins_bs	edit.c	/^ins_bs(c, mode, inserted_space_p)$/;"	f	file:
ins_char	misc1.c	/^ins_char(c)$/;"	f
ins_complete	edit.c	/^ins_complete(c)$/;"	f	file:
ins_copychar	edit.c	/^ins_copychar(lnum)$/;"	f	file:
ins_ctrl_	edit.c	/^ins_ctrl_()$/;"	f	file:
ins_del	edit.c	/^ins_del()$/;"	f	file:
ins_digraph	edit.c	/^ins_digraph()$/;"	f	file:
ins_down	edit.c	/^ins_down()$/;"	f	file:
ins_end	edit.c	/^ins_end()$/;"	f	file:
ins_eol	edit.c	/^ins_eol(c)$/;"	f	file:
ins_esc	edit.c	/^ins_esc(count, need_redraw, cmdchar)$/;"	f	file:
ins_expand_pre	edit.c	/^ins_expand_pre(c)$/;"	f	file:
ins_home	edit.c	/^ins_home()$/;"	f	file:
ins_horscroll	edit.c	/^ins_horscroll()$/;"	f
ins_left	edit.c	/^ins_left()$/;"	f	file:
ins_mouse	edit.c	/^ins_mouse(c)$/;"	f	file:
ins_pagedown	edit.c	/^ins_pagedown()$/;"	f	file:
ins_pageup	edit.c	/^ins_pageup()$/;"	f	file:
ins_reg	edit.c	/^ins_reg()$/;"	f	file:
ins_right	edit.c	/^ins_right()$/;"	f	file:
ins_s_left	edit.c	/^ins_s_left()$/;"	f	file:
ins_s_right	edit.c	/^ins_s_right()$/;"	f	file:
ins_scroll	edit.c	/^ins_scroll()$/;"	f
ins_shift	edit.c	/^ins_shift(c, lastc)$/;"	f	file:
ins_str	misc1.c	/^ins_str(s)$/;"	f
ins_tab	edit.c	/^ins_tab()$/;"	f	file:
ins_try_si	edit.c	/^ins_try_si(c)$/;"	f	file:
ins_typebuf	getchar.c	/^ins_typebuf(str, noremap, offset, nottyped)$/;"	f
ins_up	edit.c	/^ins_up()$/;"	f	file:
insert_reg	ops.c	/^insert_reg(regname)$/;"	f
insert_special	edit.c	/^insert_special(c, allow_modmask, ctrlv)$/;"	f	file:
insertchar	edit.c	/^insertchar(c, force_formatting, second_indent, ctrlv)$/;"	f
int_u	vim.h	/^typedef unsigned int	int_u;$/;"	t
intr_char	globals.h	/^EXTERN int	intr_char INIT(= 0);	    \/* extra interrupt character *\/$/;"	v
intro_message	screen.c	/^intro_message()$/;"	f	file:
invalidate_botline	screen.c	/^invalidate_botline()$/;"	f
invalidate_botline_win	screen.c	/^invalidate_botline_win(wp)$/;"	f
invalidate_current_state	syntax.c	/^invalidate_current_state()$/;"	f	file:
invalidate_state	syntax.c	/^invalidate_state(sp)$/;"	f	file:
invert_gc	gui.h	/^    GC		invert_gc;$/;"	m	struct:Gui
ip_bnum	structs.h	/^    blocknr_t	ip_bnum;	\/* block number *\/$/;"	m	struct:info_pointer
ip_high	structs.h	/^    linenr_t	ip_high;	\/* highest lnum in this block *\/$/;"	m	struct:info_pointer
ip_index	structs.h	/^    int		ip_index;	\/* index for block with current lnum *\/$/;"	m	struct:info_pointer
ip_low	structs.h	/^    linenr_t	ip_low;		\/* lowest lnum in this block *\/$/;"	m	struct:info_pointer
is_VIsual	structs.h	/^    int	    is_VIsual;		\/* operator on Visual area *\/$/;"	m	struct:oparg
is_click	misc2.c	/^    int	    is_click;		\/* Is it a mouse button click event? *\/$/;"	m	struct:mousetable	file:
is_drag	misc2.c	/^    int	    is_drag;		\/* Is it a mouse drag event? *\/$/;"	m	struct:mousetable	file:
is_etag	tag.c	/^    int		is_etag;	\/* TRUE for emacs tag *\/$/;"	m	struct:tag_pointers	file:
istermoption	option.c	/^istermoption(p)$/;"	f	file:
ital_font	gui.h	/^    GuiFont	ital_font;$/;"	m	struct:Gui
jumpProc	gui_at_sb.h	/^    XtCallbackList jumpProc;	\/* same as thumbProc but pass data by ref *\/$/;"	m	struct:__anon16
jump_to_mouse	screen.c	/^jump_to_mouse(flags, inclusive)$/;"	f
jumpto_tag	tag.c	/^jumpto_tag(lbuf, forceit)$/;"	f	file:
keep_help_flag	globals.h	/^EXTERN int	keep_help_flag INIT(= FALSE); \/* doing :ta from help file *\/$/;"	v
keep_msg	globals.h	/^EXTERN char_u	*keep_msg INIT(= NULL);	    \/* msg to be shown after redraw *\/$/;"	v
keep_msg_attr	globals.h	/^EXTERN int	keep_msg_attr INIT(= 0);    \/* highlight attr for keep_msg *\/$/;"	v
key	misc2.c	/^    int	    key;	\/* Special key code or ascii value *\/$/;"	m	struct:key_name_entry	file:
key_extra	keymap.h	/^enum key_extra$/;"	g
key_name_entry	misc2.c	/^static struct key_name_entry$/;"	s	file:
key_names_table	misc2.c	/^} key_names_table[] =$/;"	v	typeref:struct:key_name_entry	file:
keyentry	structs.h	/^struct keyentry$/;"	s
keyword	structs.h	/^    char_u	    keyword[1];	\/* actually longer *\/$/;"	m	struct:keyentry
lalloc	misc2.c	/^lalloc(size, message)$/;"	f
lalloc_clear	misc2.c	/^lalloc_clear(size, message)$/;"	f
langmap_init	option.c	/^langmap_init()$/;"	f	file:
langmap_mapchar	globals.h	/^EXTERN char_u	langmap_mapchar[256];	\/* mapping for language keys *\/$/;"	v
langmap_set	option.c	/^langmap_set()$/;"	f	file:
last	fileio.c	/^    char	    last;		\/* last command in list *\/$/;"	m	struct:AutoCmd	file:
last	fileio.c	/^    char	    last;		\/* last pattern for apply_autocmds() *\/$/;"	m	struct:AutoPat	file:
last_cmdline	globals.h	/^EXTERN char_u	*last_cmdline INIT(= NULL); \/* last command line (for ":) *\/$/;"	v
last_event	fileio.c	/^static EVENT_T	last_event;$/;"	v	file:
last_group	fileio.c	/^static int	last_group;$/;"	v	file:
last_idx	search.c	/^static int last_idx = 0;	\/* index in spats[] for RE_LAST *\/$/;"	v	file:
last_insert	edit.c	/^static char_u	*last_insert = NULL;	\/* the text of the previous insert *\/$/;"	v	file:
last_insert_skip	edit.c	/^static int	last_insert_skip; \/* nr of chars in front of previous insert *\/$/;"	v	file:
last_matchgroup	syntax.c	/^static int  last_matchgroup;$/;"	v	file:
last_pat_prog	search.c	/^last_pat_prog()$/;"	f
last_recorded_len	getchar.c	/^static int	last_recorded_len = 0;	\/* number of last recorded chars *\/$/;"	v	file:
last_status	window.c	/^last_status()$/;"	f
lastbuf	globals.h	/^EXTERN BUF	*lastbuf INIT(= NULL);	\/* last buffer *\/$/;"	v
lasticon	buffer.c	/^static char_u *lasticon = NULL;$/;"	v	file:
lasttitle	buffer.c	/^static char_u *lasttitle = NULL;$/;"	v	file:
lastwin	globals.h	/^EXTERN WIN	*lastwin;	\/* last window *\/$/;"	v
lbr_chartabsize	charset.c	/^lbr_chartabsize(s, col)$/;"	f
left_sbar_x	gui.h	/^    int		left_sbar_x;	    \/* Calculated x coord for left scrollbar *\/$/;"	m	struct:Gui
leftcol_changed	misc2.c	/^leftcol_changed()$/;"	f
len	term.c	/^    int	    len;	    \/* STRLEN(code) *\/$/;"	m	struct:termcode	file:
length	gui_at_sb.h	/^    Dimension	  length;	\/* either height or width *\/$/;"	m	struct:__anon16
line	search.c	/^    int		line;		\/* search has line offset *\/$/;"	m	struct:soffset	file:
line1	ex_cmds.h	/^    linenr_t	line1;	    \/* the first line number *\/$/;"	m	struct:exarg
line2	ex_cmds.h	/^    linenr_t	line2;	    \/* the second line number or count *\/$/;"	m	struct:exarg
line_breakcheck	misc1.c	/^line_breakcheck()$/;"	f
line_count	structs.h	/^    long    line_count;		\/* number of lines from op_start to op_end$/;"	m	struct:oparg
lineclear	screen.c	/^lineclear(p)$/;"	f	file:
lineempty	macros.h	32;"	d
linelen	ex_cmds.c	/^linelen(has_tab)$/;"	f	file:
linenr_t	structs.h	/^typedef long		linenr_t;$/;"	t
linenr_t	vim.h	/^typedef long	    linenr_t;	    \/* line number type *\/$/;"	t
lines_left	globals.h	/^EXTERN int lines_left INIT(= -1);	\/* lines left for listing *\/$/;"	v
linetabsize	charset.c	/^linetabsize(s)$/;"	f
linewhite	search.c	/^linewhite(lnum)$/;"	f
list_one_var	eval.c	/^list_one_var(v, prefix)$/;"	f	file:
listdigraphs	digraph.c	/^listdigraphs()$/;"	f
lnum	search.c	/^    linenr_t	lnum;		\/* Line we were up to in file *\/$/;"	m	struct:SearchedFile	file:
lnum	structs.h	/^    linenr_t	    lnum;	    \/* line number *\/$/;"	m	struct:fpos
longVersion	version.c	/^char	*longVersion = VIM_VERSION_LONG;$/;"	v
longVersion	version.c	/^char	*longVersion = VIM_VERSION_LONG_DATE __DATE__ " " __TIME__ ")";$/;"	v
long_to_char	memline.c	/^long_to_char(n, s)$/;"	f	file:
long_u	vim.h	/^typedef unsigned long	long_u;$/;"	t
lowest_marked	memline.c	/^static linenr_t	lowest_marked = 0;$/;"	v	file:
lrF_sub	farsi.c	/^lrF_sub(ibuf)$/;"	f
lrFswap	farsi.c	/^*lrFswap(cmdbuf, len)$/;"	f
lrswap	farsi.c	/^*lrswap(ibuf)$/;"	f
lt	macros.h	21;"	d
ltoreq	macros.h	24;"	d
m_block	structs.h	/^struct m_block$/;"	s
m_info	structs.h	/^struct m_info$/;"	s
m_keylen	getchar.c	/^    int		     m_keylen;	    \/* strlen(m_keys) *\/$/;"	m	struct:mapblock	file:
m_keys	getchar.c	/^    char_u	    *m_keys;	    \/* mapped from *\/$/;"	m	struct:mapblock	file:
m_mode	getchar.c	/^    int		     m_mode;	    \/* valid mode *\/$/;"	m	struct:mapblock	file:
m_next	getchar.c	/^    struct mapblock *m_next;	    \/* next mapblock in list *\/$/;"	m	struct:mapblock	typeref:struct:mapblock::mapblock	file:
m_next	structs.h	/^    info_t  *m_next;	\/* pointer to next free chunk in the list *\/$/;"	m	struct:m_info
m_noremap	getchar.c	/^    int		     m_noremap;	    \/* if non-zero no re-mapping for m_str *\/$/;"	m	struct:mapblock	file:
m_size	structs.h	/^    long_u   m_size;	\/* size of the chunk (including m_info) *\/$/;"	m	struct:m_info
m_str	getchar.c	/^    char_u	    *m_str;	    \/* mapped to *\/$/;"	m	struct:mapblock	file:
magic	search.c	/^    int		    magic;	\/* magicness of the pattern *\/$/;"	m	struct:spat	file:
main	if_python.c	25;"	d	file:
main	main.c	/^main(argc, argv)$/;"	f
mainerr	main.c	/^mainerr(n, str)$/;"	f	file:
make_cyclic	edit.c	/^make_cyclic()$/;"	f	file:
make_windows	window.c	/^make_windows(count)$/;"	f
makemap	getchar.c	/^makemap(fd)$/;"	f
makeset	option.c	/^makeset(fd)$/;"	f
makeswapname	memline.c	/^makeswapname(buf, dir_name)$/;"	f	file:
maketitle	buffer.c	/^maketitle()$/;"	f
map_clear	getchar.c	/^map_clear(cmdp, forceit, abbr)$/;"	f
map_free	getchar.c	/^map_free(mpp)$/;"	f	file:
mapblock	getchar.c	/^struct mapblock$/;"	s	file:
maphash	getchar.c	/^static struct mapblock	*(maphash[256]);$/;"	v	typeref:struct:mapblock	file:
maphash_valid	getchar.c	/^static int		maphash_valid = FALSE;$/;"	v	file:
maptick	globals.h	/^EXTERN int	maptick INIT(= 0);	\/* tick for each non-mapped char *\/$/;"	v
mark	structs.h	/^    FPOS	    mark;	    \/* cursor position *\/$/;"	m	struct:filemark
mark_adjust	mark.c	/^mark_adjust(line1, line2, amount, amount_after)$/;"	f
matched	search.c	/^    int		matched;	\/* Found a match in this file *\/$/;"	m	struct:SearchedFile	file:
max	gui.h	/^    int		max;		    \/* Number of lines in buffer *\/$/;"	m	struct:GuiScrollbar
max	gui_at_sb.h	/^    float	  max;		\/* Maximum value for top *\/$/;"	m	struct:__anon16
may_core_dump	os_unix.c	/^may_core_dump()$/;"	f	file:
may_sync_undo	getchar.c	/^may_sync_undo()$/;"	f	file:
may_validate_crow	screen.c	/^may_validate_crow()$/;"	f
mb_info	structs.h	/^    info_t	    mb_info;	\/* head of free chuck list for this block *\/$/;"	m	struct:m_block
mb_next	structs.h	/^    struct m_block  *mb_next;	\/* pointer to next allocated block *\/$/;"	m	struct:m_block	typeref:struct:m_block::m_block
mch_FullName	os_unix.c	/^mch_FullName(fname, buf, len, force)$/;"	f
mch_avail_mem	os_unix.c	/^mch_avail_mem(special)$/;"	f
mch_breakcheck	os_unix.c	/^mch_breakcheck()$/;"	f
mch_call_shell	os_unix.c	/^mch_call_shell(cmd, options)$/;"	f
mch_can_restore_icon	os_unix.c	/^mch_can_restore_icon()$/;"	f
mch_can_restore_title	os_unix.c	/^mch_can_restore_title()$/;"	f
mch_char_avail	os_unix.c	/^mch_char_avail()$/;"	f
mch_check_win	os_unix.c	/^mch_check_win(argc, argv)$/;"	f
mch_delay	os_unix.c	/^mch_delay(msec, ignoreinput)$/;"	f
mch_dirname	os_unix.c	/^mch_dirname(buf, len)$/;"	f
mch_display_error	vim.h	852;"	d
mch_errmsg	vim.h	851;"	d
mch_expand_wildcards	os_unix.c	/^mch_expand_wildcards(num_pat, pat, num_file, file, flags)$/;"	f
mch_expandpath	os_unix.c	/^mch_expandpath(gap, path, flags)$/;"	f
mch_get_host_name	os_unix.c	/^mch_get_host_name(s, len)$/;"	f
mch_get_pid	os_unix.c	/^mch_get_pid()$/;"	f
mch_get_user_name	os_unix.c	/^mch_get_user_name(s, len)$/;"	f
mch_get_winsize	os_unix.c	/^mch_get_winsize()$/;"	f
mch_getperm	os_unix.c	/^mch_getperm(name)$/;"	f
mch_has_wildcard	os_unix.c	/^mch_has_wildcard(p)$/;"	f
mch_hide	os_unix.c	/^mch_hide(name)$/;"	f
mch_inchar	os_unix.c	/^mch_inchar(buf, maxlen, wtime)$/;"	f
mch_input_isatty	os_unix.c	/^mch_input_isatty()$/;"	f
mch_isFullName	os_unix.c	/^mch_isFullName(fname)$/;"	f
mch_isdir	os_unix.c	/^mch_isdir(name)$/;"	f
mch_restore_title	os_unix.c	/^mch_restore_title(which)$/;"	f
mch_screenmode	os_unix.c	/^mch_screenmode(arg)$/;"	f
mch_set_winsize	os_unix.c	/^mch_set_winsize()$/;"	f
mch_setmouse	os_unix.c	/^mch_setmouse(on)$/;"	f
mch_setperm	os_unix.c	/^mch_setperm(name, perm)$/;"	f
mch_settitle	os_unix.c	/^mch_settitle(title, icon)$/;"	f
mch_settmode	os_unix.c	/^mch_settmode(tmode)$/;"	f
mch_suspend	os_unix.c	/^mch_suspend()$/;"	f
mch_windexit	os_unix.c	/^mch_windexit(r)$/;"	f
mch_windinit	os_unix.c	/^mch_windinit()$/;"	f
mch_write	os_unix.c	/^mch_write(s, len)$/;"	f
mediumVersion	version.c	/^char	*mediumVersion = VIM_VERSION_MEDIUM;$/;"	v
memfile	structs.h	/^struct memfile$/;"	s
memline	structs.h	/^struct memline$/;"	s
menu_bg_pixel	gui.h	/^    GuiColor	menu_bg_pixel;	    \/* Color of menu backgound *\/$/;"	m	struct:Gui
menu_fg_pixel	gui.h	/^    GuiColor	menu_fg_pixel;	    \/* Color of menu foregound *\/$/;"	m	struct:Gui
menu_handle	gui.h	/^    MenuHandle	menu_handle;$/;"	m	struct:GuiMenu
menu_height	gui.h	/^    int		menu_height;	    \/* Height of the menu bar *\/$/;"	m	struct:Gui
menu_height_fixed	gui.h	/^    char	menu_height_fixed;  \/* TRUE if menu height fixed *\/$/;"	m	struct:Gui
menu_id	gui.h	/^    short	menu_id;	    \/* the menu id to which this item belong *\/$/;"	m	struct:GuiMenu
menu_is_active	gui.h	/^    char	menu_is_active;	    \/* TRUE if menu is present *\/$/;"	m	struct:Gui
menu_width	gui.h	/^    int		menu_width;	    \/* Width of the menu bar *\/$/;"	m	struct:Gui
messaging	screen.c	/^messaging()$/;"	f
mf_alloc_bhdr	memfile.c	/^mf_alloc_bhdr(mfp, page_count)$/;"	f	file:
mf_blocknr_max	structs.h	/^    blocknr_t	mf_blocknr_max;	    \/* highest positive block number + 1*\/$/;"	m	struct:memfile
mf_blocknr_min	structs.h	/^    blocknr_t	mf_blocknr_min;	    \/* lowest negative block number - 1 *\/$/;"	m	struct:memfile
mf_close	memfile.c	/^mf_close(mfp, del_file)$/;"	f
mf_dirty	structs.h	/^    int		mf_dirty;	    \/* Set to TRUE if there are dirty blocks *\/$/;"	m	struct:memfile
mf_do_open	memfile.c	/^mf_do_open(mfp, fname, trunc_file)$/;"	f	file:
mf_fd	structs.h	/^    int		mf_fd;		    \/* file descriptor *\/$/;"	m	struct:memfile
mf_ffname	structs.h	/^    char_u	*mf_ffname;	    \/* idem, full path *\/$/;"	m	struct:memfile
mf_find_hash	memfile.c	/^mf_find_hash(mfp, nr)$/;"	f	file:
mf_fname	structs.h	/^    char_u	*mf_fname;	    \/* name of the file *\/$/;"	m	struct:memfile
mf_free	memfile.c	/^mf_free(mfp, hp)$/;"	f
mf_free_bhdr	memfile.c	/^mf_free_bhdr(hp)$/;"	f	file:
mf_free_first	structs.h	/^    BHDR	*mf_free_first;	    \/* first block_hdr in free list *\/$/;"	m	struct:memfile
mf_fullname	memfile.c	/^mf_fullname(mfp)$/;"	f
mf_get	memfile.c	/^mf_get(mfp, nr, page_count)$/;"	f
mf_hash	structs.h	/^    BHDR	*mf_hash[MEMHASHSIZE];	\/* array of hash lists *\/$/;"	m	struct:memfile
mf_infile_count	structs.h	/^    blocknr_t	mf_infile_count;    \/* number of pages in the file *\/$/;"	m	struct:memfile
mf_ins_free	memfile.c	/^mf_ins_free(mfp, hp)$/;"	f	file:
mf_ins_hash	memfile.c	/^mf_ins_hash(mfp, hp)$/;"	f	file:
mf_ins_used	memfile.c	/^mf_ins_used(mfp, hp)$/;"	f	file:
mf_need_trans	memfile.c	/^mf_need_trans(mfp)$/;"	f
mf_neg_count	structs.h	/^    blocknr_t	mf_neg_count;	    \/* number of negative blocks numbers *\/$/;"	m	struct:memfile
mf_new	memfile.c	/^mf_new(mfp, negative, page_count)$/;"	f
mf_open	memfile.c	/^mf_open(fname, trunc_file)$/;"	f
mf_open_file	memfile.c	/^mf_open_file(mfp, fname)$/;"	f
mf_page_size	structs.h	/^    unsigned	mf_page_size;	    \/* number of bytes in a page *\/$/;"	m	struct:memfile
mf_put	memfile.c	/^mf_put(mfp, hp, dirty, infile)$/;"	f
mf_read	memfile.c	/^mf_read(mfp, hp)$/;"	f	file:
mf_release	memfile.c	/^mf_release(mfp, page_count)$/;"	f	file:
mf_release_all	memfile.c	/^mf_release_all()$/;"	f
mf_rem_free	memfile.c	/^mf_rem_free(mfp)$/;"	f	file:
mf_rem_hash	memfile.c	/^mf_rem_hash(mfp, hp)$/;"	f	file:
mf_rem_used	memfile.c	/^mf_rem_used(mfp, hp)$/;"	f	file:
mf_set_ffname	memfile.c	/^mf_set_ffname(mfp)$/;"	f
mf_sync	memfile.c	/^mf_sync(mfp, flags)$/;"	f
mf_trans	structs.h	/^    NR_TRANS	*mf_trans[MEMHASHSIZE];	\/* array of trans lists *\/$/;"	m	struct:memfile
mf_trans_add	memfile.c	/^mf_trans_add(mfp, hp)$/;"	f	file:
mf_trans_del	memfile.c	/^mf_trans_del(mfp, old_nr)$/;"	f
mf_used_count	structs.h	/^    unsigned	mf_used_count;	    \/* number of pages in used list *\/$/;"	m	struct:memfile
mf_used_count_max	structs.h	/^    unsigned	mf_used_count_max;  \/* maximum number of pages in memory *\/$/;"	m	struct:memfile
mf_used_first	structs.h	/^    BHDR	*mf_used_first;	    \/* mru block_hdr in used list *\/$/;"	m	struct:memfile
mf_used_last	structs.h	/^    BHDR	*mf_used_last;	    \/* lru block_hdr in used list *\/$/;"	m	struct:memfile
mf_write	memfile.c	/^mf_write(mfp, hp)$/;"	f	file:
min_rows	window.c	/^min_rows()$/;"	f
min_thumb	gui_at_sb.h	/^    Dimension	  min_thumb;	\/* minium size for the thumb. *\/$/;"	m	struct:__anon16
ml_add_stack	memline.c	/^ml_add_stack(buf)$/;"	f	file:
ml_append	memline.c	/^ml_append(lnum, line, len, newfile)$/;"	f
ml_append_int	memline.c	/^ml_append_int(buf, lnum, line, len, newfile)$/;"	f	file:
ml_clearmarked	memline.c	/^ml_clearmarked()$/;"	f
ml_close	memline.c	/^ml_close(buf, del_file)$/;"	f
ml_close_all	memline.c	/^ml_close_all(del_file)$/;"	f
ml_close_notmod	memline.c	/^ml_close_notmod()$/;"	f
ml_delete	memline.c	/^ml_delete(lnum, message)$/;"	f
ml_delete_int	memline.c	/^ml_delete_int(buf, lnum, message)$/;"	f	file:
ml_find_line	memline.c	/^ml_find_line(buf, lnum, action)$/;"	f	file:
ml_firstmarked	memline.c	/^ml_firstmarked()$/;"	f
ml_flags	structs.h	/^    int		ml_flags;$/;"	m	struct:memline
ml_flush_line	memline.c	/^ml_flush_line(buf)$/;"	f	file:
ml_get	memline.c	/^ml_get(lnum)$/;"	f
ml_get_buf	memline.c	/^ml_get_buf(buf, lnum, will_change)$/;"	f
ml_get_curline	memline.c	/^ml_get_curline()$/;"	f
ml_get_cursor	memline.c	/^ml_get_cursor()$/;"	f
ml_get_pos	memline.c	/^ml_get_pos(pos)$/;"	f
ml_has_mark	memline.c	/^ml_has_mark(lnum)$/;"	f
ml_line_alloced	memline.c	/^ml_line_alloced()$/;"	f
ml_line_count	structs.h	/^    linenr_t	ml_line_count;	\/* number of lines in the buffer *\/$/;"	m	struct:memline
ml_line_lnum	structs.h	/^    linenr_t	ml_line_lnum;	\/* line number of cached line, 0 if not valid *\/$/;"	m	struct:memline
ml_line_ptr	structs.h	/^    char_u	*ml_line_ptr;	\/* pointer to cached line *\/$/;"	m	struct:memline
ml_lineadd	memline.c	/^ml_lineadd(buf, count)$/;"	f	file:
ml_locked	structs.h	/^    BHDR	*ml_locked;	\/* block used by last ml_get *\/$/;"	m	struct:memline
ml_locked_high	structs.h	/^    linenr_t	ml_locked_high;	\/* last line in ml_locked *\/$/;"	m	struct:memline
ml_locked_lineadd	structs.h	/^    int		ml_locked_lineadd;  \/* number of lines inserted in ml_locked *\/$/;"	m	struct:memline
ml_locked_low	structs.h	/^    linenr_t	ml_locked_low;	\/* first line in ml_locked *\/$/;"	m	struct:memline
ml_mfp	structs.h	/^    MEMFILE	*ml_mfp;	\/* pointer to associated memfile *\/$/;"	m	struct:memline
ml_new_data	memline.c	/^ml_new_data(mfp, negative, page_count)$/;"	f	file:
ml_new_ptr	memline.c	/^ml_new_ptr(mfp)$/;"	f	file:
ml_open	memline.c	/^ml_open()$/;"	f
ml_open_file	memline.c	/^ml_open_file(buf)$/;"	f
ml_open_files	memline.c	/^ml_open_files()$/;"	f
ml_preserve	memline.c	/^ml_preserve(buf, message)$/;"	f
ml_recover	memline.c	/^ml_recover()$/;"	f
ml_replace	memline.c	/^ml_replace(lnum, line, copy)$/;"	f
ml_setmarked	memline.c	/^ml_setmarked(lnum)$/;"	f
ml_setname	memline.c	/^ml_setname()$/;"	f
ml_stack	structs.h	/^    IPTR	*ml_stack;	\/* stack of pointer blocks (array of IPTRs) *\/$/;"	m	struct:memline
ml_stack_size	structs.h	/^    int		ml_stack_size;	\/* total number of entries in ml_stack *\/$/;"	m	struct:memline
ml_stack_top	structs.h	/^    int		ml_stack_top;	\/* current top if ml_stack *\/$/;"	m	struct:memline
ml_sync_all	memline.c	/^ml_sync_all(check_file, check_char)$/;"	f
ml_timestamp	memline.c	/^ml_timestamp(buf)$/;"	f
mod_mask	globals.h	/^EXTERN int	mod_mask INIT(= 0x0);		\/* current key modifiers *\/$/;"	v
mod_mask	misc2.c	/^    int	    mod_mask;	    \/* Bit-mask for particular key modifier *\/$/;"	m	struct:modmasktable	file:
mod_mask_table	misc2.c	/^} mod_mask_table[] =$/;"	v	typeref:struct:modmasktable	file:
mode	vim.h	/^    short_u	mode;		    \/* Select by char, word, or line. *\/$/;"	m	struct:VimClipboard
modes	gui.h	/^    int		modes;		    \/* Which modes is this menu visible for? *\/$/;"	m	struct:GuiMenu
modified	globals.h	/^EXTERN int	modified INIT(= FALSE);		\/* buffer was modified since$/;"	v
modified_was_set	globals.h	/^EXTERN int	modified_was_set;		\/* did ":set modified" *\/$/;"	v
modmasktable	misc2.c	/^static struct modmasktable$/;"	s	file:
modname	fileio.c	/^modname(fname, ext, prepend_dot)$/;"	f
motion_type	structs.h	/^    int	    motion_type;	\/* type of the current cursor motion *\/$/;"	m	struct:oparg
mouse_col	globals.h	/^EXTERN int	mouse_col;$/;"	v
mouse_has	term.c	/^mouse_has(c)$/;"	f
mouse_past_bottom	globals.h	/^EXTERN int	mouse_past_bottom INIT(= FALSE);\/* mouse below last line *\/$/;"	v
mouse_past_eol	globals.h	/^EXTERN int	mouse_past_eol INIT(= FALSE);	\/* mouse right of line *\/$/;"	v
mouse_row	globals.h	/^EXTERN int	mouse_row;$/;"	v
mouse_table	misc2.c	/^} mouse_table[] =$/;"	v	typeref:struct:mousetable	file:
mousetable	misc2.c	/^static struct mousetable$/;"	s	file:
move_state	syntax.c	/^move_state(from, to)$/;"	f	file:
movemark	mark.c	/^movemark(count)$/;"	f
movetail	tag.c	2132;"	d	file:
mr_pattern	search.c	/^static char_u	    *mr_pattern = NULL;	\/* pattern used by search_regcomp() *\/$/;"	v	file:
msg	message.c	/^msg(s)$/;"	f
msg_add_eol	fileio.c	/^msg_add_eol()$/;"	f	file:
msg_add_fileformat	fileio.c	/^msg_add_fileformat(eol_type)$/;"	f	file:
msg_add_fname	fileio.c	/^msg_add_fname(buf, fname)$/;"	f	file:
msg_add_lines	fileio.c	/^msg_add_lines(insert_space, lnum, nchars)$/;"	f	file:
msg_advance	message.c	/^msg_advance(col)$/;"	f
msg_attr	message.c	/^msg_attr(s, attr)$/;"	f
msg_buf	globals.h	/^EXTERN char_u	msg_buf[MSG_BUF_LEN];	\/* small buffer for messages *\/$/;"	v
msg_check	message.c	/^msg_check()$/;"	f
msg_check_screen	message.c	/^msg_check_screen()$/;"	f	file:
msg_clr_eos	message.c	/^msg_clr_eos()$/;"	f
msg_col	globals.h	/^EXTERN int	msg_col;$/;"	v
msg_didany	globals.h	/^EXTERN int	msg_didany INIT(= FALSE);   \/* msg_outstr() was used at all *\/$/;"	v
msg_didout	globals.h	/^EXTERN int	msg_didout INIT(= FALSE);   \/* msg_outstr() was used in line *\/$/;"	v
msg_end	message.c	/^msg_end()$/;"	f
msg_home_replace	message.c	/^msg_home_replace(fname)$/;"	f
msg_home_replace_attr	message.c	/^msg_home_replace_attr(fname, attr)$/;"	f	file:
msg_home_replace_hl	message.c	/^msg_home_replace_hl(fname)$/;"	f
msg_make	message.c	/^msg_make(arg)$/;"	f
msg_moremsg	message.c	/^msg_moremsg(full)$/;"	f
msg_nowait	globals.h	/^EXTERN int	msg_nowait INIT(= FALSE);   \/* don't wait for this msg *\/$/;"	v
msg_outnum	message.c	/^msg_outnum(n)$/;"	f
msg_outtrans	message.c	/^msg_outtrans(str)$/;"	f
msg_outtrans_attr	message.c	/^msg_outtrans_attr(str, attr)$/;"	f
msg_outtrans_len	message.c	/^msg_outtrans_len(str, len)$/;"	f
msg_outtrans_len_attr	message.c	/^msg_outtrans_len_attr(str, len, attr)$/;"	f
msg_outtrans_special	message.c	/^msg_outtrans_special(str, all)$/;"	f
msg_prt_line	message.c	/^msg_prt_line(s)$/;"	f
msg_putchar	message.c	/^msg_putchar(c)$/;"	f
msg_puts	message.c	/^msg_puts(s)$/;"	f
msg_puts_attr	message.c	/^msg_puts_attr(s, attr)$/;"	f
msg_puts_title	message.c	/^msg_puts_title(s)$/;"	f
msg_row	globals.h	/^EXTERN int	msg_row;$/;"	v
msg_screen_putchar	message.c	/^msg_screen_putchar(c, attr)$/;"	f	file:
msg_scroll	globals.h	/^EXTERN int	msg_scroll INIT(= FALSE);   \/* msg_start() will scroll *\/$/;"	v
msg_scrolled	globals.h	/^EXTERN int	msg_scrolled;$/;"	v
msg_start	message.c	/^msg_start()$/;"	f
msg_trunc	message.c	/^msg_trunc(s)$/;"	f
msg_use_printf	message.c	/^msg_use_printf()$/;"	f	file:
msgmore	misc1.c	/^msgmore(n)$/;"	f
mt_names	tag.c	/^static char	*mt_names[MT_COUNT] =$/;"	v	file:
must_redraw	globals.h	/^EXTERN int	must_redraw INIT(= 0);	    \/* type of redraw necessary *\/$/;"	v
name	fileio.c	/^    char	*name;	    \/* event name *\/$/;"	m	struct:event_name	file:
name	gui.h	/^    char_u	*name;		    \/* Name shown in menu *\/$/;"	m	struct:GuiMenu
name	misc2.c	/^    char_u  *name;	\/* Name of key *\/$/;"	m	struct:key_name_entry	file:
name	misc2.c	/^    char_u  name;	    \/* Single letter name of modifier *\/$/;"	m	struct:modmasktable	file:
name	os_unix.c	/^    char    *name;	\/* Signal name (not char_u!). *\/$/;"	m	struct:signalinfo	file:
name	search.c	/^    char_u	*name;		\/* Full name of file *\/$/;"	m	struct:SearchedFile	file:
name	syntax.c	/^    char    *name;				\/* subcommand name *\/$/;"	m	struct:subcommand	file:
name	term.c	/^    char_u  name[2];	    \/* termcap name of entry *\/$/;"	m	struct:termcode	file:
name_to_mod_mask	misc2.c	/^name_to_mod_mask(c)$/;"	f
namedfm	mark.c	/^static struct filemark namedfm[NMARKS + EXTRA_MARKS];	\/* marks with file nr *\/$/;"	v	typeref:struct:filemark	file:
namedfm_names	mark.c	/^static char_u *namedfm_names[NMARKS + EXTRA_MARKS];	\/* name for namedfm[] *\/$/;"	v	file:
nchar	structs.h	/^    int	    nchar;	    \/* next character (optional) *\/$/;"	m	struct:cmdarg
need_check_timestamps	globals.h	/^EXTERN int	need_check_timestamps INIT(= FALSE); \/* got STOP signal *\/$/;"	v
need_clear_subexpr	regexp.c	/^static int	  need_clear_subexpr;	\/* *regstartp end *regendp still need$/;"	v	file:
need_fileinfo	globals.h	/^EXTERN int	need_fileinfo INIT(= FALSE);\/* do fileinfo() after redraw *\/$/;"	v
need_gather	term.c	/^static int	need_gather = FALSE;		\/* need to fill termleader[] *\/$/;"	v	file:
need_highlight_changed	globals.h	/^EXTERN int	need_highlight_changed INIT(= TRUE);$/;"	v
need_start_insertmode	globals.h	/^EXTERN int	need_start_insertmode INIT(= FALSE);$/;"	v
need_wait_return	globals.h	/^EXTERN int	need_wait_return INIT(= 0); \/* need to wait for return later *\/$/;"	v
nested	fileio.c	/^    char	    nested;		\/* If autocommands nest here *\/$/;"	m	struct:AutoCmd	file:
new_insert_skip	edit.c	/^static int	new_insert_skip;  \/* nr of chars in front of current insert *\/$/;"	v	file:
new_last_cmdline	globals.h	/^EXTERN char_u	*new_last_cmdline INIT(= NULL);	\/* new value for last_cmdline *\/$/;"	v
newline_on_exit	globals.h	/^EXTERN int	newline_on_exit INIT(= FALSE);	\/* did msg in altern. screen *\/$/;"	v
next	edit.c	/^    struct Completion	*next;$/;"	m	struct:Completion	typeref:struct:Completion::Completion	file:
next	fileio.c	/^    struct AutoCmd  *next;		\/* Next AutoCmd in list *\/$/;"	m	struct:AutoCmd	typeref:struct:AutoCmd::AutoCmd	file:
next	fileio.c	/^    struct AutoPat  *next;		\/* next AutoPat in AutoPat list *\/$/;"	m	struct:AutoPat	typeref:struct:AutoPat::AutoPat	file:
next	gui.h	/^    struct GuiMenu *next;	    \/* Next item in menu *\/$/;"	m	struct:GuiMenu	typeref:struct:GuiMenu::GuiMenu
next	quickfix.c	/^    struct eformat  *next;	    \/* pointer to next (NULL if last) *\/$/;"	m	struct:eformat	typeref:struct:eformat::eformat	file:
next	structs.h	/^    struct keyentry *next;	\/* next keyword in the hash list *\/$/;"	m	struct:keyentry	typeref:struct:keyentry::keyentry
next_buf	edit.c	/^next_buf(buf, flag)$/;"	f	file:
next_list	structs.h	/^    short	    *next_list;	\/* ID list for next match (if non-zero) *\/$/;"	m	struct:keyentry
next_match_col	syntax.c	/^static int next_match_col;	    \/* column for start of next match *\/$/;"	v	file:
next_match_end_idx	syntax.c	/^static int next_match_end_idx;	    \/* ID of group for end pattern or zero *\/$/;"	v	file:
next_match_eoe_col	syntax.c	/^static int next_match_eoe_col;	    \/* column for end of end pattern *\/$/;"	v	file:
next_match_eos_col	syntax.c	/^static int next_match_eos_col;	    \/* column for end of start pattern *\/$/;"	v	file:
next_match_flags	syntax.c	/^static int next_match_flags;	    \/* flags for next match *\/$/;"	v	file:
next_match_h_endcol	syntax.c	/^static int next_match_h_endcol;	    \/* column for highl. end of next match *\/$/;"	v	file:
next_match_h_startcol	syntax.c	/^static int next_match_h_startcol;   \/* column for highl. start of next match *\/$/;"	v	file:
next_match_idx	syntax.c	/^static int next_match_idx;	    \/* index of matched item *\/$/;"	v	file:
next_match_m_endcol	syntax.c	/^static int next_match_m_endcol;	    \/* column for end of next match *\/$/;"	v	file:
nextchr	regexp.c	/^static int	nextchr;    \/* used for ungetchr() *\/$/;"	v	file:
nextcmd	ex_cmds.h	/^    char_u	*nextcmd;   \/* next command (NULL if none) *\/$/;"	m	struct:exarg
nextcmd	fileio.c	/^    AutoCmd	*nextcmd;	\/* next AutoCmd to execute *\/$/;"	m	struct:AutoPatCmd	file:
nextwild	ex_getln.c	/^nextwild(type)$/;"	f	file:
no_abbr	globals.h	/^EXTERN int	no_abbr INIT(= TRUE);	\/* TRUE when no abbreviations loaded *\/$/;"	v
no_abbr_cnt	getchar.c	/^static int	no_abbr_cnt = 0;    \/* nr of chars without abbrev. in typebuf *\/$/;"	v	file:
no_lines_msg	globals.h	/^EXTERN char_u no_lines_msg[]	    INIT(="--No lines in buffer--");$/;"	v
no_mapping	globals.h	/^EXTERN int	no_mapping INIT(= FALSE);   \/* currently no mapping allowed *\/$/;"	v
no_scs	search.c	/^    int		    no_scs;	\/* no smarcase for this pattern *\/$/;"	m	struct:spat	file:
no_smartcase	globals.h	/^EXTERN int	no_smartcase INIT(= FALSE);	\/* don't use 'smartcase' once *\/$/;"	v
no_u_sync	globals.h	/^EXTERN int	no_u_sync INIT(= 0);	\/* Don't call u_sync() *\/$/;"	v
no_viminfo	ex_cmds.c	/^no_viminfo()$/;"	f	file:
no_wait_return	globals.h	/^EXTERN int	no_wait_return INIT(= 0);   \/* don't wait for return now *\/$/;"	v
nofile_fname	tag.c	/^static char_u	*nofile_fname = NULL;	\/* fname for NOTAGFILE error *\/$/;"	v	file:
noremap	gui.h	/^    int		noremap[MENU_MODES]; \/* A noremap flag for each mode *\/$/;"	m	struct:GuiMenu
noremapbuf	getchar.c	/^static char_u	*noremapbuf = NULL;	  \/* flags for typeahead characters *\/$/;"	v	file:
noremapbuf_init	getchar.c	/^static char_u	noremapbuf_init[TYPELEN_INIT];	    \/* initial noremapbuf *\/$/;"	v	file:
norm_font	gui.h	/^    GuiFont	norm_font;$/;"	m	struct:Gui
norm_pixel	gui.h	/^    GuiColor	norm_pixel;	    \/* Color of normal text *\/$/;"	m	struct:Gui
normal_cmd	normal.c	/^normal_cmd(oap, toplevel)$/;"	f
not_exiting	ex_docmd.c	/^not_exiting()$/;"	f
nr_trans	structs.h	/^struct nr_trans$/;"	s
nt_new_bnum	structs.h	/^    blocknr_t	nt_new_bnum;		\/* new, positive, number *\/$/;"	m	struct:nr_trans
nt_next	structs.h	/^    NR_TRANS	*nt_next;	    \/* next nr_trans in hash list *\/$/;"	m	struct:nr_trans
nt_old_bnum	structs.h	/^    blocknr_t	nt_old_bnum;		\/* old, negative, number *\/$/;"	m	struct:nr_trans
nt_prev	structs.h	/^    NR_TRANS	*nt_prev;	    \/* previous nr_trans in hash list *\/$/;"	m	struct:nr_trans
num_chars	getchar.c	/^int num_chars = 0;$/;"	v
num_cols	gui.h	/^    int		num_cols;	    \/* Number of columns *\/$/;"	m	struct:Gui
num_complex_braces	regexp.c	/^static int	num_complex_braces; \/* Complex \\{...} count *\/$/;"	v	file:
num_rows	gui.h	/^    int		num_rows;	    \/* Number of rows *\/$/;"	m	struct:Gui
oap	structs.h	/^    OPARG   *oap;	    \/* Operator arguments *\/$/;"	m	struct:cmdarg
off	search.c	/^    long	off;		\/* line or char offset *\/$/;"	m	struct:soffset	file:
off	search.c	/^    struct soffset  off;$/;"	m	struct:spat	typeref:struct:spat::soffset	file:
old_char	getchar.c	/^static int old_char = -1;	\/* ungotten character *\/$/;"	v	file:
old_fn	if_python.c	/^static writefn old_fn = NULL;$/;"	v	file:
old_indent	edit.c	/^static int	old_indent = 0;		\/* for ^^D command in insert mode *\/$/;"	v	file:
old_redobuff	getchar.c	/^static struct buffheader old_redobuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
old_showcmd_buf	normal.c	/^static char_u	old_showcmd_buf[SHOWCMD_COLS + 1];  \/* For push_showcmd() *\/$/;"	v	file:
old_sub	ex_cmds.c	/^static char_u	    *old_sub = NULL;	\/* previous substitute pattern *\/$/;"	v	file:
oldicon	os_unix.c	/^static char_u	*oldicon = NULL;$/;"	v	file:
oldtitle	os_unix.c	/^static char_u	*oldtitle = NULL;$/;"	v	file:
one_adjust	mark.c	510;"	d	file:
one_adjust_nodel	mark.c	525;"	d	file:
oneleft	edit.c	/^oneleft()$/;"	f
onepage	screen.c	/^onepage(dir, count)$/;"	f
oneright	edit.c	/^oneright()$/;"	f
only_one_window	window.c	/^only_one_window()$/;"	f
op_change	ops.c	/^op_change(oap)$/;"	f
op_chars	normal.c	/^static char_u *op_chars = (char_u *)"dyc<>!~=Q:UuJq";$/;"	v	file:
op_colon	normal.c	/^op_colon(oap, VIsual_was_active)$/;"	f	file:
op_delete	ops.c	/^op_delete(oap)$/;"	f
op_format	ops.c	/^op_format(oap)$/;"	f
op_prechar	structs.h	/^    int	    op_prechar;		\/* optional character before operator command *\/$/;"	m	struct:oparg
op_reindent	ops.c	/^op_reindent(oap, how)$/;"	f
op_shift	ops.c	/^op_shift(oap, curs_top, amount)$/;"	f
op_tilde	ops.c	/^op_tilde(oap)$/;"	f
op_type	structs.h	/^    int	    op_type;		\/* current pending operator type *\/$/;"	m	struct:oparg
op_yank	ops.c	/^op_yank(oap, deleting, mess)$/;"	f
oparg	structs.h	/^typedef struct oparg$/;"	s
open_buffer	buffer.c	/^open_buffer(read_stdin)$/;"	f
open_exfile	ex_docmd.c	/^open_exfile(eap, mode)$/;"	f	file:
open_line	misc1.c	/^open_line(dir, redraw, del_spaces, old_indent)$/;"	f
openscript	getchar.c	/^openscript(name)$/;"	f
option_expand	option.c	/^option_expand(opt_idx)$/;"	f	file:
option_not_default	option.c	/^option_not_default(p)$/;"	f	file:
option_value2string	option.c	/^option_value2string(opp)$/;"	f	file:
options	option.c	/^static struct vimoption options[] =$/;"	v	typeref:struct:vimoption	file:
orientation	gui_at_sb.h	/^    XtOrientation orientation;	\/* horizontal or vertical *\/$/;"	m	struct:__anon16
origin_end_col	vim.h	/^    short_u	origin_end_col;$/;"	m	struct:VimClipboard
origin_row	vim.h	/^    short_u	origin_row;$/;"	m	struct:VimClipboard
origin_start_col	vim.h	/^    short_u	origin_start_col;$/;"	m	struct:VimClipboard
original	edit.c	/^    int			original; \/* ORIGINAL_TEXT, CONT_S_IPOS or FREE_FNAME *\/$/;"	m	struct:Completion	file:
original_text	edit.c	/^static char_u		    *original_text = NULL;  \/* text before completion *\/$/;"	v	file:
ospeed	term.c	/^short ospeed;$/;"	v
otherfile	buffer.c	/^otherfile(fname)$/;"	f
out_buf	term.c	/^static char_u		out_buf[OUT_SIZE + 1];$/;"	v	file:
out_char	term.c	/^out_char(c)$/;"	f
out_char_nf	term.c	/^out_char_nf(c)$/;"	f	file:
out_flush	term.c	/^out_flush()$/;"	f
out_pos	term.c	/^static int		out_pos = 0;	\/* number of chars in out_buf *\/$/;"	v	file:
out_str	term.c	/^out_str(s)$/;"	f
out_str_nf	term.c	/^out_str_nf(s)$/;"	f
out_trash	term.c	/^out_trash()$/;"	f
overstrike	ex_getln.c	/^    int	     overstrike;    \/* Typing mode on the command line.  Shared by$/;"	m	struct:cmdline_info	file:
owned	vim.h	/^    int		owned;		    \/* Flag: do we own the selection? *\/$/;"	m	struct:VimClipboard
p_aleph	option.h	/^EXTERN int	p_aleph;	\/* Hebrew 'Aleph' encoding *\/$/;"	v
p_altkeymap	option.h	/^EXTERN int	p_altkeymap;	\/* alternative keyboard map Hebrew\/Farsi *\/$/;"	v
p_aw	option.h	/^EXTERN int	p_aw;		\/* auto-write *\/$/;"	v
p_bdir	option.h	/^EXTERN char_u  *p_bdir;		\/* list of directory names for backup files *\/$/;"	v
p_bex	option.h	/^EXTERN char_u  *p_bex;		\/* extension for backup file *\/$/;"	v
p_bg	option.h	/^EXTERN char_u  *p_bg;		\/* window background color: light or dark *\/$/;"	v
p_bg_values	option.c	/^static char *(p_bg_values[]) = {"light", "dark", NULL};$/;"	v	file:
p_biosk	option.h	/^EXTERN int	p_biosk;	\/* Use bioskey() instead of kbhit() *\/$/;"	v
p_bk	option.h	/^EXTERN int	p_bk;		\/* make backups when writing out files *\/$/;"	v
p_breakat	option.h	/^EXTERN char_u  *p_breakat;	\/* characters that can cause a line break *\/$/;"	v
p_bs	option.h	/^EXTERN long	p_bs;		\/* backspace over newlines in insert mode *\/$/;"	v
p_ch	option.h	/^EXTERN long	p_ch;		\/* command line height *\/$/;"	v
p_cp	option.h	/^EXTERN int	p_cp;		\/* vi-compatible *\/$/;"	v
p_cpo	option.h	/^EXTERN char_u  *p_cpo;		\/* vi-compatible option flags *\/$/;"	v
p_def	option.h	/^EXTERN char_u  *p_def;		\/* Pattern for recognising definitions *\/$/;"	v
p_dg	option.h	/^EXTERN int	p_dg;		\/* enable digraphs *\/$/;"	v
p_dict	option.h	/^EXTERN char_u  *p_dict;		\/* Dictionaries for ^P\/^N *\/$/;"	v
p_dir	option.h	/^EXTERN char_u	*p_dir;		\/* list of directories for swap file *\/$/;"	v
p_ea	option.h	/^EXTERN int	p_ea;		\/* make windows equal height *\/$/;"	v
p_eb	option.h	/^EXTERN int	p_eb;		\/* ring bell for errors *\/$/;"	v
p_ed	option.h	/^EXTERN int	p_ed;		\/* :s is ed compatible *\/$/;"	v
p_ef	option.h	/^EXTERN char_u  *p_ef;		\/* name of errorfile *\/$/;"	v
p_efm	option.h	/^EXTERN char_u  *p_efm;		\/* error format *\/$/;"	v
p_ei	option.h	/^EXTERN char_u  *p_ei;		\/* events ignored for autocommands *\/$/;"	v
p_ek	option.h	/^EXTERN int	p_ek;		\/* function keys with ESC in insert mode *\/$/;"	v
p_ep	option.h	/^EXTERN char_u	*p_ep;		\/* program name for '=' command *\/$/;"	v
p_exrc	option.h	/^EXTERN int	p_exrc;		\/* read .exrc in current dir *\/$/;"	v
p_ff_values	option.c	/^static char *(p_ff_values[]) = {FF_UNIX, FF_DOS, FF_MAC, NULL};$/;"	v	file:
p_ffs	option.h	/^EXTERN char_u  *p_ffs;		\/* acceptable file formats *\/$/;"	v
p_fkmap	option.h	/^EXTERN int	p_fkmap;	\/* Farsi keyboard map *\/$/;"	v
p_fp	option.h	/^EXTERN char_u  *p_fp;		\/* name of format program *\/$/;"	v
p_gd	option.h	/^EXTERN int	p_gd;		\/* \/g is default for :s *\/$/;"	v
p_guicursor	option.h	/^EXTERN char_u  *p_guicursor;	\/* shape settings for cursor *\/$/;"	v
p_guifont	option.h	/^EXTERN char_u  *p_guifont;	\/* GUI font list *\/$/;"	v
p_guioptions	option.h	/^EXTERN char_u  *p_guioptions;	\/* Which GUI components? *\/$/;"	v
p_guipty	option.h	/^EXTERN int	p_guipty;	\/* use pseudo pty for external commands *\/$/;"	v
p_hf	option.h	/^EXTERN char_u  *p_hf;		\/* name of help file *\/$/;"	v
p_hh	option.h	/^EXTERN long	p_hh;		\/* help window height *\/$/;"	v
p_hi	option.h	/^EXTERN long	p_hi;		\/* command line history size *\/$/;"	v
p_hid	option.h	/^EXTERN int	p_hid;		\/* buffers can be hidden *\/$/;"	v
p_hkmap	option.h	/^EXTERN int	p_hkmap;	\/* Hebrew keyboard map *\/$/;"	v
p_hkmapp	option.h	/^EXTERN int	p_hkmapp;	\/* idem, phonetic *\/$/;"	v
p_hl	option.h	/^EXTERN char_u  *p_hl;		\/* which highlight mode to use *\/$/;"	v
p_hls	option.h	/^EXTERN int	p_hls;		\/* highlight matches with last search pattern *\/$/;"	v
p_ic	option.h	/^EXTERN int	p_ic;		\/* ignore case in searches *\/$/;"	v
p_icon	option.h	/^EXTERN int	p_icon;		\/* put file name in icon if possible *\/$/;"	v
p_iconstring	option.h	/^EXTERN char_u  *p_iconstring;	\/* icon string *\/$/;"	v
p_im	option.h	/^EXTERN int	p_im;		\/* start editing in input mode *\/$/;"	v
p_inc	option.h	/^EXTERN char_u  *p_inc;		\/* Pattern for including other files *\/$/;"	v
p_is	option.h	/^EXTERN int	p_is;		\/* incremental search *\/$/;"	v
p_isf	option.h	/^EXTERN char_u  *p_isf;		\/* characters in a file name *\/$/;"	v
p_isi	option.h	/^EXTERN char_u  *p_isi;		\/* characters in an identifier *\/$/;"	v
p_isp	option.h	/^EXTERN char_u  *p_isp;		\/* characters that are printable *\/$/;"	v
p_js	option.h	/^EXTERN int	p_js;		\/* use two spaces after '.' with Join *\/$/;"	v
p_kp	option.h	/^EXTERN char_u  *p_kp;		\/* keyword program *\/$/;"	v
p_langmap	option.h	/^EXTERN char_u  *p_langmap;	\/* mapping for some language *\/$/;"	v
p_ls	option.h	/^EXTERN long	p_ls;		\/* last window has status line *\/$/;"	v
p_lz	option.h	/^EXTERN int	p_lz;		\/* lazy redraw, only when key typed *\/$/;"	v
p_magic	option.h	/^EXTERN int	p_magic;	\/* use some characters for reg exp *\/$/;"	v
p_mat	option.h	/^EXTERN long	p_mat;		\/* time to show the match of a paren *\/$/;"	v
p_mef	option.h	/^EXTERN char_u  *p_mef;		\/* name of make errorfile *\/$/;"	v
p_mh	option.h	/^EXTERN int	p_mh;		\/* hide pointer enable *\/$/;"	v
p_mls	option.h	/^EXTERN long	p_mls;		\/* number of mode lines *\/$/;"	v
p_mm	option.h	/^EXTERN long	p_mm;		\/* maximal amount of memory for buffer *\/$/;"	v
p_mmd	option.h	/^EXTERN long	p_mmd;		\/* maximal map depth *\/$/;"	v
p_mmt	option.h	/^EXTERN long	p_mmt;		\/* maximal amount of memory for Vim *\/$/;"	v
p_more	option.h	/^EXTERN int	p_more;		\/* wait when screen full when listing *\/$/;"	v
p_mouse	option.h	/^EXTERN char_u  *p_mouse;	\/* enable mouse clicks (for xterm) *\/$/;"	v
p_mouset	option.h	/^EXTERN long	p_mouset;	\/* mouse double click time *\/$/;"	v
p_mp	option.h	/^EXTERN char_u  *p_mp;		\/* program for :make command *\/$/;"	v
p_nf_values	option.c	/^static char *(p_nf_values[]) = {"octal", "hex", NULL};$/;"	v	file:
p_para	option.h	/^EXTERN char_u  *p_para;		\/* paragraphs *\/$/;"	v
p_paste	option.h	/^EXTERN int	p_paste;	\/* paste mode *\/$/;"	v
p_path	option.h	/^EXTERN char_u  *p_path;		\/* path for "]f" and "^Wf" *\/$/;"	v
p_pm	option.h	/^EXTERN char_u  *p_pm;		\/* patchmode file suffix *\/$/;"	v
p_remap	option.h	/^EXTERN int	p_remap;	\/* remap *\/$/;"	v
p_report	option.h	/^EXTERN long	p_report;	\/* minimum number of lines for report *\/$/;"	v
p_ri	option.h	/^EXTERN int	p_ri;		\/* reverse direction of insert *\/$/;"	v
p_rs	option.h	/^EXTERN int	p_rs;		\/* restore startup screen upon exit *\/$/;"	v
p_ru	option.h	/^EXTERN int	p_ru;		\/* show column\/line number *\/$/;"	v
p_sb	option.h	/^EXTERN int	p_sb;		\/* split window backwards *\/$/;"	v
p_sbr	option.h	/^EXTERN char_u  *p_sbr;		\/* string for break of line *\/$/;"	v
p_sc	option.h	/^EXTERN int	p_sc;		\/* show command in status line *\/$/;"	v
p_scs	option.h	/^EXTERN int	p_scs;		\/* 'smartcase' *\/$/;"	v
p_sections	option.h	/^EXTERN char_u  *p_sections;	\/* sections *\/$/;"	v
p_secure	option.h	/^EXTERN int	p_secure;	\/* do .exrc and .vimrc in secure mode *\/$/;"	v
p_sh	option.h	/^EXTERN char_u  *p_sh;		\/* name of shell to use *\/$/;"	v
p_shcf	option.h	/^EXTERN char_u  *p_shcf;		\/* flag to shell to execute one command *\/$/;"	v
p_shm	option.h	/^EXTERN char_u  *p_shm;		\/* When to use short message *\/$/;"	v
p_shq	option.h	/^EXTERN char_u  *p_shq;		\/* quote character(s) for shell *\/$/;"	v
p_sj	option.h	/^EXTERN long	p_sj;		\/* scroll jump size *\/$/;"	v
p_sm	option.h	/^EXTERN int	p_sm;		\/* showmatch *\/$/;"	v
p_smd	option.h	/^EXTERN int	p_smd;		\/* show mode *\/$/;"	v
p_so	option.h	/^EXTERN long	p_so;		\/* scroll offset *\/$/;"	v
p_sol	option.h	/^EXTERN int	p_sol;		\/* Move cursor to start-of-line? *\/$/;"	v
p_sp	option.h	/^EXTERN char_u  *p_sp;		\/* string for output of make *\/$/;"	v
p_sr	option.h	/^EXTERN int	p_sr;		\/* shift round off (for < and >) *\/$/;"	v
p_srr	option.h	/^EXTERN char_u  *p_srr;		\/* string for output of filter *\/$/;"	v
p_ss	option.h	/^EXTERN long	p_ss;		\/* sideways scrolling offset *\/$/;"	v
p_st	option.h	/^EXTERN long	p_st;		\/* type of shell *\/$/;"	v
p_sta	option.h	/^EXTERN int	p_sta;		\/* smart-tab for expand-tab *\/$/;"	v
p_su	option.h	/^EXTERN char_u  *p_su;		\/* suffixes for wildcard expansion *\/$/;"	v
p_sws	option.h	/^EXTERN char_u  *p_sws;		\/* swap file syncing *\/$/;"	v
p_sxq	option.h	/^EXTERN char_u  *p_sxq;		\/* quote around redirection for shell *\/$/;"	v
p_ta	option.h	/^EXTERN int	p_ta;		\/* auto textmode detection *\/$/;"	v
p_tags	option.h	/^EXTERN char_u  *p_tags;		\/* tags search path *\/$/;"	v
p_tbi	option.h	/^EXTERN int	p_tbi;		\/* 'ttybuiltin' use builtin termcap first *\/$/;"	v
p_tbs	option.h	/^EXTERN int	p_tbs;		\/* tag binary search *\/$/;"	v
p_term	option.c	916;"	d	file:
p_terse	option.h	/^EXTERN int	p_terse;	\/* terse messages *\/$/;"	v
p_tf	option.h	/^EXTERN int	p_tf;		\/* terminal fast I\/O *\/$/;"	v
p_timeout	option.h	/^EXTERN int	p_timeout;	\/* mappings entered within one second *\/$/;"	v
p_title	option.h	/^EXTERN int	p_title;	\/* set window title if possible *\/$/;"	v
p_titlelen	option.h	/^EXTERN long	p_titlelen;	\/* length of window title in % of Columns *\/$/;"	v
p_titlestring	option.h	/^EXTERN char_u  *p_titlestring;	\/* window title string *\/$/;"	v
p_tl	option.h	/^EXTERN long	p_tl;		\/* used tag length *\/$/;"	v
p_tm	option.h	/^EXTERN long	p_tm;		\/* timeoutlen (msec) *\/$/;"	v
p_to	option.h	/^EXTERN int	p_to;		\/* tilde is an operator *\/$/;"	v
p_tr	option.h	/^EXTERN int	p_tr;		\/* tag file name is relative *\/$/;"	v
p_ttimeout	option.h	/^EXTERN int	p_ttimeout;	\/* key codes entered within one second *\/$/;"	v
p_ttm	option.h	/^EXTERN long	p_ttm;		\/* key code timeoutlen (msec) *\/$/;"	v
p_ttyscroll	option.h	/^EXTERN long	p_ttyscroll;	\/* maximum nr of screen lines for a scroll *\/$/;"	v
p_uc	option.h	/^EXTERN long	p_uc;		\/* update count for swap file *\/$/;"	v
p_ul	option.h	/^EXTERN long	p_ul;		\/* number of Undo Levels *\/$/;"	v
p_ut	option.h	/^EXTERN long	p_ut;		\/* update time for swap file *\/$/;"	v
p_vb	option.h	/^EXTERN int	p_vb;		\/* visual bell only (no beep) *\/$/;"	v
p_verbose	option.h	/^EXTERN long	p_verbose;	\/* verbosity, -V command line argument *\/$/;"	v
p_viminfo	option.h	/^EXTERN char_u  *p_viminfo;	\/* Parameters for using ~\/.viminfo file *\/$/;"	v
p_wa	option.h	/^EXTERN int	p_wa;		\/* write any *\/$/;"	v
p_warn	option.h	/^EXTERN int	p_warn;		\/* warn for changes at shell command *\/$/;"	v
p_wb	option.h	/^EXTERN int	p_wb;		\/* write backup files *\/$/;"	v
p_wc	option.h	/^EXTERN long	p_wc;		\/* character for wildcard exapansion *\/$/;"	v
p_wd	option.h	/^EXTERN long	p_wd;		\/* write delay for screen output (for tests) *\/$/;"	v
p_wh	option.h	/^EXTERN long	p_wh;		\/* desired window height *\/$/;"	v
p_wiv	option.h	/^EXTERN int	p_wiv;		\/* inversion of text is weird *\/$/;"	v
p_ws	option.h	/^EXTERN int	p_ws;		\/* wrap scan *\/$/;"	v
p_ww	option.h	/^EXTERN char_u  *p_ww;		\/* which keys wrap to next\/prev line *\/$/;"	v
parse_builtin_tcap	term.c	/^parse_builtin_tcap(term)$/;"	f	file:
parse_match	tag.c	/^parse_match(lbuf, tagp)$/;"	f	file:
parse_tag_line	tag.c	/^parse_tag_line(lbuf,$/;"	f	file:
paste_option_changed	option.c	/^paste_option_changed()$/;"	f	file:
pat	fileio.c	/^    char_u	    *pat;		\/* pattern as typed (NULL when pattern$/;"	m	struct:AutoPat	file:
pat	search.c	/^    char_u	    *pat;	\/* the pattern (in allocated memory) or NULL *\/$/;"	m	struct:spat	file:
path_is_url	window.c	/^path_is_url(p)$/;"	f	file:
pb_count	memline.c	/^    short_u	pb_count;	\/* number of pointer in this block *\/$/;"	m	struct:pointer_block	file:
pb_count_max	memline.c	/^    short_u	pb_count_max;	\/* maximum value for pb_count *\/$/;"	m	struct:pointer_block	file:
pb_id	memline.c	/^    short_u	pb_id;		\/* ID for pointer block: PTR_ID *\/$/;"	m	struct:pointer_block	file:
pb_pointer	memline.c	/^    PTR_EN	pb_pointer[1];	\/* list of pointers to blocks (actually longer)$/;"	m	struct:pointer_block	file:
pchar	macros.h	16;"	d
pchar_cursor	misc1.c	/^pchar_cursor(c)$/;"	f
pe_bnum	memline.c	/^    blocknr_t	pe_bnum;	\/* block number *\/$/;"	m	struct:pointer_entry	file:
pe_line_count	memline.c	/^    linenr_t	pe_line_count;	\/* number of lines in this branch *\/$/;"	m	struct:pointer_entry	file:
pe_old_lnum	memline.c	/^    linenr_t	pe_old_lnum;	\/* lnum for this block (for recovery) *\/$/;"	m	struct:pointer_entry	file:
pe_page_count	memline.c	/^    int		pe_page_count;	\/* number of pages in block pe_bnum *\/$/;"	m	struct:pointer_entry	file:
peekchr	regexp.c	/^peekchr()$/;"	f	file:
perl_private	structs.h	/^    void	    *perl_private;$/;"	m	struct:buffer
perl_private	structs.h	/^    void	    *perl_private;$/;"	m	struct:window
plines	misc1.c	/^plines(p)$/;"	f
plines_m	misc1.c	/^plines_m(first, last)$/;"	f
plines_m_win	misc1.c	/^plines_m_win(wp, first, last)$/;"	f
plines_win	misc1.c	/^plines_win(wp, p)$/;"	f
plines_win_col	misc1.c	/^plines_win_col(wp, p, column)$/;"	f
plural	misc1.c	/^plural(n)$/;"	f
pointer_block	memline.c	/^struct pointer_block$/;"	s	file:
pointer_entry	memline.c	/^struct pointer_entry$/;"	s	file:
pointer_hidden	gui.h	/^    int		pointer_hidden;	    \/* Is the mouse pointer hidden? *\/$/;"	m	struct:Gui
pop_current	syntax.c	/^pop_current()$/;"	f	file:
pop_showcmd	normal.c	/^pop_showcmd()$/;"	f
postponed_split	globals.h	/^EXTERN int	postponed_split INIT(= 0);  \/* for CTRL-W CTRL-] command *\/$/;"	v
prechar	structs.h	/^    int	    prechar;	    \/* prefix character (optional, always 'g') *\/$/;"	m	struct:cmdarg
prep_redo	normal.c	/^prep_redo(regname, num, prechar, cmd, c, nchar)$/;"	f	file:
prep_redo_cmd	normal.c	/^prep_redo_cmd(cap)$/;"	f	file:
prepare_viminfo_history	ex_getln.c	/^prepare_viminfo_history(asklen)$/;"	f
preserve_exit	misc1.c	/^preserve_exit()$/;"	f
prev	edit.c	/^    struct Completion	*prev;$/;"	m	struct:Completion	typeref:struct:Completion::Completion	file:
prev	vim.h	/^    FPOS	prev;		    \/* Previous position *\/$/;"	m	struct:VimClipboard
prev_wrap	gui.h	/^    int		prev_wrap;	    \/* For updating the horizontal scrollbar *\/$/;"	m	struct:Gui
prevchr	regexp.c	/^static int	prevchr;$/;"	v	file:
prevwin	window.c	/^static WIN	*prevwin = NULL;	\/* previous window *\/$/;"	v	file:
print_line	ex_cmds.c	/^print_line(lnum, use_number)$/;"	f
print_line_no_prefix	ex_cmds.c	/^print_line_no_prefix(lnum, use_number)$/;"	f
printdigraph	digraph.c	/^printdigraph(p)$/;"	f	file:
priority	gui.h	/^    int		priority;	    \/* Menu order priority *\/$/;"	m	struct:GuiMenu
process_env	main.c	/^process_env(env)$/;"	f
program	regexp.h	/^    char_u	    program[1]; \/* Unwarranted chumminess with compiler. *\/$/;"	m	struct:__anon11
pseudo_code	misc2.c	/^    int	    pseudo_code;	\/* Code for pseudo mouse event *\/$/;"	m	struct:mousetable	file:
pstrcmp	os_unix.c	/^pstrcmp(a, b)$/;"	f	file:
push_current	syntax.c	/^push_current(idx)$/;"	f	file:
push_next_match	syntax.c	/^push_next_match(cur_si, line)$/;"	f	file:
push_showcmd	normal.c	/^push_showcmd()$/;"	f
put_curr_and_l_to_X	farsi.c	/^put_curr_and_l_to_X(c)$/;"	f	file:
put_id_list	syntax.c	/^put_id_list(name, list, attr)$/;"	f	file:
put_in_typebuf	ops.c	/^put_in_typebuf(s, colon)$/;"	f	file:
put_on_cmdline	ex_getln.c	/^put_on_cmdline(str, len, redraw)$/;"	f
put_pattern	syntax.c	/^put_pattern(s, c, spp, attr)$/;"	f	file:
putcmdline	ex_getln.c	/^putcmdline(c)$/;"	f	file:
putdigraph	digraph.c	/^putdigraph(str)$/;"	f
putescstr	getchar.c	/^putescstr(fd, str, set)$/;"	f
python_buffer_free	if_python.c	/^python_buffer_free(BUF *buf)$/;"	f
python_ref	structs.h	/^    void	    *python_ref;    \/* The Python value referring to$/;"	m	struct:buffer
python_ref	structs.h	/^    void	    *python_ref;    \/* The Python value referring to$/;"	m	struct:window
python_window_free	if_python.c	/^python_window_free(WIN *win)$/;"	f
qf_cleared	quickfix.c	/^    char_u	     qf_cleared;\/* set to TRUE if line has been deleted *\/$/;"	m	struct:qf_line	file:
qf_col	quickfix.c	/^    int		     qf_col;	\/* column where the error occurred *\/$/;"	m	struct:qf_line	file:
qf_count	quickfix.c	/^static int  qf_count = 0;	\/* number of errors (0 means no error list) *\/$/;"	v	file:
qf_fnum	quickfix.c	/^    int		     qf_fnum;	\/* file number for the line *\/$/;"	m	struct:qf_line	file:
qf_free	quickfix.c	/^qf_free()$/;"	f	file:
qf_index	quickfix.c	/^static int  qf_index;		\/* current index in the error list *\/$/;"	v	file:
qf_init	quickfix.c	/^qf_init(efile)$/;"	f
qf_jump	quickfix.c	/^qf_jump(dir, errornr, forceit)$/;"	f
qf_line	quickfix.c	/^struct qf_line$/;"	s	file:
qf_list	quickfix.c	/^qf_list(all)$/;"	f
qf_lnum	quickfix.c	/^    linenr_t	     qf_lnum;	\/* line number where the error occurred *\/$/;"	m	struct:qf_line	file:
qf_mark_adjust	quickfix.c	/^qf_mark_adjust(line1, line2, amount, amount_after)$/;"	f
qf_next	quickfix.c	/^    struct qf_line  *qf_next;	\/* pointer to next error in the list *\/$/;"	m	struct:qf_line	typeref:struct:qf_line::qf_line	file:
qf_nonevalid	quickfix.c	/^static int  qf_nonevalid;	\/* set to TRUE if not a single valid entry found *\/$/;"	v	file:
qf_nr	quickfix.c	/^    int		     qf_nr;	\/* error number *\/$/;"	m	struct:qf_line	file:
qf_prev	quickfix.c	/^    struct qf_line  *qf_prev;	\/* pointer to previous error in the list *\/$/;"	m	struct:qf_line	typeref:struct:qf_line::qf_line	file:
qf_ptr	quickfix.c	/^static struct qf_line *qf_ptr;		\/* pointer to the current error *\/$/;"	v	typeref:struct:qf_line	file:
qf_start	quickfix.c	/^static struct qf_line *qf_start;	\/* pointer to the first error *\/$/;"	v	typeref:struct:qf_line	file:
qf_text	quickfix.c	/^    char_u	    *qf_text;	\/* description of the error *\/$/;"	m	struct:qf_line	file:
qf_type	quickfix.c	/^    char_u	     qf_type;	\/* type of the error (mostly 'E') *\/$/;"	m	struct:qf_line	file:
qf_types	quickfix.c	/^qf_types(c, nr)$/;"	f	file:
qf_valid	quickfix.c	/^    char_u	     qf_valid;	\/* valid error message detected *\/$/;"	m	struct:qf_line	file:
quit_more	globals.h	/^EXTERN int	quit_more INIT(= FALSE);    \/* 'q' hit at "--more--" msg *\/$/;"	v
quitmore	ex_docmd.c	/^static int	    quitmore = 0;$/;"	v	file:
quote_meta	edit.c	/^quote_meta(dest, src, len)$/;"	f	file:
rc_did_emsg	globals.h	/^EXTERN int	rc_did_emsg INIT(= FALSE);  \/* vim_regcomp() called emsg() *\/$/;"	v
re_ismult	regexp.c	/^re_ismult(c)$/;"	f	file:
read_cmd_fd	globals.h	/^EXTERN int	read_cmd_fd INIT(= 0);	    \/* fd to read commands from *\/$/;"	v
read_error_exit	ui.c	/^read_error_exit()$/;"	f
read_from_input_buf	ui.c	/^read_from_input_buf(buf, maxlen)$/;"	f
read_limits	regexp.c	/^read_limits(start, end, minval, maxval)$/;"	f	file:
read_redo	getchar.c	/^read_redo(init, old_redo)$/;"	f	file:
read_stuff	getchar.c	/^read_stuff(advance)$/;"	f	file:
read_viminfo	ex_cmds.c	/^read_viminfo(file, want_info, want_marks, forceit)$/;"	f
read_viminfo_bufferlist	buffer.c	/^read_viminfo_bufferlist(line, fp, writing)$/;"	f
read_viminfo_filemark	mark.c	/^read_viminfo_filemark(line, fp, force)$/;"	f
read_viminfo_history	ex_getln.c	/^read_viminfo_history(line, fp)$/;"	f
read_viminfo_register	ops.c	/^read_viminfo_register(line, fp, force)$/;"	f
read_viminfo_search_pattern	search.c	/^read_viminfo_search_pattern(line, fp, force)$/;"	f
read_viminfo_sub_string	ex_cmds.c	/^read_viminfo_sub_string(line, fp, force)$/;"	f
read_viminfo_up_to_marks	ex_cmds.c	/^read_viminfo_up_to_marks(line, fp, forceit, writing)$/;"	f	file:
readfile	fileio.c	/^readfile(fname, sfname, from, lines_to_skip, lines_to_read, flags)$/;"	f
readonlymode	globals.h	/^EXTERN int	readonlymode INIT(= FALSE); \/* Set to TRUE for "view" *\/$/;"	v
realloc_cmdbuff	ex_getln.c	/^realloc_cmdbuff(len)$/;"	f	file:
recordbuff	getchar.c	/^static struct buffheader recordbuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
recov_file_names	memline.c	/^recov_file_names(names, path, prepend_dot)$/;"	f	file:
recover_names	memline.c	/^recover_names(fname, list, nr)$/;"	f
recoverymode	globals.h	/^EXTERN int	recoverymode INIT(= FALSE); \/* Set to TRUE for "-r" option *\/$/;"	v
redir_fd	globals.h	/^EXTERN FILE *redir_fd INIT(= NULL);	\/* message redirection file *\/$/;"	v
redir_off	globals.h	/^EXTERN int  redir_off INIT(= FALSE);	\/* no redirection for a moment *\/$/;"	v
redir_write	message.c	/^redir_write(s)$/;"	f	file:
redo_VIsual_busy	globals.h	/^EXTERN int	redo_VIsual_busy INIT(= FALSE);$/;"	v
redo_literal	edit.c	/^redo_literal(c)$/;"	f	file:
redobuff	getchar.c	/^static struct buffheader redobuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
redraw_all_later	screen.c	/^redraw_all_later(type)$/;"	f
redraw_cmdline	globals.h	/^EXTERN int	redraw_cmdline INIT(= FALSE);	\/* cmdline must be redrawn *\/$/;"	v
redraw_curbuf_later	screen.c	/^redraw_curbuf_later(type)$/;"	f
redraw_later	screen.c	/^redraw_later(type)$/;"	f
redrawcmd	ex_getln.c	/^redrawcmd()$/;"	f	file:
redrawcmdline	ex_getln.c	/^redrawcmdline()$/;"	f
redrawing	screen.c	/^redrawing()$/;"	f
reg	regexp.c	/^reg(paren, flagp)$/;"	f	file:
reg_ic	globals.h	/^EXTERN int	reg_ic INIT(= 0);	    \/* p_ic passed to vim_regexec() *\/$/;"	v
reg_magic	regexp.c	/^static int	reg_magic;	\/* p_magic passed to vim_regexec() *\/$/;"	v	file:
reg_pat	fileio.c	/^    char_u	    *reg_pat;		\/* pattern converted to regexp *\/$/;"	m	struct:AutoPat	file:
reg_prev_sub	regexp.c	/^static char_u		*reg_prev_sub;$/;"	v	file:
reg_syn	globals.h	/^EXTERN int	reg_syn INIT(= 0);	    \/* vim_regexec() used for syntax *\/$/;"	v
reganch	regexp.h	/^    char_u	    reganch;	\/* Internal use only. *\/$/;"	m	struct:__anon11
regatom	regexp.c	/^regatom(flagp)$/;"	f	file:
regbol	regexp.c	/^static char_u	 *regbol;		\/* Beginning of input, for ^ check. *\/$/;"	v	file:
regbranch	regexp.c	/^regbranch(flagp)$/;"	f	file:
regc	regexp.c	/^regc(b)$/;"	f	file:
regcode	regexp.c	/^static char_u	*regcode;	\/* Code-emit pointer, or JUST_CALC_SIZE *\/$/;"	v	file:
regdump	regexp.c	/^regdump(pattern, r)$/;"	f	file:
regendp	regexp.c	/^static char_u	**regendp;	\/* Pointer to endp array *\/$/;"	v	file:
reginput	regexp.c	/^static char_u	 *reginput;		\/* String-input pointer. *\/$/;"	v	file:
reginsert	regexp.c	/^reginsert(op, opnd)$/;"	f	file:
reginsert_limits	regexp.c	/^reginsert_limits(op, minval, maxval, opnd)$/;"	f	file:
regmatch	regexp.c	/^regmatch(prog)$/;"	f	file:
regmlen	regexp.h	/^    int		    regmlen;	\/* Internal use only. *\/$/;"	m	struct:__anon11
regmust	regexp.h	/^    char_u	   *regmust;	\/* Internal use only. *\/$/;"	m	struct:__anon11
regname	ex_cmds.h	/^    int		regname;    \/* register name (NUL if none) *\/$/;"	m	struct:exarg
regname	structs.h	/^    int	    regname;		\/* register to use for the operator *\/$/;"	m	struct:oparg
regnarrate	regexp.c	/^int		regnarrate = 0;$/;"	v
regnext	regexp.c	/^regnext(p)$/;"	f	file:
regnode	regexp.c	/^regnode(op)$/;"	f	file:
regnpar	regexp.c	/^static int	regnpar;	\/* () count. *\/$/;"	v	file:
regoptail	regexp.c	/^regoptail(p, val)$/;"	f	file:
regparse	regexp.c	/^static char_u	*regparse;  \/* Input-scan pointer. *\/$/;"	v	file:
regpiece	regexp.c	/^regpiece(flagp)$/;"	f	file:
regprop	regexp.c	/^regprop(op)$/;"	f	file:
regrepeat	regexp.c	/^regrepeat(p)$/;"	f	file:
regsize	regexp.c	/^static long	regsize;	\/* Code size. *\/$/;"	v	file:
regstart	regexp.h	/^    char_u	    regstart;	\/* Internal use only. *\/$/;"	m	struct:__anon11
regstartp	regexp.c	/^static char_u	**regstartp;		\/* Pointer to startp array. *\/$/;"	v	file:
regtail	regexp.c	/^regtail(p, val)$/;"	f	file:
regtilde	regexp.c	/^regtilde(source, magic)$/;"	f
regtry	regexp.c	/^regtry(prog, string)$/;"	f	file:
rem_backslash	ex_docmd.c	/^rem_backslash(str)$/;"	f	file:
removable	mark.c	/^removable(name)$/;"	f	file:
rename	os_unix.c	/^rename(src, dest)$/;"	f
replace_do_bs	edit.c	/^replace_do_bs()$/;"	f	file:
replace_flush	edit.c	/^replace_flush()$/;"	f	file:
replace_join	edit.c	/^replace_join(off)$/;"	f	file:
replace_offset	globals.h	/^EXTERN int	replace_offset INIT(= 0);   \/* offset for replace_push() *\/$/;"	v
replace_pop	edit.c	/^replace_pop()$/;"	f	file:
replace_pop_ins	edit.c	/^replace_pop_ins()$/;"	f	file:
replace_push	edit.c	/^replace_push(c)$/;"	f
replace_push_off	edit.c	/^replace_push_off(c)$/;"	f	file:
replace_stack	edit.c	/^char_u	*replace_stack = NULL;$/;"	v
replace_stack_len	edit.c	/^long	replace_stack_len = 0;	    \/* max. number of entries *\/$/;"	v
replace_stack_nr	edit.c	/^long	replace_stack_nr = 0;	    \/* next entry in replace stack *\/$/;"	v
replace_termcodes	term.c	/^replace_termcodes(from, bufp, from_part)$/;"	f
resel_VIsual_col	normal.c	/^static colnr_t	resel_VIsual_col;		\/* nr of cols or end col *\/$/;"	v	file:
resel_VIsual_line_count	normal.c	/^static linenr_t	resel_VIsual_line_count;	\/* number of lines *\/$/;"	v	file:
resel_VIsual_mode	normal.c	/^static int	resel_VIsual_mode = NUL;	\/* 'v', 'V', or Ctrl-V *\/$/;"	v	file:
reset_VIsual	window.c	/^reset_VIsual()$/;"	f	file:
reset_cterm_colors	screen.c	/^reset_cterm_colors()$/;"	f
reset_signals	os_unix.c	/^reset_signals()$/;"	f
resettitle	buffer.c	/^resettitle()$/;"	f
restart_edit	globals.h	/^EXTERN int	restart_edit INIT(= 0);	\/* call edit when next cmd finished *\/$/;"	v
restoreRedobuff	getchar.c	/^restoreRedobuff()$/;"	f
restore_search_patterns	search.c	/^restore_search_patterns()$/;"	f
restricted	globals.h	/^EXTERN int	restricted INIT(= FALSE);$/;"	v
rev_video	gui.h	/^    Bool	rev_video;	    \/* Use reverse video? *\/$/;"	m	struct:Gui
rev_video	gui.h	/^    char_u	rev_video;	    \/* Use reverse video? *\/$/;"	m	struct:Gui
reverse_line	ops.c	/^reverse_line(s)$/;"	f	file:
revins_chars	edit.c	/^int	    revins_chars;	    \/* how much to skip after edit *\/$/;"	v
revins_legal	edit.c	/^int	    revins_legal;	    \/* was the last char 'legal'? *\/$/;"	v
revins_on	edit.c	/^int	    revins_on;		    \/* reverse insert mode on *\/$/;"	v
revins_scol	edit.c	/^int	    revins_scol;	    \/* start column of revins session *\/$/;"	v
right_sbar_x	gui.h	/^    int		right_sbar_x;	    \/* Calculated x coord for right scrollbar *\/$/;"	m	struct:Gui
root_menu	gui.h	/^    GuiMenu	*root_menu;	    \/* Root of menu hierarchy *\/$/;"	m	struct:Gui
row	gui.h	/^    int		row;		    \/* Current cursor row in GUI display *\/$/;"	m	struct:Gui
ru_col	globals.h	/^EXTERN int	ru_col;		\/* column for ruler *\/$/;"	v
safe_vim_isprintc	charset.c	/^safe_vim_isprintc(c)$/;"	f
same_leader	ops.c	/^same_leader(leader1_len, leader1_flags, leader2_len, leader2_flags)$/;"	f	file:
saveRedobuff	getchar.c	/^saveRedobuff()$/;"	f
save_old_redobuff	getchar.c	/^static struct buffheader save_old_redobuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
save_patterns	os_unix.c	/^save_patterns(num_pat, pat, num_file, file)$/;"	f	file:
save_redobuff	getchar.c	/^static struct buffheader save_redobuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
save_search_patterns	search.c	/^save_search_patterns()$/;"	f
save_sm	edit.c	/^static int		    save_sm;$/;"	v	file:
save_typebuf	getchar.c	/^save_typebuf()$/;"	f
saved_last_idx	search.c	/^static int	    saved_last_idx = 0;$/;"	v	file:
saved_python_thread	if_python.c	/^static PyThreadState* saved_python_thread = NULL;$/;"	v	file:
saved_spats	search.c	/^static struct spat  saved_spats[2];$/;"	v	typeref:struct:spat	file:
sc_col	globals.h	/^EXTERN int	sc_col;		\/* column for shown command *\/$/;"	v
screen_Columns	globals.h	/^EXTERN int	screen_Columns INIT(= 0);   \/* actual size of NextScreen *\/$/;"	v
screen_Rows	globals.h	/^EXTERN int	screen_Rows INIT(= 0);	    \/* actual size of NextScreen *\/$/;"	v
screen_attr	screen.c	/^static int	screen_attr = 0;$/;"	v	file:
screen_char	screen.c	/^screen_char(p, row, col)$/;"	f	file:
screen_cleared	globals.h	/^EXTERN int	screen_cleared INIT(= FALSE);	\/* screen has been cleared *\/$/;"	v
screen_cur_col	screen.c	/^static int	screen_cur_row, screen_cur_col;	\/* last known cursor position *\/$/;"	v	file:
screen_cur_row	screen.c	/^static int	screen_cur_row, screen_cur_col;	\/* last known cursor position *\/$/;"	v	file:
screen_del_lines	screen.c	/^screen_del_lines(off, row, line_count, end, force)$/;"	f
screen_down	screen.c	/^screen_down()$/;"	f
screen_fill	screen.c	/^screen_fill(start_row, end_row, start_col, end_col, c1, c2, attr)$/;"	f
screen_ins_lines	screen.c	/^screen_ins_lines(off, row, line_count, end)$/;"	f	file:
screen_line	screen.c	/^screen_line(row, endcol, clear_rest$/;"	f	file:
screen_new_rows	window.c	/^screen_new_rows()$/;"	f
screen_putchar	screen.c	/^screen_putchar(c, row, col, attr)$/;"	f
screen_puts	screen.c	/^screen_puts(text, row, col, attr)$/;"	f
screen_start	screen.c	/^screen_start()$/;"	f
screen_start_highlight	screen.c	/^screen_start_highlight(attr)$/;"	f	file:
screen_stop_highlight	screen.c	/^screen_stop_highlight()$/;"	f
screen_valid	screen.c	/^screen_valid(clear)$/;"	f
screenalloc	screen.c	/^screenalloc(clear)$/;"	f
screenclear	screen.c	/^screenclear()$/;"	f
screenclear2	screen.c	/^screenclear2()$/;"	f	file:
screengo	normal.c	/^screengo(oap, dir, dist)$/;"	f	file:
scriptin	globals.h	/^EXTERN FILE	*scriptin[NSCRIPT];	    \/* streams to read script from *\/$/;"	v
scriptout	globals.h	/^EXTERN FILE	*scriptout  INIT(= NULL);   \/* stream to write script to *\/$/;"	v
scrollProc	gui_at_sb.h	/^    XtCallbackList scrollProc;	\/* proportional scroll *\/$/;"	m	struct:__anon16
scroll_bg_pixel	gui.h	/^    GuiColor	scroll_bg_pixel;    \/* Color of scrollbar backgrnd *\/$/;"	m	struct:Gui
scroll_cursor_bot	screen.c	/^scroll_cursor_bot(min_scroll, set_topbot)$/;"	f
scroll_cursor_halfway	screen.c	/^scroll_cursor_halfway(atend)$/;"	f
scroll_cursor_top	screen.c	/^scroll_cursor_top(min_scroll, always)$/;"	f
scroll_fg_pixel	gui.h	/^    GuiColor	scroll_fg_pixel;    \/* Color of scrollbar foregrnd *\/$/;"	m	struct:Gui
scroll_mode	gui_at_sb.h	/^    char	  scroll_mode;	\/* see below *\/$/;"	m	struct:__anon16
scroll_off	gui_at_sb.h	/^    float	  scroll_off;	\/* offset from event to top of thumb *\/$/;"	m	struct:__anon16
scroll_region	globals.h	/^EXTERN int	scroll_region INIT(= FALSE); \/* term supports scroll region *\/$/;"	v
scroll_region_bot	gui.h	/^    int		scroll_region_bot;  \/* Bottom (last) line of scroll region *\/$/;"	m	struct:Gui
scroll_region_reset	term.c	/^scroll_region_reset()$/;"	f
scroll_region_set	term.c	/^scroll_region_set(wp, off)$/;"	f
scroll_region_top	gui.h	/^    int		scroll_region_top;  \/* Top (first) line of scroll region *\/$/;"	m	struct:Gui
scroll_start	term.c	/^scroll_start()$/;"	f
scrollbar	gui_at_sb.h	/^    ScrollbarPart	scrollbar;$/;"	m	struct:_ScrollbarRec
scrollbar_class	gui_at_sb.h	/^    ScrollbarClassPart		scrollbar_class;$/;"	m	struct:_ScrollbarClassRec
scrollbar_height	gui.h	/^    int		scrollbar_height;   \/* Height of horizontal scrollbar *\/$/;"	m	struct:Gui
scrollbar_value	globals.h	/^EXTERN long_u	scrollbar_value;$/;"	v
scrollbar_width	gui.h	/^    int		scrollbar_width;    \/* Width of vertical scrollbars *\/$/;"	m	struct:Gui
scrolldown	screen.c	/^scrolldown(line_count)$/;"	f
scrolldown_clamp	screen.c	/^scrolldown_clamp()$/;"	f
scrollup	screen.c	/^scrollup(line_count)$/;"	f
scrollup_clamp	screen.c	/^scrollup_clamp()$/;"	f
search_for_exact_line	search.c	/^search_for_exact_line(buf, pos, dir, pat)$/;"	f
search_hl_attr	screen.c	/^int		search_hl_attr;$/;"	v
search_hl_ic	screen.c	/^int		search_hl_ic;$/;"	v
search_hl_prog	screen.c	/^vim_regexp	*search_hl_prog = NULL;$/;"	v
search_match_len	globals.h	/^EXTERN int	search_match_len;		\/* length of matched string *\/$/;"	v
search_regcomp	search.c	/^search_regcomp(pat, pat_save, pat_use, options)$/;"	f
searchc	search.c	/^searchc(c, dir, type, count)$/;"	f
searchcmdlen	globals.h	/^EXTERN int	searchcmdlen;		    \/* length of previous search cmd *\/$/;"	v
searchit	search.c	/^searchit(buf, pos, dir, str, count, options, pat_use)$/;"	f
secure	globals.h	/^EXTERN int	secure INIT(= FALSE);$/;"	v
select	os_unix.c	24;"	d	file:
select	os_unix.c	37;"	d	file:
select	os_unix.c	39;"	d	file:
set_Changed	misc1.c	/^set_Changed()$/;"	f
set_b0_fname	memline.c	/^set_b0_fname(b0p, buf)$/;"	f	file:
set_bool_option	option.c	/^set_bool_option(opt_idx, varp, value)$/;"	f	file:
set_context_in_autocmd	fileio.c	/^set_context_in_autocmd(arg, doautocmd)$/;"	f
set_context_in_highlight_cmd	syntax.c	/^set_context_in_highlight_cmd(arg)$/;"	f
set_context_in_set_cmd	option.c	/^set_context_in_set_cmd(arg)$/;"	f
set_context_in_syntax_cmd	syntax.c	/^set_context_in_syntax_cmd(arg)$/;"	f
set_expand_context	ex_getln.c	/^set_expand_context()$/;"	f	file:
set_expr_line	ops.c	/^set_expr_line(new_line)$/;"	f
set_file_time	fileio.c	/^set_file_time(fname, atime, mtime)$/;"	f	file:
set_fileformat	misc2.c	/^set_fileformat(t)$/;"	f
set_group_colors	syntax.c	/^set_group_colors(name, fgp, bgp)$/;"	f	file:
set_hl_attr	syntax.c	/^set_hl_attr(idx)$/;"	f	file:
set_indent	misc1.c	/^set_indent(size, del_first)$/;"	f
set_init_1	option.c	/^set_init_1()$/;"	f
set_init_2	option.c	/^set_init_2()$/;"	f
set_init_3	option.c	/^set_init_3()$/;"	f
set_internal_string_var	eval.c	/^set_internal_string_var(name, value)$/;"	f
set_last_cursor	mark.c	/^set_last_cursor(win)$/;"	f
set_last_insert	edit.c	/^set_last_insert(c)$/;"	f
set_normal_colors	syntax.c	/^set_normal_colors()$/;"	f
set_num_option	option.c	/^set_num_option(opt_idx, varp, value, errbuf)$/;"	f	file:
set_number_default	option.c	/^set_number_default(name, val)$/;"	f
set_one_cmd_context	ex_docmd.c	/^set_one_cmd_context(buff)$/;"	f
set_option_default	option.c	/^set_option_default(opt_idx, dofree)$/;"	f	file:
set_option_value	option.c	/^set_option_value(name, number, string)$/;"	f
set_options_bin	option.c	/^set_options_bin(oldval, newval)$/;"	f
set_options_default	option.c	/^set_options_default(dofree)$/;"	f	file:
set_redo_ins	getchar.c	/^set_redo_ins()$/;"	f
set_reg_ic	search.c	/^set_reg_ic(pat)$/;"	f
set_signals	os_unix.c	/^set_signals()$/;"	f	file:
set_string_default	option.c	/^set_string_default(name, val)$/;"	f
set_string_option	option.c	/^set_string_option(opt_idx, value)$/;"	f	file:
set_string_option_direct	option.c	/^set_string_option_direct(name, opt_idx, val, dofree)$/;"	f
set_term_defaults	option.c	/^set_term_defaults()$/;"	f
set_termname	term.c	/^set_termname(term)$/;"	f
set_title_defaults	option.c	/^set_title_defaults()$/;"	f
set_topline	screen.c	/^set_topline(wp, lnum)$/;"	f
set_var	eval.c	/^set_var(name, varp)$/;"	f	file:
set_winsize	term.c	/^set_winsize(width, height, mustset)$/;"	f
set_x11_icon	os_unix.c	/^set_x11_icon(icon)$/;"	f	file:
set_x11_title	os_unix.c	/^set_x11_title(title)$/;"	f	file:
setaltfname	buffer.c	/^setaltfname(ffname, sfname, lnum)$/;"	f
setcursor	screen.c	/^setcursor()$/;"	f
setfname	buffer.c	/^setfname(ffname, sfname, message)$/;"	f
setmark	mark.c	/^setmark(c)$/;"	f
setmouse	term.c	/^setmouse()$/;"	f
setpcmark	mark.c	/^setpcmark()$/;"	f
settmode	term.c	/^settmode(tmode)$/;"	f
sfname	fileio.c	/^    char_u	*sfname;	\/* sfname to match with *\/$/;"	m	struct:AutoPatCmd	file:
sg_cterm	syntax.c	/^    int		    sg_cterm;	    \/* "cterm=" highlighting attr *\/$/;"	m	struct:hl_group	file:
sg_cterm_attr	syntax.c	/^    int		    sg_cterm_attr;  \/* NextScreen attr for color term mode *\/$/;"	m	struct:hl_group	file:
sg_cterm_bg	syntax.c	/^    int		    sg_cterm_bg;    \/* terminal bg color number + 1 *\/$/;"	m	struct:hl_group	file:
sg_cterm_bold	syntax.c	/^    int		    sg_cterm_bold;  \/* bold attr was set for light color *\/$/;"	m	struct:hl_group	file:
sg_cterm_fg	syntax.c	/^    int		    sg_cterm_fg;    \/* terminal fg color number + 1 *\/$/;"	m	struct:hl_group	file:
sg_font	syntax.c	/^    GuiFont	    sg_font;	    \/* GUI font handle *\/$/;"	m	struct:hl_group	file:
sg_font_name	syntax.c	/^    char_u	    *sg_font_name;  \/* GUI font name *\/$/;"	m	struct:hl_group	file:
sg_gui	syntax.c	/^    int		    sg_gui;	    \/* "gui=" highlighting attributes *\/$/;"	m	struct:hl_group	file:
sg_gui_attr	syntax.c	/^    int		    sg_gui_attr;    \/* NextScreen attr for GUI mode *\/$/;"	m	struct:hl_group	file:
sg_gui_bg	syntax.c	/^    GuiColor	    sg_gui_bg;	    \/* GUI background color handle + 1 *\/$/;"	m	struct:hl_group	file:
sg_gui_bg_name	syntax.c	/^    char_u	    *sg_gui_bg_name;\/* GUI background color name *\/$/;"	m	struct:hl_group	file:
sg_gui_fg	syntax.c	/^    GuiColor	    sg_gui_fg;	    \/* GUI foreground color handle + 1 *\/$/;"	m	struct:hl_group	file:
sg_gui_fg_name	syntax.c	/^    char_u	    *sg_gui_fg_name;\/* GUI foreground color name *\/$/;"	m	struct:hl_group	file:
sg_link	syntax.c	/^    int		    sg_link;	    \/* link to this highlight group ID *\/$/;"	m	struct:hl_group	file:
sg_name	syntax.c	/^    char_u	    *sg_name;	    \/* highlight group name *\/$/;"	m	struct:hl_group	file:
sg_name_u	syntax.c	/^    char_u	    *sg_name_u;	    \/* uppercase of sg_name *\/$/;"	m	struct:hl_group	file:
sg_start	syntax.c	/^    char_u	    *sg_start;	    \/* terminal string for start highl *\/$/;"	m	struct:hl_group	file:
sg_stop	syntax.c	/^    char_u	    *sg_stop;	    \/* terminal string for stop highl *\/$/;"	m	struct:hl_group	file:
sg_term	syntax.c	/^    int		    sg_term;	    \/* "term=" highlighting attributes *\/$/;"	m	struct:hl_group	file:
sg_term_attr	syntax.c	/^    int		    sg_term_attr;   \/* NextScreen attr for term mode *\/$/;"	m	struct:hl_group	file:
shadow_width	gui_at_sb.h	/^    Dimension	shadow_width;$/;"	m	struct:__anon16
shift_line	ops.c	/^shift_line(left, round, amount)$/;"	f
shifted_keys_table	misc2.c	/^static char_u shifted_keys_table[] =$/;"	v	file:
short_u	structs.h	/^typedef unsigned short	short_u;$/;"	t
short_u	vim.h	/^typedef unsigned short	short_u;$/;"	t
shorten_fname	fileio.c	/^shorten_fname(full_path, dir_name)$/;"	f
shortmess	option.c	/^shortmess(x)$/;"	f
shortname	option.c	/^    char	*shortname;	\/* permissible abbreviation *\/$/;"	m	struct:vimoption	file:
show_autocmd	fileio.c	/^show_autocmd(ap, event)$/;"	f	file:
show_one_mark	mark.c	/^show_one_mark(c, arg, p, name)$/;"	f	file:
show_one_termcode	term.c	/^show_one_termcode(name, code, printit)$/;"	f
show_pat_in_path	search.c	/^show_pat_in_path(line, type, did_show, action, fp, lnum, count)$/;"	f	file:
show_shell_mess	os_unix.c	/^static int	show_shell_mess = TRUE;$/;"	v	file:
show_termcodes	term.c	/^show_termcodes()$/;"	f
showcmd_buf	normal.c	/^static char_u	showcmd_buf[SHOWCMD_COLS + 1];$/;"	v	file:
showcmd_is_clear	normal.c	/^static int	showcmd_is_clear = TRUE;$/;"	v	file:
showmap	getchar.c	/^showmap(mp)$/;"	f	file:
showmatch	search.c	/^showmatch()$/;"	f
showmatches	ex_getln.c	/^showmatches()$/;"	f	file:
showmode	screen.c	/^showmode()$/;"	f
shown	gui_at_sb.h	/^    float	  shown;	\/* What percent is shown in the win *\/$/;"	m	struct:__anon16
shownLength	gui_at_sb.h	/^    Dimension	  shownLength;	\/* Num pixels corresponding to shown *\/$/;"	m	struct:__anon16
showoneopt	option.c	/^showoneopt(p)$/;"	f	file:
showoptions	option.c	/^showoptions(all)$/;"	f	file:
showruler	screen.c	/^showruler(always)$/;"	f
si_attr	syntax.c	/^    int	    si_attr;		    \/* attributes in this state *\/$/;"	m	struct:state_item	file:
si_cont_list	syntax.c	/^    short   *si_cont_list;	    \/* list of contained groups *\/$/;"	m	struct:state_item	file:
si_end_idx	syntax.c	/^    int	    si_end_idx;		    \/* group ID for end pattern or zero *\/$/;"	m	struct:state_item	file:
si_ends	syntax.c	/^    int	    si_ends;		    \/* if match ends after si_m_endcol *\/$/;"	m	struct:state_item	file:
si_eoe_col	syntax.c	/^    int	    si_eoe_col;		    \/* ending column of end pattern *\/$/;"	m	struct:state_item	file:
si_flags	syntax.c	/^    int	    si_flags;		    \/* HL_HAS_EOL flag in this state, and$/;"	m	struct:state_item	file:
si_h_endcol	syntax.c	/^    int	    si_h_endcol;	    \/* ending column of the highlighting *\/$/;"	m	struct:state_item	file:
si_h_startcol	syntax.c	/^    int	    si_h_startcol;	    \/* starting column of the highlighting *\/$/;"	m	struct:state_item	file:
si_id	syntax.c	/^    int	    si_id;		    \/* highlight group ID for keywords *\/$/;"	m	struct:state_item	file:
si_idx	syntax.c	/^    int	    si_idx;		    \/* index of syntax pattern *\/$/;"	m	struct:state_item	file:
si_m_endcol	syntax.c	/^    int	    si_m_endcol;	    \/* ending column of the match *\/$/;"	m	struct:state_item	file:
si_m_lnum	syntax.c	/^    int	    si_m_lnum;		    \/* lnum of the match *\/$/;"	m	struct:state_item	file:
si_m_startcol	syntax.c	/^    int	    si_m_startcol;	    \/* starting column of the match *\/$/;"	m	struct:state_item	file:
si_next_list	syntax.c	/^    short   *si_next_list;	    \/* nextgroup IDs after this item ends *\/$/;"	m	struct:state_item	file:
si_trans_id	syntax.c	/^    int	    si_trans_id;	    \/* idem, transparancy removed *\/$/;"	m	struct:state_item	file:
sig	os_unix.c	/^    int	    sig;	\/* Signal number, eg. SIGSEGV etc *\/$/;"	m	struct:signalinfo	file:
signal	os_unixx.h	17;"	d
signal_info	os_unix.c	/^} signal_info[] =$/;"	v	typeref:struct:signalinfo	file:
signalinfo	os_unix.c	/^static struct signalinfo$/;"	s	file:
silent_mode	globals.h	/^EXTERN int	silent_mode INIT(= FALSE);$/;"	v
simple	gui_at_sb.h	/^    SimplePart		simple;$/;"	m	struct:_ScrollbarRec
simple_class	gui_at_sb.h	/^    SimpleClassPart		simple_class;$/;"	m	struct:_ScrollbarClassRec
simplify_filename	tag.c	/^simplify_filename(filename)$/;"	f
simplify_key	misc2.c	/^simplify_key(key, modifiers)$/;"	f
single_input	if_python.c	29;"	d	file:
size	gui.h	/^    int		size;		    \/* Size of scrollbar thumb *\/$/;"	m	struct:GuiScrollbar
skip	ex_cmds.h	/^    int		skip;	    \/* don't execute the command, only parse it *\/$/;"	m	struct:exarg
skip_chars	search.c	/^skip_chars(cclass, dir)$/;"	f	file:
skip_cmd_arg	ex_docmd.c	/^skip_cmd_arg(p)$/;"	f	file:
skip_label	misc1.c	/^skip_label(lnum, pp, ind_maxcomment)$/;"	f	file:
skip_range	regexp.c	/^skip_range(p)$/;"	f	file:
skip_redraw	globals.h	/^EXTERN int	skip_redraw INIT(= FALSE);  \/* skip redraw once *\/$/;"	v
skip_regexp	regexp.c	/^skip_regexp(p, dirc, magic)$/;"	f
skip_string	misc1.c	/^skip_string(p)$/;"	f	file:
skip_to_option_part	misc1.c	/^skip_to_option_part(p)$/;"	f
skipchr	regexp.c	/^skipchr()$/;"	f	file:
skipdigits	charset.c	/^skipdigits(p)$/;"	f
skiptowhite	charset.c	/^skiptowhite(p)$/;"	f
skiptowhite_esc	charset.c	/^skiptowhite_esc(p)$/;"	f
skipwhite	charset.c	/^skipwhite(p)$/;"	f
slash_adjust	os_unix.c	/^slash_adjust(p)$/;"	f	file:
smsg	message.c	/^int smsg(char_u *s, ...)$/;"	f
smsg	message.c	/^smsg(s, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)$/;"	f
smsg_attr	message.c	/^int smsg_attr(int attr, char_u *s, ...)$/;"	f
smsg_attr	message.c	/^smsg_attr(attr, s, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)$/;"	f
soffset	search.c	/^struct soffset$/;"	s	file:
softspace	if_python.c	/^    long softspace;$/;"	m	struct:__anon4	file:
source_cookie	ex_docmd.c	/^struct source_cookie$/;"	s	file:
sourcing_lnum	globals.h	/^EXTERN linenr_t	sourcing_lnum INIT(= 0);    \/* line number of the source file *\/$/;"	v
sourcing_name	globals.h	/^EXTERN char_u	*sourcing_name INIT( = NULL);\/* name of error message source *\/$/;"	v
sp_cont_list	syntax.c	/^    short		*sp_cont_list;	    \/* cont. group IDs, if non-zero *\/$/;"	m	struct:syn_pattern	file:
sp_flags	syntax.c	/^    short		 sp_flags;	    \/* see HL_ defines below *\/$/;"	m	struct:syn_pattern	file:
sp_ic	syntax.c	/^    int			 sp_ic;		    \/* ignore-case flag for sp_prog *\/$/;"	m	struct:syn_pattern	file:
sp_line_id	syntax.c	/^    int			 sp_line_id;	    \/* ID of last line where tried *\/$/;"	m	struct:syn_pattern	file:
sp_next_list	syntax.c	/^    short		*sp_next_list;	    \/* next group IDs, if non-zero *\/$/;"	m	struct:syn_pattern	file:
sp_off_flags	syntax.c	/^    short		 sp_off_flags;	    \/* see below *\/$/;"	m	struct:syn_pattern	file:
sp_offsets	syntax.c	/^    int			 sp_offsets[SPO_COUNT];	\/* offsets *\/$/;"	m	struct:syn_pattern	file:
sp_pattern	syntax.c	/^    char_u		*sp_pattern;	    \/* regexp to match, pattern *\/$/;"	m	struct:syn_pattern	file:
sp_prog	syntax.c	/^    vim_regexp		*sp_prog;	    \/* regexp to match, program *\/$/;"	m	struct:syn_pattern	file:
sp_startcol	syntax.c	/^    int			 sp_startcol;	    \/* next match in sp_line_id line *\/$/;"	m	struct:syn_pattern	file:
sp_syn_id	syntax.c	/^    short		 sp_syn_id;	    \/* highlight group ID of item *\/$/;"	m	struct:syn_pattern	file:
sp_syn_match_id	syntax.c	/^    short		 sp_syn_match_id;   \/* highlight group ID of pattern *\/$/;"	m	struct:syn_pattern	file:
sp_sync_idx	syntax.c	/^    int			 sp_sync_idx;	    \/* sync item index (syncing only) *\/$/;"	m	struct:syn_pattern	file:
sp_syncing	syntax.c	/^    char		 sp_syncing;	    \/* this item used for syncing *\/$/;"	m	struct:syn_pattern	file:
sp_type	syntax.c	/^    char		 sp_type;	    \/* see SPTYPE_ defines below *\/$/;"	m	struct:syn_pattern	file:
spat	search.c	/^struct spat$/;"	s	file:
spats	search.c	/^static struct spat spats[2] =$/;"	v	typeref:struct:spat	file:
spo_name_tab	syntax.c	/^static char *(spo_name_tab[SPO_COUNT]) =$/;"	v	file:
sst_ga	structs.h	/^    struct growarray	sst_ga;		\/* growarray to store syntax state *\/$/;"	m	struct:syn_state	typeref:struct:syn_state::growarray
sst_next_flags	structs.h	/^    int			sst_next_flags;	\/* flags for sst_next_list *\/$/;"	m	struct:syn_state
sst_next_list	structs.h	/^    short		*sst_next_list;	\/* "nextgroup" list in this state$/;"	m	struct:syn_state
start	if_python.c	/^    int start;$/;"	m	struct:__anon7	file:
start	structs.h	/^	    char_u	    *start;	\/* start escape sequence *\/$/;"	m	struct:attr_entry::__anon12::__anon13
start	structs.h	/^    FPOS    start;		\/* start of the operator *\/$/;"	m	struct:oparg
start	vim.h	/^    FPOS	start;		    \/* Start of selected area *\/$/;"	m	struct:VimClipboard
startPS	search.c	/^startPS(lnum, para, both)$/;"	f
start_arrow	edit.c	/^start_arrow(end_insert_pos)$/;"	f	file:
start_redo	getchar.c	/^start_redo(count, old_redo)$/;"	f
start_redo_ins	getchar.c	/^start_redo_ins()$/;"	f
start_search_hl	screen.c	/^start_search_hl()$/;"	f	file:
start_stuff	getchar.c	/^start_stuff()$/;"	f	file:
start_vcol	structs.h	/^    colnr_t start_vcol;		\/* start col for block mode operator *\/$/;"	m	struct:oparg
started_completion	edit.c	/^static int		    started_completion;$/;"	v	file:
starting	globals.h	/^EXTERN int	starting INIT(= TRUE);$/;"	v
starting	gui.h	/^    int		starting;	    \/* GUI will start in a little while *\/$/;"	m	struct:Gui
startp	regexp.h	/^    char_u	   *startp[NSUBEXP];$/;"	m	struct:__anon11
startspaces	ops.c	/^    int		startspaces;$/;"	m	struct:block_def	file:
starttermcap	term.c	/^starttermcap()$/;"	f
stat	vim.h	834;"	d
state	vim.h	/^    short_u	state;		    \/* Current selection state *\/$/;"	m	struct:VimClipboard
state_item	syntax.c	/^struct state_item$/;"	s	file:
status_height	gui.h	/^    int		status_height;	    \/* Height of status line *\/$/;"	m	struct:GuiScrollbar
status_redraw_all	screen.c	/^status_redraw_all()$/;"	f
stop	structs.h	/^	    char_u	    *stop;	\/* stop escape sequence *\/$/;"	m	struct:attr_entry::__anon12::__anon13
stop_arrow	edit.c	/^stop_arrow()$/;"	f
stop_insert	edit.c	/^stop_insert(end_insert_pos)$/;"	f	file:
stop_redo_ins	getchar.c	/^stop_redo_ins()$/;"	f
stoptermcap	term.c	/^stoptermcap()$/;"	f
store_current_state	syntax.c	/^store_current_state()$/;"	f	file:
str	edit.c	/^    char_u		*str;	  \/* matched text *\/$/;"	m	struct:Completion	file:
str_to_reg	ops.c	/^str_to_reg(y_ptr, type, str, len)$/;"	f	file:
strerror	os_unix.c	/^strerror(err)$/;"	f	file:
strings	gui.h	/^    char_u	*strings[MENU_MODES]; \/* Mapped string for each mode *\/$/;"	m	struct:GuiMenu
stuffReadbuff	getchar.c	/^stuffReadbuff(s)$/;"	f
stuff_empty	getchar.c	/^stuff_empty()$/;"	f
stuff_inserted	edit.c	/^stuff_inserted(c, count, no_esc)$/;"	f
stuff_yank	ops.c	/^stuff_yank(regname, p)$/;"	f	file:
stuffbuff	getchar.c	/^static struct buffheader stuffbuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
stuffcharReadbuff	getchar.c	/^stuffcharReadbuff(c)$/;"	f
stuffnumReadbuff	getchar.c	/^stuffnumReadbuff(n)$/;"	f
stype	search.c	/^static int	stype;		\/* type of the word motion being performed *\/$/;"	v	file:
sub_nlines	ex_cmds.c	/^static linenr_t	    sub_nlines;	    \/* total number of lines changed *\/$/;"	v	file:
sub_nsubs	ex_cmds.c	/^static long	    sub_nsubs;	    \/* total number of substitutions *\/$/;"	v	file:
subcommand	syntax.c	/^struct subcommand$/;"	s	file:
subcommands	syntax.c	/^static struct subcommand subcommands[] =$/;"	v	typeref:struct:subcommand	file:
submenu_handle	gui.h	/^    MenuHandle	submenu_handle;$/;"	m	struct:GuiMenu
submenu_id	gui.h	/^    BMenu	*submenu_id;	    \/* If this is submenu, add children here *\/$/;"	m	struct:GuiMenu
submenu_id	gui.h	/^    HMENU	submenu_id;	    \/* If this is submenu, add children here *\/$/;"	m	struct:GuiMenu
submenu_id	gui.h	/^    Widget	submenu_id;	    \/* If this is submenu, add children here *\/$/;"	m	struct:GuiMenu
submenu_id	gui.h	/^    short	submenu_id;	    \/* the menu id of the children (could be$/;"	m	struct:GuiMenu
suspend_shell	ui.c	/^suspend_shell()$/;"	f
sv_no_abbr_cnt	getchar.c	/^static int	sv_no_abbr_cnt[NSCRIPT];$/;"	v	file:
sv_noremapbuf	getchar.c	/^static char_u	*(sv_noremapbuf[NSCRIPT]);$/;"	v	file:
sv_typebuf	getchar.c	/^static char_u	*(sv_typebuf[NSCRIPT]);$/;"	v	file:
sv_typebuflen	getchar.c	/^static int	sv_typebuflen[NSCRIPT];$/;"	v	file:
sv_typelen	getchar.c	/^static int	sv_typelen[NSCRIPT];$/;"	v	file:
sv_typemaplen	getchar.c	/^static int	sv_typemaplen[NSCRIPT];$/;"	v	file:
sv_typeoff	getchar.c	/^static int	sv_typeoff[NSCRIPT];$/;"	v	file:
swapchar	ops.c	/^swapchar(op_type, pos)$/;"	f
swapfile_info	memline.c	/^swapfile_info(fname)$/;"	f	file:
swapping_screen	term.c	/^swapping_screen()$/;"	f
switch_visual	normal.c	/^switch_visual(cap)$/;"	f	file:
syn_add_end_off	syntax.c	/^syn_add_end_off(spp, idx, extra)$/;"	f	file:
syn_add_group	syntax.c	/^syn_add_group(name)$/;"	f	file:
syn_add_start_off	syntax.c	/^syn_add_start_off(spp, idx, extra)$/;"	f	file:
syn_buf	syntax.c	/^static BUF	*syn_buf;		\/* current buffer for highlighting *\/$/;"	v	file:
syn_check_group	syntax.c	/^syn_check_group(pp, len)$/;"	f
syn_clear_keyword	syntax.c	/^syn_clear_keyword(id, ktabp)$/;"	f	file:
syn_clear_one	syntax.c	/^syn_clear_one(id, syncing)$/;"	f	file:
syn_clear_pattern	syntax.c	/^syn_clear_pattern(buf, i)$/;"	f	file:
syn_clear_states	syntax.c	/^syn_clear_states(start, end)$/;"	f	file:
syn_cmd_case	syntax.c	/^syn_cmd_case(eap, syncing)$/;"	f	file:
syn_cmd_clear	syntax.c	/^syn_cmd_clear(eap, syncing)$/;"	f	file:
syn_cmd_keyword	syntax.c	/^syn_cmd_keyword(eap, syncing)$/;"	f	file:
syn_cmd_list	syntax.c	/^syn_cmd_list(eap, syncing)$/;"	f	file:
syn_cmd_match	syntax.c	/^syn_cmd_match(eap, syncing)$/;"	f	file:
syn_cmd_off	syntax.c	/^syn_cmd_off(eap, syncing)$/;"	f	file:
syn_cmd_on	syntax.c	/^syn_cmd_on(eap, syncing)$/;"	f	file:
syn_cmd_region	syntax.c	/^syn_cmd_region(eap, syncing)$/;"	f	file:
syn_cmd_sync	syntax.c	/^syn_cmd_sync(eap, syncing)$/;"	f	file:
syn_cterm_attr2entry	syntax.c	/^syn_cterm_attr2entry(attr)$/;"	f
syn_current_attr	syntax.c	/^syn_current_attr(syncing, line)$/;"	f	file:
syn_finish_line	syntax.c	/^syn_finish_line(syncing)$/;"	f	file:
syn_free_all_states	syntax.c	/^syn_free_all_states(buf)$/;"	f	file:
syn_get_final_id	syntax.c	/^syn_get_final_id(hl_id)$/;"	f
syn_get_id	syntax.c	/^syn_get_id(line, col, trans)$/;"	f
syn_gui_attr2entry	syntax.c	/^syn_gui_attr2entry(attr)$/;"	f
syn_id	structs.h	/^    short	    syn_id;	\/* syntax ID for this match (if non-zero) *\/$/;"	m	struct:keyentry
syn_id2attr	syntax.c	/^syn_id2attr(hl_id)$/;"	f	file:
syn_id2colors	syntax.c	/^syn_id2colors(hl_id, fgp, bgp)$/;"	f
syn_lines_msg	syntax.c	/^syn_lines_msg()$/;"	f	file:
syn_list_header	syntax.c	/^syn_list_header(did_header, outlen, id)$/;"	f	file:
syn_list_keywords	syntax.c	/^syn_list_keywords(id, ktabp, did_header, attr)$/;"	f	file:
syn_list_one	syntax.c	/^syn_list_one(id, syncing, link_only)$/;"	f	file:
syn_match_linecont	syntax.c	/^syn_match_linecont(lnum)$/;"	f	file:
syn_name2id	syntax.c	/^syn_name2id(name)$/;"	f
syn_namen2id	syntax.c	/^syn_namen2id(linep, len)$/;"	f	file:
syn_pattern	syntax.c	/^struct syn_pattern$/;"	s	file:
syn_remove_pattern	syntax.c	/^syn_remove_pattern(buf, idx)$/;"	f	file:
syn_start_line	syntax.c	/^syn_start_line()$/;"	f	file:
syn_state	structs.h	/^struct syn_state$/;"	s
syn_sync	syntax.c	/^syn_sync(wp, start_lnum)$/;"	f	file:
syn_term_attr2entry	syntax.c	/^syn_term_attr2entry(attr)$/;"	f
syn_unadd_group	syntax.c	/^syn_unadd_group()$/;"	f	file:
syntax_check_changed	syntax.c	/^syntax_check_changed(lnum)$/;"	f
syntax_clear	syntax.c	/^syntax_clear(buf)$/;"	f
syntax_present	syntax.c	/^syntax_present(buf)$/;"	f
syntax_start	syntax.c	/^syntax_start(wp, lnum)$/;"	f
syntax_sync_clear	syntax.c	/^syntax_sync_clear()$/;"	f	file:
tag_fname	tag.c	/^    char_u	*tag_fname;	\/* file name of the tags file *\/$/;"	m	struct:tag_pointers	file:
tag_modified	globals.h	/^EXTERN int	tag_modified INIT(= FALSE);	\/* buffer was modified since$/;"	v
tag_pointers	tag.c	/^struct tag_pointers$/;"	s	file:
taggy	structs.h	/^struct taggy$/;"	s
tagkind	tag.c	/^    char_u	*tagkind;	\/* "kind:" value *\/$/;"	m	struct:tag_pointers	file:
tagkind_end	tag.c	/^    char_u	*tagkind_end;	\/* end of tagkind *\/$/;"	m	struct:tag_pointers	file:
tagname	structs.h	/^    char_u	    *tagname;		\/* tag name *\/$/;"	m	struct:taggy
tagname	tag.c	/^    char_u	*tagname;	\/* start of tag name (skip "file:") *\/$/;"	m	struct:tag_pointers	file:
tagname_end	tag.c	/^    char_u	*tagname_end;	\/* char after tag name *\/$/;"	m	struct:tag_pointers	file:
tail	fileio.c	/^    char_u	*tail;		\/* tail of fname *\/$/;"	m	struct:AutoPatCmd	file:
tc_len	term.c	/^static int  tc_len = 0;	    \/* current number of entries in termcodes[] *\/$/;"	v	file:
tc_max_len	term.c	/^static int  tc_max_len = 0; \/* number of entries that termcodes[] can hold *\/$/;"	v	file:
term	structs.h	/^	} term;$/;"	m	union:attr_entry::__anon12	typeref:struct:attr_entry::__anon12::__anon13
term_append_lines	term.c	/^term_append_lines(line_count)$/;"	f
term_attr_table	syntax.c	/^struct growarray    term_attr_table = {0, 0, 0, 0, NULL};$/;"	v	typeref:struct:growarray
term_bg_color	term.c	/^term_bg_color(n)$/;"	f
term_color	term.c	/^term_color(s, n)$/;"	f	file:
term_console	globals.h	/^EXTERN int	term_console INIT(= FALSE); \/* set to TRUE when consule used *\/$/;"	v
term_cursor_right	term.c	/^term_cursor_right(i)$/;"	f
term_delete_lines	term.c	/^term_delete_lines(line_count)$/;"	f
term_fg_color	term.c	/^term_fg_color(n)$/;"	f
term_is_builtin	term.c	/^term_is_builtin(name)$/;"	f	file:
term_is_gui	term.c	/^term_is_gui(name)$/;"	f
term_strings	term.c	/^char_u *(term_strings[(int)KS_LAST + 1]);$/;"	v
term_windgoto	term.c	/^term_windgoto(row, col)$/;"	f
termcap_active	globals.h	/^EXTERN int	termcap_active INIT(= FALSE);	\/* set by starttermcap() *\/$/;"	v
termcapinit	term.c	/^termcapinit(name)$/;"	f
termcode	term.c	/^struct termcode$/;"	s	file:
termcodes	term.c	/^} *termcodes = NULL;$/;"	v	typeref:struct:termcode
termleader	term.c	/^static char_u	termleader[256 + 1];		\/* for check_termcode() *\/$/;"	v	file:
test_for_current	tag.c	/^test_for_current(is_etag, fname, fname_end, tag_fname)$/;"	f	file:
test_for_static	tag.c	/^test_for_static(tagp)$/;"	f	file:
text_gc	gui.h	/^    GC		text_gc;$/;"	m	struct:Gui
textcol	ops.c	/^    colnr_t	textcol;$/;"	m	struct:block_def	file:
textlen	ops.c	/^    int		textlen;$/;"	m	struct:block_def	file:
textstart	ops.c	/^    char_u	*textstart;$/;"	m	struct:block_def	file:
tgetent_error	term.c	/^tgetent_error(tbuf, term)$/;"	f	file:
tgetstr	term.c	24;"	d	file:
tgetstr	term.c	50;"	d	file:
tgoto	term.c	/^tgoto(cm, x, y)$/;"	f
thickness	gui_at_sb.h	/^    Dimension	  thickness;	\/* either width or height *\/$/;"	m	struct:__anon16
thumb	gui_at_sb.h	/^    Pixmap	  thumb;	\/* thumb color *\/$/;"	m	struct:__anon16
thumbProc	gui_at_sb.h	/^    XtCallbackList thumbProc;	\/* jump (to position) scroll *\/$/;"	m	struct:__anon16
tilde_replace	ex_getln.c	/^tilde_replace(orig_pat, num_files, files)$/;"	f
timer_id	gui_at_sb.h	/^    XtIntervalId  timer_id;	\/* autorepeat timer; remove on destruction *\/$/;"	m	struct:__anon16
tltoa	term.c	/^tltoa(i)$/;"	f
toF_Rjoin	farsi.c	/^toF_Rjoin(c)$/;"	f	file:
toF_TyA	farsi.c	/^toF_TyA(c)$/;"	f
toF_TyB	farsi.c	/^toF_TyB(c)$/;"	f	file:
toF_Xor_X_	farsi.c	/^toF_Xor_X_(c)$/;"	f	file:
toF_ending	farsi.c	/^toF_ending(c)$/;"	f	file:
toF_leading	farsi.c	/^toF_leading(c)$/;"	f	file:
tolower_tab	globals.h	/^EXTERN char_u	tolower_tab[256];	\/* table for tolower() *\/$/;"	v
top	gui.h	/^    int		top;		    \/* Top of scroll bar (chars from row 0) *\/$/;"	m	struct:GuiScrollbar
top	gui_at_sb.h	/^    float	  top;		\/* What percent is above the win's top *\/$/;"	m	struct:__anon16
topLoc	gui_at_sb.h	/^    Position	  topLoc;	\/* Pixel that corresponds to top *\/$/;"	m	struct:__anon16
top_bot_msg	search.c	/^static char_u *top_bot_msg = (char_u *)"search hit TOP, continuing at BOTTOM";$/;"	v	file:
top_file_num	buffer.c	/^static int  top_file_num = 1;		\/* highest file number *\/$/;"	v	file:
top_shadow_GC	gui_at_sb.h	/^    GC		top_shadow_GC;$/;"	m	struct:__anon16
top_shadow_contrast	gui_at_sb.h	/^    int		top_shadow_contrast;$/;"	m	struct:__anon16
top_shadow_pixel	gui_at_sb.h	/^    Pixel	top_shadow_pixel;$/;"	m	struct:__anon16
topmsg	tag.c	/^static char_u *topmsg = (char_u *)"at top of tag stack";$/;"	v	file:
total_mem_used	memfile.c	/^static long_u total_mem_used = 0;	\/* total memory used for memfiles *\/$/;"	v	file:
toupper_tab	globals.h	/^EXTERN char_u	toupper_tab[256];	\/* table for toupper() *\/$/;"	v
trans_characters	charset.c	/^trans_characters(buf, bufsize)$/;"	f
trans_special	misc2.c	/^trans_special(srcp, dst)$/;"	f
transchar	charset.c	/^transchar(c)$/;"	f
transchar_nonprint	charset.c	/^transchar_nonprint(buf, c)$/;"	f
trash_input_buf	ui.c	/^trash_input_buf()$/;"	f
truncate_line	misc1.c	/^truncate_line(fixpos)$/;"	f
ttest	term.c	/^ttest(pairs)$/;"	f
typebuf	globals.h	/^EXTERN char_u	*typebuf INIT(= NULL);	\/* buffer for typed characters *\/$/;"	v
typebuf_init	getchar.c	/^static char_u	typebuf_init[TYPELEN_INIT];	    \/* initial typebuf *\/$/;"	v	file:
typebuf_typed	getchar.c	/^typebuf_typed()$/;"	f
typebuflen	globals.h	/^EXTERN int	typebuflen;		\/* size of typebuf *\/$/;"	v
typelen	globals.h	/^EXTERN int	typelen;		\/* number of valid chars in typebuf *\/$/;"	v
typemaplen	getchar.c	/^static int	typemaplen = 0;	    \/* nr of mapped characters in typebuf *\/$/;"	v	file:
typeoff	globals.h	/^EXTERN int	typeoff;		\/* current position in typebuf *\/$/;"	v
u_alloc_line	undo.c	/^u_alloc_line(size)$/;"	f	file:
u_blockalloc	undo.c	/^u_blockalloc(size)$/;"	f	file:
u_blockfree	undo.c	/^u_blockfree(buf)$/;"	f
u_clearall	undo.c	/^u_clearall(buf)$/;"	f
u_clearline	undo.c	/^u_clearline()$/;"	f
u_doit	undo.c	/^u_doit(count)$/;"	f	file:
u_entry	structs.h	/^struct u_entry$/;"	s
u_free_line	undo.c	/^u_free_line(ptr)$/;"	f	file:
u_freeentry	undo.c	/^u_freeentry(uep, n)$/;"	f	file:
u_freelist	undo.c	/^u_freelist(uhp)$/;"	f	file:
u_getbot	undo.c	/^u_getbot()$/;"	f	file:
u_header	structs.h	/^struct u_header$/;"	s
u_inssub	undo.c	/^u_inssub(lnum)$/;"	f
u_newcount	undo.c	/^static long	u_newcount, u_oldcount;$/;"	v	file:
u_oldcount	undo.c	/^static long	u_newcount, u_oldcount;$/;"	v	file:
u_redo	undo.c	/^u_redo(count)$/;"	f
u_save	undo.c	/^u_save(top, bot)$/;"	f
u_save_cursor	undo.c	/^u_save_cursor()$/;"	f
u_save_line	undo.c	/^u_save_line(lnum)$/;"	f	file:
u_savecommon	undo.c	/^u_savecommon(top, bot, newbot)$/;"	f	file:
u_savedel	undo.c	/^u_savedel(lnum, nlines)$/;"	f
u_saveline	undo.c	/^u_saveline(lnum)$/;"	f
u_savesub	undo.c	/^u_savesub(lnum)$/;"	f
u_sync	undo.c	/^u_sync()$/;"	f
u_unchanged	undo.c	/^u_unchanged(buf)$/;"	f
u_undo	undo.c	/^u_undo(count)$/;"	f
u_undo_end	undo.c	/^u_undo_end()$/;"	f	file:
u_undoline	undo.c	/^u_undoline()$/;"	f
u_undoredo	undo.c	/^u_undoredo()$/;"	f	file:
ue_array	structs.h	/^    char_u	    **ue_array;	\/* array of lines in undo block *\/$/;"	m	struct:u_entry
ue_bot	structs.h	/^    linenr_t	    ue_bot;	\/* number of line below undo block *\/$/;"	m	struct:u_entry
ue_lcount	structs.h	/^    linenr_t	    ue_lcount;	\/* linecount when u_save called *\/$/;"	m	struct:u_entry
ue_next	structs.h	/^    struct u_entry  *ue_next;	\/* pointer to next entry in list *\/$/;"	m	struct:u_entry	typeref:struct:u_entry::u_entry
ue_size	structs.h	/^    long	    ue_size;	\/* number of lines in ue_array *\/$/;"	m	struct:u_entry
ue_top	structs.h	/^    linenr_t	    ue_top;	\/* number of line above undo block *\/$/;"	m	struct:u_entry
uh_cursor	structs.h	/^    FPOS	     uh_cursor;	\/* cursor position before saving *\/$/;"	m	struct:u_header
uh_entry	structs.h	/^    struct u_entry  *uh_entry;	\/* pointer to first entry *\/$/;"	m	struct:u_header	typeref:struct:u_header::u_entry
uh_flags	structs.h	/^    int		     uh_flags;	\/* see below *\/$/;"	m	struct:u_header
uh_namedm	structs.h	/^    FPOS	     uh_namedm[NMARKS];	\/* marks before undo\/after redo *\/$/;"	m	struct:u_header
uh_next	structs.h	/^    struct u_header *uh_next;	\/* pointer to next header in list *\/$/;"	m	struct:u_header	typeref:struct:u_header::u_header
uh_prev	structs.h	/^    struct u_header *uh_prev;	\/* pointer to previous header in list *\/$/;"	m	struct:u_header	typeref:struct:u_header::u_header
ui_breakcheck	ui.c	/^ui_breakcheck()$/;"	f
ui_can_restore_icon	ui.c	/^ui_can_restore_icon()$/;"	f
ui_can_restore_title	ui.c	/^ui_can_restore_title()$/;"	f
ui_char_avail	ui.c	/^ui_char_avail()$/;"	f
ui_delay	ui.c	/^ui_delay(msec, ignoreinput)$/;"	f
ui_get_winsize	ui.c	/^ui_get_winsize()$/;"	f
ui_inchar	ui.c	/^ui_inchar(buf, maxlen, wtime)$/;"	f
ui_set_winsize	ui.c	/^ui_set_winsize()$/;"	f
ui_suspend	ui.c	/^ui_suspend()$/;"	f
ui_write	ui.c	/^ui_write(s, len)$/;"	f
undisplay_dollar	edit.c	/^undisplay_dollar()$/;"	f	file:
undo_off	globals.h	/^EXTERN int	undo_off INIT(= FALSE);	    \/* undo switched off for now *\/$/;"	v
undo_undoes	undo.c	/^static int	undo_undoes = FALSE;$/;"	v	file:
ungetchr	regexp.c	/^ungetchr()$/;"	f	file:
unregc	regexp.c	/^unregc()$/;"	f	file:
unset_Changed	misc1.c	/^unset_Changed(buf)$/;"	f
unshowmode	screen.c	/^unshowmode(force)$/;"	f
updateWindow	screen.c	/^updateWindow(wp)$/;"	f
update_curbuf	screen.c	/^update_curbuf(type)$/;"	f
update_curswant	screen.c	/^update_curswant()$/;"	f
update_other_win	screen.c	/^update_other_win()$/;"	f
update_screen	screen.c	/^update_screen(type)$/;"	f
update_screenline	screen.c	/^update_screenline()$/;"	f
update_si_attr	syntax.c	/^update_si_attr(idx)$/;"	f	file:
update_si_end	syntax.c	/^update_si_end(sip, line, startcol)$/;"	f	file:
update_topline	screen.c	/^update_topline()$/;"	f
update_topline_redraw	screen.c	/^update_topline_redraw()$/;"	f
updatescript	getchar.c	/^updatescript(c)$/;"	f
usage	main.c	/^usage()$/;"	f	file:
use_gvimrc	globals.h	/^EXTERN char_u	*use_gvimrc INIT(= NULL);	\/* "-U" cmdline argument *\/$/;"	v
use_viminfo	globals.h	/^EXTERN char_u	*use_viminfo INIT(= NULL);  \/* name of viminfo file to use *\/$/;"	v
usefilter	ex_cmds.h	/^    int		usefilter;  \/* TRUE with ":w !command" and ":r!command" *\/$/;"	m	struct:exarg
valid_yank_reg	ops.c	/^valid_yank_reg(regname, writing)$/;"	f
validate_botline	screen.c	/^validate_botline()$/;"	f
validate_cheight	screen.c	/^validate_cheight()$/;"	f
validate_cline_row	screen.c	/^validate_cline_row()$/;"	f
validate_current_state	syntax.c	/^validate_current_state()$/;"	f	file:
validate_cursor	screen.c	/^validate_cursor()$/;"	f
validate_cursor_col	screen.c	/^validate_cursor_col()$/;"	f
validate_maphash	getchar.c	/^validate_maphash()$/;"	f	file:
validate_state	syntax.c	/^validate_state(sp)$/;"	f	file:
validate_virtcol	screen.c	/^validate_virtcol()$/;"	f
validate_virtcol_win	screen.c	/^validate_virtcol_win(wp)$/;"	f	file:
value	gui.h	/^    int		value;		    \/* Represents top line number visible *\/$/;"	m	struct:GuiScrollbar
var	eval.c	/^} var;$/;"	t	typeref:struct:__anon1	file:
var	option.c	/^    char_u	*var;		\/* pointer to variable *\/$/;"	m	struct:vimoption	file:
var2fpos	eval.c	/^var2fpos(varp)$/;"	f	file:
var_clear	eval.c	/^var_clear(gap)$/;"	f
var_free_one	eval.c	/^var_free_one(v)$/;"	f	file:
var_init	eval.c	/^var_init(gap)$/;"	f
var_name	eval.c	/^    char_u	*var_name;	\/* name of variable *\/$/;"	m	struct:__anon1	file:
var_number	eval.c	/^	long	var_number;	\/* number value *\/$/;"	m	union:__anon1::__anon2	file:
var_string	eval.c	/^	char_u	*var_string;	\/* string value (Careful: can be NULL!) *\/$/;"	m	union:__anon1::__anon2	file:
var_type	eval.c	/^    char	var_type;	\/* VAR_NUMBER or VAR_STRING *\/$/;"	m	struct:__anon1	file:
var_val	eval.c	/^    }		var_val;$/;"	m	struct:__anon1	typeref:union:__anon1::__anon2	file:
variables	eval.c	/^struct growarray    variables;$/;"	v	typeref:struct:growarray
vdcmp	gui.h	/^    int		vdcmp;		    \/* Vim Direct Communication Message Port *\/$/;"	m	struct:Gui
version_msg	version.c	/^version_msg(s)$/;"	f	file:
vgetc	getchar.c	/^vgetc()$/;"	f
vgetc_busy	globals.h	/^EXTERN int	vgetc_busy INIT(= FALSE);   \/* inside vgetc() now *\/$/;"	v
vgetorpeek	getchar.c	/^vgetorpeek(advance)$/;"	f	file:
vimApp	gui.h	/^    VimApp     *vimApp;$/;"	m	struct:Gui
vimForm	gui.h	/^    VimFormView *vimForm;$/;"	m	struct:Gui
vimTextArea	gui.h	/^    VimTextAreaView *vimTextArea;$/;"	m	struct:Gui
vimWindow	gui.h	/^    VimWindow  *vimWindow;$/;"	m	struct:Gui
vim_beep	misc1.c	/^vim_beep()$/;"	f
vim_chdir	vim.h	727;"	d
vim_fexists	misc1.c	/^vim_fexists(fname)$/;"	f
vim_fgets	fileio.c	/^vim_fgets(buf, size, fp)$/;"	f
vim_free	misc2.c	/^vim_free(x)$/;"	f
vim_free_in_input_buf	ui.c	/^vim_free_in_input_buf()$/;"	f
vim_getenv	vim.h	689;"	d
vim_isIDc	charset.c	/^vim_isIDc(c)$/;"	f
vim_is_ctrl_x_key	edit.c	/^vim_is_ctrl_x_key(c)$/;"	f
vim_is_fastterm	os_unix.c	/^vim_is_fastterm(name)$/;"	f
vim_is_input_buf_empty	ui.c	/^vim_is_input_buf_empty()$/;"	f
vim_is_input_buf_full	ui.c	/^vim_is_input_buf_full()$/;"	f
vim_is_iris_ansi	os_unix.c	/^vim_is_iris_ansi(name)$/;"	f
vim_is_xterm	os_unix.c	/^vim_is_xterm(name)$/;"	f
vim_isblankline	charset.c	/^vim_isblankline(lbuf)$/;"	f
vim_isbreak	macros.h	76;"	d
vim_isdigit	charset.c	/^vim_isdigit(c)$/;"	f
vim_isfilec	charset.c	/^vim_isfilec(c)$/;"	f
vim_ispathsep	misc1.c	/^vim_ispathsep(c)$/;"	f
vim_isprintc	charset.c	/^vim_isprintc(c)$/;"	f
vim_isspace	misc2.c	/^vim_isspace(x)$/;"	f
vim_iswhite	vim.h	734;"	d
vim_iswildc	regexp.c	/^vim_iswildc(c)$/;"	f
vim_iswordc	charset.c	/^vim_iswordc(c)$/;"	f
vim_iswordc_buf	charset.c	/^vim_iswordc_buf(c, buf)$/;"	f
vim_memcmp	misc2.c	/^vim_memcmp(b1, b2, len)$/;"	f
vim_memcmp	vim.h	713;"	d
vim_memcmp	vim.h	716;"	d
vim_memmove	misc2.c	/^vim_memmove(dst_arg, src_arg, len)$/;"	f
vim_memmove	os_unix.h	281;"	d
vim_memmove	os_unix.h	284;"	d
vim_memmove	os_unix.h	287;"	d
vim_memmove	vim.h	680;"	d
vim_memset	misc2.c	/^vim_memset(ptr, c, size)$/;"	f
vim_memset	vim.h	707;"	d
vim_regcomp	regexp.c	/^vim_regcomp(exp, magic)$/;"	f
vim_regcomp_had_eol	regexp.c	/^vim_regcomp_had_eol()$/;"	f
vim_regexec	regexp.c	/^vim_regexec(prog, string, at_bol)$/;"	f
vim_regexp	regexp.h	/^} vim_regexp;$/;"	t	typeref:struct:__anon11
vim_regsub	regexp.c	/^vim_regsub(prog, source, dest, copy, magic)$/;"	f
vim_remove	os_unix.h	70;"	d
vim_rename	fileio.c	/^vim_rename(from, to)$/;"	f
vim_str2nr	charset.c	/^vim_str2nr(start, hexp, len, dooct, dohex)$/;"	f
vim_strchr	misc2.c	/^vim_strchr(string, n)$/;"	f
vim_stricmp	misc2.c	/^vim_stricmp(s1, s2)$/;"	f
vim_strncpy	misc2.c	/^vim_strncpy(to, from, len)$/;"	f
vim_strnicmp	misc2.c	/^vim_strnicmp(s1, s2, len)$/;"	f
vim_strnsave	misc2.c	/^vim_strnsave(string, len)$/;"	f
vim_strnsave_esc	misc2.c	/^vim_strnsave_esc(string, len)$/;"	f
vim_strnsave_up	misc2.c	/^vim_strnsave_up(string, len)$/;"	f
vim_strpbrk	misc2.c	/^vim_strpbrk(s, charset)$/;"	f
vim_strpbrk	misc2.c	798;"	d	file:
vim_strpbrk	vim.h	646;"	d
vim_strrchr	misc2.c	/^vim_strrchr(string, n)$/;"	f
vim_strsave	misc2.c	/^vim_strsave(string)$/;"	f
vim_strsave_escaped	misc2.c	/^vim_strsave_escaped(string, esc_chars)$/;"	f
vim_strsave_up	misc2.c	/^vim_strsave_up(string)$/;"	f
vim_strsize	charset.c	/^vim_strsize(s)$/;"	f
vim_strup	misc2.c	/^vim_strup(p)$/;"	f	file:
vim_tempname	fileio.c	/^vim_tempname(extra_char)$/;"	f
viminfo_add_at_front	ex_getln.c	/^static int	viminfo_add_at_front = FALSE;$/;"	v	file:
viminfo_errcnt	ex_cmds.c	/^static int  viminfo_errcnt;$/;"	v	file:
viminfo_error	ex_cmds.c	/^viminfo_error(message, line)$/;"	f
viminfo_filename	ex_cmds.c	/^viminfo_filename(file)$/;"	f	file:
viminfo_hisidx	ex_getln.c	/^static int	viminfo_hisidx[HIST_COUNT] = {0, 0, 0};$/;"	v	file:
viminfo_hislen	ex_getln.c	/^static int	viminfo_hislen[HIST_COUNT] = {0, 0, 0};$/;"	v	file:
viminfo_history	ex_getln.c	/^static char_u **viminfo_history[HIST_COUNT] = {NULL, NULL, NULL};$/;"	v	file:
viminfo_readstring	ex_cmds.c	/^viminfo_readstring(p)$/;"	f
viminfo_writestring	ex_cmds.c	/^viminfo_writestring(fd, p)$/;"	f
vimoption	option.c	/^struct vimoption$/;"	s	file:
vimrc_found	option.c	/^vimrc_found()$/;"	f
visibility	gui.h	/^    int		visibility;	    \/* Is window partially\/fully obscured? *\/$/;"	m	struct:Gui
vmode	vim.h	/^    int		vmode;		    \/* Visual mode character *\/$/;"	m	struct:VimClipboard
vpeekc	getchar.c	/^vpeekc()$/;"	f
vungetc	getchar.c	/^vungetc(c)	\/* unget one character (can only be done once!) *\/$/;"	f
w_alt_fnum	structs.h	/^    int		w_alt_fnum;	    \/* alternate file (for # and CTRL-^) *\/$/;"	m	struct:window
w_arg_idx	structs.h	/^    int		w_arg_idx;	    \/* current index in argument list *\/$/;"	m	struct:window
w_arg_idx_invalid	structs.h	/^    int		w_arg_idx_invalid;  \/* editing another file then w_arg_idx *\/$/;"	m	struct:window
w_botline	structs.h	/^    linenr_t	w_botline;	    \/* number of the line below the bottom$/;"	m	struct:window
w_buffer	structs.h	/^    BUF		*w_buffer;	    \/* buffer we are a window into *\/$/;"	m	struct:window
w_cline_height	structs.h	/^    int		w_cline_height;	    \/* current size of cursor line *\/$/;"	m	struct:window
w_cline_row	structs.h	/^    int		w_cline_row;	    \/* starting row of the cursor line *\/$/;"	m	struct:window
w_cursor	structs.h	/^    FPOS	w_cursor;	    \/* cursor's position in buffer *\/$/;"	m	struct:window
w_curswant	structs.h	/^    colnr_t	w_curswant;	    \/* The column we'd like to be at. *\/$/;"	m	struct:window
w_empty_rows	structs.h	/^    int		w_empty_rows;	    \/* number of ~ rows in window *\/$/;"	m	struct:window
w_fraction	structs.h	/^    int		    w_fraction;$/;"	m	struct:window
w_height	structs.h	/^    int		w_height;	    \/* number of rows in window, excluding$/;"	m	struct:window
w_jumplist	structs.h	/^    struct filemark w_jumplist[JUMPLISTSIZE];$/;"	m	struct:window	typeref:struct:window::filemark
w_jumplistidx	structs.h	/^    int		    w_jumplistidx;		\/* current position *\/$/;"	m	struct:window
w_jumplistlen	structs.h	/^    int		    w_jumplistlen;		\/* number of active entries *\/$/;"	m	struct:window
w_leftcol	structs.h	/^    colnr_t	w_leftcol;	    \/* starting column of the screen *\/$/;"	m	struct:window
w_lsize	structs.h	/^    char_u	*w_lsize;	    \/* array of line heights *\/$/;"	m	struct:window
w_lsize_lnum	structs.h	/^    linenr_t	*w_lsize_lnum;	    \/* array of line numbers for w_lsize *\/$/;"	m	struct:window
w_lsize_valid	structs.h	/^    int		w_lsize_valid;	    \/* nr. of valid LineSizes *\/$/;"	m	struct:window
w_next	structs.h	/^    WIN		*w_next;	    \/* link to next window (below) *\/$/;"	m	struct:window
w_old_cursor_fcol	structs.h	/^    colnr_t	w_old_cursor_fcol;  \/* first column for block visual part *\/$/;"	m	struct:window
w_old_cursor_lcol	structs.h	/^    colnr_t	w_old_cursor_lcol;  \/* last column for block visual part *\/$/;"	m	struct:window
w_old_cursor_lnum	structs.h	/^    linenr_t	w_old_cursor_lnum;  \/* last known end of visual part *\/$/;"	m	struct:window
w_old_curswant	structs.h	/^    colnr_t	w_old_curswant;	    \/* last known value of Curswant *\/$/;"	m	struct:window
w_old_visual_lnum	structs.h	/^    linenr_t	w_old_visual_lnum;  \/* last known start of visual part *\/$/;"	m	struct:window
w_p_lbr	structs.h	/^		w_p_lbr;$/;"	m	struct:window
w_p_list	structs.h	/^    int		w_p_list,$/;"	m	struct:window
w_p_nu	structs.h	/^		w_p_nu,$/;"	m	struct:window
w_p_pers	structs.h	/^		w_p_pers,	\/* for the window dependent Farsi functions *\/$/;"	m	struct:window
w_p_rl	structs.h	/^		w_p_rl,$/;"	m	struct:window
w_p_scroll	structs.h	/^    long	w_p_scroll;$/;"	m	struct:window
w_p_wrap	structs.h	/^		w_p_wrap,$/;"	m	struct:window
w_pcmark	structs.h	/^    FPOS	w_pcmark;	    \/* previous context mark *\/$/;"	m	struct:window
w_prev	structs.h	/^    WIN		*w_prev;	    \/* link to previous window (above) *\/$/;"	m	struct:window
w_prev_fraction_row	structs.h	/^    int		    w_prev_fraction_row;$/;"	m	struct:window
w_prev_pcmark	structs.h	/^    FPOS	w_prev_pcmark;	    \/* previous w_pcmark *\/$/;"	m	struct:window
w_redr_status	structs.h	/^    int		w_redr_status;	    \/* if TRUE status line must be redrawn *\/$/;"	m	struct:window
w_redr_type	structs.h	/^    int		w_redr_type;	    \/* type of redraw to be performed on win *\/$/;"	m	struct:window
w_ru_cursor	structs.h	/^    FPOS	w_ru_cursor;	    \/* cursor position shown in ruler *\/$/;"	m	struct:window
w_ru_empty	structs.h	/^    char	w_ru_empty;	    \/* TRUE if ruler shows 0-1 (empty line) *\/$/;"	m	struct:window
w_ru_virtcol	structs.h	/^    colnr_t	w_ru_virtcol;	    \/* virtcol shown in ruler *\/$/;"	m	struct:window
w_scrollbars	structs.h	/^    GuiScrollbar    w_scrollbars[2];		\/* Scrollbars for this window *\/$/;"	m	struct:window
w_set_curswant	structs.h	/^    int		w_set_curswant;	    \/* If set, then update w_curswant *\/$/;"	m	struct:window
w_status_height	structs.h	/^    int		w_status_height;    \/* number of status lines (0 or 1) *\/$/;"	m	struct:window
w_tagstack	structs.h	/^    struct taggy    w_tagstack[TAGSTACKSIZE];	\/* the tag stack *\/$/;"	m	struct:window	typeref:struct:window::taggy
w_tagstackidx	structs.h	/^    int		    w_tagstackidx;		\/* idx just below activ entry *\/$/;"	m	struct:window
w_tagstacklen	structs.h	/^    int		    w_tagstacklen;		\/* number of tags on stack *\/$/;"	m	struct:window
w_topline	structs.h	/^    linenr_t	w_topline;	    \/* number of the line at the top of$/;"	m	struct:window
w_valid	structs.h	/^    int		w_valid;$/;"	m	struct:window
w_valid_cursor	structs.h	/^    FPOS	w_valid_cursor;	    \/* last known position of w_cursor, used$/;"	m	struct:window
w_valid_leftcol	structs.h	/^    colnr_t	w_valid_leftcol;    \/* last known w_leftcol *\/$/;"	m	struct:window
w_vars	structs.h	/^    struct growarray w_vars;	    \/* internal variables, local to window *\/$/;"	m	struct:window	typeref:struct:window::growarray
w_virtcol	structs.h	/^    colnr_t	w_virtcol;	    \/* column number of the file's actual *\/$/;"	m	struct:window
w_wcol	structs.h	/^    int		w_wrow, w_wcol;	    \/* cursor's position in window *\/$/;"	m	struct:window
w_winpos	structs.h	/^    int		w_winpos;	    \/* row of topline of window in screen *\/$/;"	m	struct:window
w_wrow	structs.h	/^    int		w_wrow, w_wcol;	    \/* cursor's position in window *\/$/;"	m	struct:window
wait_return	message.c	/^wait_return(redraw)$/;"	f
where_paste_started	globals.h	/^EXTERN FPOS	where_paste_started;$/;"	v
which_scrollbars	gui.h	/^    int		which_scrollbars[3];\/* Which scrollbar boxes are active? *\/$/;"	m	struct:Gui
wid	gui.h	/^    Window	wid;		    \/* Window id of text area *\/$/;"	m	struct:Gui
wid	gui.h	/^    WindowPtr	wid;		    \/* Window id of text area *\/$/;"	m	struct:Gui
win	if_python.c	/^    WIN *win;$/;"	m	struct:__anon5	file:
win_alloc	window.c	/^win_alloc(after)$/;"	f
win_alloc_lsize	window.c	/^win_alloc_lsize(wp)$/;"	f
win_append	window.c	/^win_append(after, wp)$/;"	f	file:
win_chartabsize	charset.c	/^win_chartabsize(wp, c, col)$/;"	f
win_comp_pos	window.c	/^win_comp_pos()$/;"	f	file:
win_comp_scroll	window.c	/^win_comp_scroll(wp)$/;"	f
win_copy_options	option.c	/^win_copy_options(wp_from, wp_to)$/;"	f
win_count	window.c	/^win_count()$/;"	f
win_del_lines	screen.c	/^win_del_lines(wp, row, line_count, invalid, mayclear)$/;"	f
win_drag_status_line	window.c	/^win_drag_status_line(offset)$/;"	f
win_enter	window.c	/^win_enter(wp, undo_sync)$/;"	f
win_equal	window.c	/^win_equal(next_curwin, redraw)$/;"	f
win_exchange	window.c	/^win_exchange(Prenum)$/;"	f	file:
win_free	window.c	/^win_free(wp)$/;"	f
win_free_lsize	window.c	/^win_free_lsize(wp)$/;"	f
win_goto	window.c	/^win_goto(wp)$/;"	f	file:
win_goto_nr	window.c	/^win_goto_nr(winnr)$/;"	f
win_init	window.c	/^win_init(wp)$/;"	f
win_ins_lines	screen.c	/^win_ins_lines(wp, row, line_count, invalid, mayclear)$/;"	f
win_lbr_chartabsize	charset.c	/^win_lbr_chartabsize(wp, s, col, head)$/;"	f
win_line	screen.c	/^win_line(wp, lnum, startrow, endrow)$/;"	f	file:
win_linetabsize	charset.c	/^win_linetabsize(wp, s)$/;"	f
win_move_after	window.c	/^win_move_after(win1, win2)$/;"	f
win_new_height	window.c	/^win_new_height(wp, height)$/;"	f	file:
win_redr_ruler	screen.c	/^win_redr_ruler(wp, always)$/;"	f	file:
win_redr_status	screen.c	/^win_redr_status(wp)$/;"	f
win_remove	window.c	/^win_remove(wp)$/;"	f	file:
win_rest_invalid	screen.c	/^win_rest_invalid(wp)$/;"	f
win_rotate	window.c	/^win_rotate(upwards, count)$/;"	f	file:
win_setheight	window.c	/^win_setheight(height)$/;"	f
win_split	window.c	/^win_split(new_height, redraw, req_room)$/;"	f
win_update	screen.c	/^win_update(wp)$/;"	f	file:
win_valid	window.c	/^win_valid(win)$/;"	f
windgoto	screen.c	/^windgoto(row, col)$/;"	f
window	structs.h	/^struct window$/;"	s
window_created	gui.h	/^    int		window_created;	    \/* Has the window been created yet? *\/$/;"	m	struct:Gui
winlnum	structs.h	/^struct winlnum$/;"	s
wl_lnum	structs.h	/^    linenr_t	 wl_lnum;	    \/* last cursor line in the file *\/$/;"	m	struct:winlnum
wl_next	structs.h	/^    WINLNUM	*wl_next;	    \/* next entry or NULL for last entry *\/$/;"	m	struct:winlnum
wl_prev	structs.h	/^    WINLNUM	*wl_prev;	    \/* previous entry or NULL for first entry *\/$/;"	m	struct:winlnum
wl_win	structs.h	/^    WIN		*wl_win;	    \/* pointer to window that did set wl_lnum *\/$/;"	m	struct:winlnum
word_end_col	vim.h	/^    short_u	word_end_col;$/;"	m	struct:VimClipboard
word_start_col	vim.h	/^    short_u	word_start_col;$/;"	m	struct:VimClipboard
wp	gui.h	/^    struct window *wp;		    \/* Scrollbar's window, NULL for bottom *\/$/;"	m	struct:GuiScrollbar	typeref:struct:GuiScrollbar::window
write_buf	fileio.c	/^write_buf(fd, buf, len)$/;"	f	file:
write_lnum_adjust	fileio.c	/^write_lnum_adjust(offset)$/;"	f
write_no_eol_lnum	fileio.c	/^static linenr_t	write_no_eol_lnum = 0;	\/* non-zero lnum when last line of$/;"	v	file:
write_reg_contents	ops.c	/^write_reg_contents(name, str)$/;"	f
write_viminfo	ex_cmds.c	/^write_viminfo(file, forceit)$/;"	f
write_viminfo_bufferlist	buffer.c	/^write_viminfo_bufferlist(fp)$/;"	f
write_viminfo_filemarks	mark.c	/^write_viminfo_filemarks(fp)$/;"	f
write_viminfo_history	ex_getln.c	/^write_viminfo_history(fp)$/;"	f
write_viminfo_marks	mark.c	/^write_viminfo_marks(fp_out)$/;"	f
write_viminfo_registers	ops.c	/^write_viminfo_registers(fp)$/;"	f
write_viminfo_search_pattern	search.c	/^write_viminfo_search_pattern(fp)$/;"	f
write_viminfo_sub_string	ex_cmds.c	/^write_viminfo_sub_string(fp)$/;"	f
writefn	if_python.c	/^typedef void (*writefn)(char_u *);$/;"	t	file:
writer	if_python.c	/^writer(writefn fn, char_u *str, int n)$/;"	f	file:
wvsp_one	search.c	/^wvsp_one(fp, idx, s, sc)$/;"	f	file:
x11_display	os_unix.c	/^Display	    *x11_display = NULL;$/;"	v
x11_window	os_unix.c	/^Window	    x11_window = 0;$/;"	v
x_error_check	os_unix.c	/^x_error_check(dpy, error_event)$/;"	f	file:
x_error_handler	os_unix.c	/^x_error_handler(dpy, error_event)$/;"	f	file:
y_append	ops.c	/^static int		y_append;	    \/* TRUE when appending *\/$/;"	v	file:
y_array	ops.c	/^    char_u	**y_array;	\/* pointer to array of line pointers *\/$/;"	m	struct:yankreg	file:
y_current	ops.c	/^static struct yankreg	*y_current;	    \/* ptr to current yankreg *\/$/;"	v	typeref:struct:yankreg	file:
y_previous	ops.c	/^static struct yankreg	*y_previous = NULL; \/* ptr to last written yankreg *\/$/;"	v	typeref:struct:yankreg	file:
y_regs	ops.c	/^} y_regs[NUM_REGISTERS];$/;"	v	typeref:struct:yankreg	file:
y_size	ops.c	/^    linenr_t	y_size;		\/* number of lines in y_array *\/$/;"	m	struct:yankreg	file:
y_type	ops.c	/^    char_u	y_type;		\/* MLINE, MCHAR or MBLOCK *\/$/;"	m	struct:yankreg	file:
yank_register_mline	ops.c	/^yank_register_mline(regname)$/;"	f
yankreg	ops.c	/^static struct yankreg$/;"	s	file:
