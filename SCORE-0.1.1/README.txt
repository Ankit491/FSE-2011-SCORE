You can get the latest version of SCORE, as well as news and announcements at
SCORE's homepage: http://pswlab.kaist.ac.kr/tools/score

SETUP 
=====
A user has to build CIL to instrument a target C program for concolic testing.
A modified distribution of CIL is included in the cil/ directory.  To build
CIL, simply run "./configure" and "make" in the cil/ directory. You may need to
download OcamlC compiler version 3.08 or higher from http://caml.inria.fr/. 

SCORE also depends on Z3, an SMT solver tool and library. The Z3 libraries are
included in the lib/ directory. You must set LD_LIBRARY_PATH to include a
directory that has libz3-gmp.so (i.e., lib/)

PREPARING A PROGRAM FOR SCORE 
=============================
To use SCORE on a C program, use functions SCORE_int, SCORE_char, etc.,
declared in "include/score.h", to generate symbolic inputs for your program.
For examples, see the programs in examples/ and benchmarks/.

For simple, single-file programs, you can use the build script "bin/scorec" to
instrument and compile your target program.

In addition, SCORE can instrument multi-file programs. However, it depends on
target programs' build script. You can take a look at an example of vim, in
benchmarks/.  

RUNNING SCORE 
=============
SCORE consists of a server and clients. A SCORE server program manages SCORE
clients to distribute workloads and each SCORE client program performs concolic
testing. The sever and the clients are connected through TCP/IP networks. 

SERVER: 
    bin/score_server -p PORT [ -t TIMEOUT ] [ -n NUM_CLIENTS ] [ -h ]

PORT indicates a listening port to which SCORE clients will connect. TIMEOUT
indicates the maximum execution time of SCORE in seconds. If -t option is not
set, SCORE will run until all possible execution paths are explored.
NUM_CLIENTS indicates a number of clients of SCORE. SCORE server will wait
until all clients are connected to server and start distributed concolic
testing after all clients are connected. If -n option is not set, SCORE server
waits one client as a default.

Example commands to run the server that waits one client on the port 12345: 
    $ bin/score_server -p 12345 -n 16

This should produce output like: 
    score_server: listen on port 12345.
    score_server: wait 16 clients.

and the server waits for the specified number of clients to respond. When
TIMEOUT is reached or no more test cases can be generated by the clients, the
server finishes with the following output:
    score_server: # of total messages: 36
    score_server: # of total generated TCs: 38020 

You can find more details for options by run bin/score_server -h

CLIENT:
SCORE client is run as 
    bin/score_client -i ITERATION -t TARGET_PROGRAM \
                     -a SERVER_IP -p SERVER_PORT [ -o DIRECTORY ] [ -h ]

ITERATION indicates the maximum number of test cases generated by a SCORE
client. TARGET_PROGRAM indicates a command to execute the target program. 
SERVER_IP and SERVER_PORT indicate the IP address of the SCORE server and
the port number of the SCORE server. DIRECTORY indicates the output directory
of the generated test cases. If -o option is not set, the generated test 
cases will not be saved. 

Example commands to run the client that uses distributed depth-first search
and connects the server run on 127.0.0.1:12345 to test 'test' program:
    $ bin/score_client -i 10 -t ./test -a 127.0.0.1 -p 12345

This should produce output roughly like:

    Iteration 0 (0s): covered 0 branches [0 reached funs (total 0 branches)].
    Iteration 1 (0s): covered 1 branches [1 reached funs (total 2 branches)].
    ...
    Iteration 10 (0s): covered 132 branches [10 reach funs (total 154 branches)].
    Total waiting time: 0.989149 s
    # of generated TCs: 10 
    
Each iteration corresponds to a single run of the target program under test.
At each iteration, score_client prints the number of branches that have been
covered through iterations so far.  In addition, score_client reports the
number of reached functions so far and the number of all branches in those
reached functions.  Total waiting time is a total amount of time during which
score_client waits to receive test case pairs from another client when it does
not have any test case pairs to work on. 

NOTE: score_client and scorec generate several intermediate files.  
"branches" is generated by scorec and used by score_client. score_client 
produces "coverage", a list of the ID's of all covered branches, and "input",
a list of integer values as the input test case for the target program. 

PRINTING TESTCASE
=================
If -o option of the SCORE client is set, the generated test cases, 
testcase_1.test, testcase_2.test, ..., testcase_N.test, will be stored in the 
specified directory. The generated test cases can be read with the 
bin/print_testcase utility. 

    bin/print_testcase TESTFILE

This should produce output roughly like:

    # of symbolic inputs: 2
    sym input 0
    name: x
    size: 4
    data: \x00\x00\x00\x00

    sym input 1
    name: y
    size: 4
    data: \x00\x00\x00\x01

print_testcase prints the number of total symbolic inputs of the given test
case in the first line followed by the name, size in bytes, and value in
hexadecimal representation of each symbolic input. 

RUNNING BENCHMARK  
=================
We use 6 benchmark programs from the SIR benchmark(http://sir.unl.edu).  In
each benchmark program directory (see benchmarks/), there exist three scripts,
build.sh for building a target benchmark program, clean.sh for cleaning the
temp files and run.sh for running a target benchmark program. 

LICENSE
=======
SCORE is distributed under the revised BSD license.  See LICENSE for details.

SCORE uses a modified version of CREST.  See bin/LICENSE.crest

SCORE uses the Z3 SMT solver. Z3 is distributed under Microsoft Research
License Agreement. See lib/LICENSE.Z3 for details.

SCORE uses a modified version of CIL (C Intermetiate Language) for
instrumentation. CIL is distributed under the revised BSD license. see
cil/LICENSE for details.

